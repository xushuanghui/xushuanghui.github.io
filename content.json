{"pages":[{"title":"","text":"Flutter与原生开发的区别 跨平台，热更新。上手快，但深入还需要iOS和Android原生的支持，硬件能力都是调用的原生的。 Flutter 就是这样的一个开发框架。一个跨平台 UI 解决方案 Flutter 是由 Google 开发的，一个跨平台 UI 解决方案。换句话说，它原则上只管 UI 的问题，如果涉及到平台本身的一些功能，比如调用蓝牙、摄像头，一般还是需要原生代码去操作。但现在也会有一些第三方库帮我们解决这些问题。 绘图引擎 Skia Flutter 使用 Skia 作为它的绘图引擎。Skia 已经被 Google 收购，目前很多 Google 旗下的产品都是用 Skia 绘制的，包括 Android。 Android 内置了 Skia，但 iOS 没有，所以在打 iOS 安装包的时候，会把 Skia 一起打进去。这就导致了，用同一份 Flutter 代码打包之后，iOS 的包要比 Android 的包大一些。 1、没有桥接层 React Native、Weex等技术都是跨终端的框架，然而性能跟原生App存在很大差距。这是由于它们的工作原理决定的： React Native、Weex等技术多了一个桥接层，所以界面渲染会慢一些，由于UI渲染非常频繁，想要不卡顿，基本上比较难，性能和用户体验跟原生代码有差距。而这恰恰是Flutter的优势所在： Dart可以被编译成不同平台的本地代码，让Flutter不通过桥接层直接跟平台通信，自然性能会快一些。 3、Flutter Engine虚拟机 Flutter是依靠Flutter Engine虚拟机在iOS和Android上运行的，Flutter Engine使用C/C++编写，开发人员通过Flutter框架直接和API在内部进行交互，所以具有输入低延迟和UI渲染高帧速率的特点 4、自带渲染引擎 Flutter使用谷歌自己的Skia渲染引擎，而Android系统自带Skia引擎，iOS平台上Flutter也会把Skia引擎打包到APP中，从而实现了高效渲染。而React Native通过桥接层访问原生UI，操作频繁就容易出性能问题。 综合所述，Flutter 是性能最接近原生代码 的一种开发框架，未来也会是构建谷歌Fuchsia应用的主要方式，前途不可限量， Flutter与原生通信概述flutter与原生通信主要有三种方式：MethodChannel、EventChannel、BasicMessageChannel，这三种方式均各有适用的场景：MethodChannel用于native与flutter的方法调用，EventChannel用于native单向的向flutter发送广播消息，BasicMessageChannel用于native与flutter之间的消息互发。 MethodChannel用于双方之间的方法互调，使用步骤是：1.创建一个MethodChannel对象，传入MethodChannel名称。2.使用setMethodHandle对对方调用自己的方法进行监听，通过回调中的MethodCall对象方法名判断、获取方法参数，并且返回调用结果。3.使用invokeMethod来调用对方的方法，可传入方法名，方法参数，以及监听对方的回调结果。","link":"/flutter%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E5%8C%BA%E5%88%AB.html"},{"title":"flutter状态管理框架provider和Get","text":"为什么需要状态管理？首先，为什么需要状态管理？根据笔者的经验，这是因为 Flutter 基于声明式 2 构建 UI ，使用状态管理的目的之一就是解决「声明式」开发带来的问题。 「声明式」开发是一种区别于传原生的方式，所以我们没有在原生开发中听到过状态管理，那如何理解「声明式」开发呢？ 「声明式」VS「命令式」分析以最经典的的计数器例子分析： [ 如上图所示：点击右下角按钮，显示的文本数字加一。Android 中可以这么实现：当右下角按钮点中时，拿到 TextView 的对象，手动设置其展示的文本。 实现代码如下： 1234567891011121314// 一、定义展示的内容private int mCount =0; // 二、中间展示数字的控件 TextViewprivate TextView mTvCount; // 三、关联 TextView 与 xml 中的组件mTvCount = findViewById(R.id.tv_count) // 四、点击按钮控制组件更新private void increase( ){ mCount++; mTvCounter.setText(mCount.toString()); } 而在 Flutter 中，我们只需要使变量增加之后调用 setState((){}) 即可。setState 会刷新整个页面，使得中间展示的值进行变更。 12345678910// 一、声明变量int _counter =0; // 二、展示变量 Text('$_counter')// 三、变量增加，更新界面setState(() { _counter++; }); 可以发现，Flutter 中只对 _counter 属性进行了修改，并没有对 Text 组件进行任何的操作，整个界面随着状态的改变而改变。 所以在 Flutter 中有这么一种说法: UI = f(state): 上面的例子中，状态 (state) 就是 _counter 的值，调用 setState 驱动 f build 方法生成新的 UI。 那么，声明式有哪些优势，并带来了哪些问题呢？ 优势: 让开发者摆脱组件的繁琐控制，聚焦于状态处理 习惯 Flutter 开发之后，回到原生平台开发，你会发现当多个组件之间相互关联时，对于 View 的控制非常麻烦。 而在 Flutter 中我们只需要处理好状态即可 (复杂度转移到了状态 → UI 的映射，也就是 Widget 的构建)。包括 Jetpack Compose、Swift 等技术的最新发展，也是在朝着「声明式」的方向演进。 声明式开发带来的问题 没有使用状态管理，直接「声明式」开发的时候，遇到的问题总结有三个: 逻辑和页面 UI 耦合，导致无法复用/单元测试、修改混乱等 难以跨组件 (跨页面) 访问数据 无法轻松的控制刷新范围 (页面 setState 的变化会导致全局页面的变化) 接下来，我先带领大家逐个了解这些问题，下一章向大家详细描述状态管理框架如何解决这些问题。 1) 逻辑和页面 UI 耦合，导致无法复用/单元测试、修改混乱等 2637×1299 217 KB 一开始业务不复杂的时候，所有的代码都直接写到 widget 中，随着业务迭代，文件越来越大，其他开发者很难直观地明白里面的业务逻辑。并且一些通用逻辑，例如网络请求状态的处理、分页等，在不同的页面来回粘贴。 这个问题在原生上同样存在，后面也衍生了诸如 MVP 设计模式的思路去解决。 2) 难以跨组件 (跨页面) 访问数据 2388×1288 222 KB 第二点在于跨组件交互，比如在 Widget 结构中，一个子组件想要展示父组件中的 name 字段，可能需要层层进行传递。 又或者是要在两个页面之间共享筛选数据，并没有一个很优雅的机制去解决这种跨页面的数据访问。 3) 无法轻松的控制刷新范围 (页面 setState 的变化会导致全局页面的变化) 最后一个问题也是上面提到的优点，很多场景我们只是部分状态的修改，例如按钮的颜色。但是整个页面的 setState 会使得其他不需要变化的地方也进行重建，带来不必要的开销。 Provider、Get 状态管理框架设计分析Flutter 中状态管理框架的核心在于这三个问题的解决思路，下面一起看看 Provider、Get 是如何解决的： 解决逻辑和页面 UI 耦合问题传统的原生开发同样存在这个问题，Activity 文件也可能随着迭代变得难以维护，这个问题可以通过 MVP 模式进行解耦。 简单来说就是将 View 中的逻辑代码抽离到 Presenter 层，View 只负责视图的构建。 3438×1332 226 KB 这也是 Flutter 中几乎所有状态管理框架的解决思路，上图的 Presenter 你可以认为是 Get 中的 GetController、Provider 中的 ChangeNotifier 或者 Bloc 中的 Bloc。值得一提的是，具体做法上 Flutter 和原生 MVP 框架有所不同。 我们知道在经典 MVP 模式中，一般 View 和 Presenter 以接口定义自身行为 (action)，相互持有接口进行调用 。 3405×1348 269 KB 但 Flutter 中不太适合这么做，从 Presenter → View 关系上 View 在 Flutter 中对应 Widget，但在 Flutter 中 Widget 只是用户声明 UI 的配置，直接控制 Widget 实例并不是好的做法。 而在从 View → Presenter 的关系上，Widget 可以确实可以直接持有 Presenter，但是这样又会带来难以数据通信的问题。 这一点不同状态管理框架的解决思路不一样，从实现上他们可以分为两大类： 通过 Flutter 树机制 解决，例如 Provider 通过 依赖注入，例如 Get。 1) 通过 Flutter 树机制处理 V → P 的获取 2039×1721 172 KB 1234567891011121314151617abstract class Element implements BuildContext { /// 当前 Element 的父节点 Element? _parent; }abstract class BuildContext { /// 查找父节点中的T类型的State T findAncestorState0fType&lt;T extends State&gt;( ); /// 遍历子元素的element对象 void visitChildElements(ElementVisitor visitor); /// 查找父节点中的T类型的 InheritedWidget 例如 MediaQuery 等 T dependOnInheritedWidget0fExactType&lt;T extends InheritedWidget&gt;({ Object aspect }); ……} Element 实现了父类 BuildContext 中操作树结构的方法 我们知道 Flutter 中存在三棵树，Widget、Element 和 RenderObject。所谓的 Widget 树其实只是我们描述组件嵌套关系的一种说法，是一种虚拟的结构。但 Element 和 RenderObject 在运行时实际存在，可以看到 Element 组件中包含了 _parent 属性，存放其父节点。而它实现了 BuildContext 接口，包含了诸多对于树结构操作的方法，例如 findAncestorStateOfType，向上查找父节点；visitChildElements 遍历子节点。 在一开始的例子中，我们可以通过 context.findAncestorStateOfType一层一层地向上查找到需要的 Element 对象，获取 Widget 或者 State 后即可取出需要的变量。 3064×1444 270 KB provider 也是借助了这样的机制，完成了 View → Presenter 的获取。通过 Provider.of 获取顶层 Provider 组件中的 Present 对象。显然，所有 Provider 以下的 Widget 节点，都可以通过自身的 context 访问到 Provider 中的 Presenter，很好地解决了跨组件的通信问题。 2) 通过依赖注入的方式解决 V → P 树机制很不错，但依赖于 context，这一点有时很让人抓狂。我们知道 Dart 是一种单线程的模型，所以不存在多线程下对于对象访问的竞态问题。基于此 Get 借助一个全局单例的 Map 存储对象。通过依赖注入的方式，实现了对 Presenter 层的获取。这样在任意的类中都可以获取到 Presenter。 3233×1506 340 KB 这个 Map 对应的 key 是 runtimeType + tag，其中 tag 是可选参数，而 value 对应 Object，也就是说我们可以存入任何类型的对象，并且在任意位置获取。 解决难以跨组件 (跨页面) 访问数据的问题这个问题其实和上一部分的思考基本类似，所以我们可以总结一下两种方案特点： 3478×1500 312 KB Provider 依赖树机制，必须基于 context 提供了子组件访问上层的能力 Get 全局单例，任意位置可以存取 存在类型重复，内存回收问题 解决高层级 setState 引起不必要刷新的问题最后就是我们提到的高层级 setState 引起不必要刷新的问题，Flutter 通过采用观察者模式解决，其关键在于两步： 观察者去订阅被观察的对象； 被观察的对象通知观察者。 1528×1677 161 KB 系统也提供了 ValueNotifier 等组件的实现： 123456789101112/// 声明可能变化的数据ValueNotifier&lt;int&gt; _statusNotifier = ValueNotifier(0); ValueListenableBuilder&lt;int&gt;( // 建立与 _statusNotifier 的绑定关系 valueListenable: _statusNotifier, builder: (c, data, _) { return Text('$data'); })///数据变化驱动 ValueListenableBuilder 局部刷新 _statusNotifier.value += 1; 了解到最基础的观察者模式后，看看不同框架中提供的组件： 比如 Provider 中提供了 ChangeNotifierProvider: 1234567891011121314151617181920212223class Counter extend ChangeNotifier { int count = 0; /// 调用此方法更新所有观察节点 void increment() { count++; notifyListeners(); }}void main() { runApp( ChangeNotifierProvider( /// 返回一个实现 ChangeNotifier 接口的对象 create: (_) =&gt; Counter(), child: const MyApp( ), ), ); }/// 子节点通过 Consumer 获取 Counter 对象 Consumer&lt;Counter&gt;( builder:(_, counter, _) =&gt; Text(counter.count.toString()) 还是之前计数器的例子，这里 Counter 继承了ChangeNotifier 通过顶层的 Provider 进行存储。子节点通过 Consumer 即可获取实例，调用了 increment 方法之后，只有对应的 Text 组件进行变化。 同样的功能，在 Get 中，只需要提前调用 Get.put 方法存储 Counter 对象，为 GetBuilder 组件指定 Counter 作为泛型。因为 Get 基于单例，所以 GetBuilder 可以直接通过泛型获取到存入的对象，并在 builder 方法中暴露。这样 Counter 便与组件建立了监听关系，之后 Counter 的变动，只会驱动以它作为泛型的 GetBuilder 组件更新。 123456789101112131415class Counter extends GetxController { int count = 0; void increase() { count++; update(); }}/// 提前进行存储final counter = Get.put(Counter( )); /// 直接通过泛型获取存储好的实例GetBuilder&lt;Counter&gt;( builder: (Counter counter) =&gt; Text('${counter.count}') ); 实践中的常见问题在使用这些框架过程中，可能会遇到以下的问题： Provider 中 context 层级过高123456789101112131415class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Provider( create: (_) =&gt; const Count(), child: MaterialApp( home: Scaffold( body: Center(child: Text('${Provider.of&lt;Counter&gt;(context).count}')), ), ), ); }} 1355×1287 174 KB 如代码所示，当我们直接将 Provider 与组件嵌套于同一层级时，这时代码中的 Provider.of(context) 运行时抛出 ProviderNotFoundException。因为此处我们使用的 context 来自于 MyApp，但 Provider 的 element 节点位于 MyApp 的下方，所以 Provider.of(context) 无法获取到 Provider 节点。这个问题可以有两种改法，如下方代码所示： 改法 1: 通过嵌套 Builder 组件，使用子节点的 context 访问: 12345678910111213141516171819class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return Provider( create: (_) =&gt; const Count(), child: MaterialApp( home: Scaffold( body: Center( child: Builder(builder: (builderContext) { return Text('${Provider.of&lt;Counter&gt;(builderContext).count}'); }), ), ), ), ); }} 改法 2: 将 Provider 提至顶层: 123456789101112131415161718192021void main() { runApp( Provider( create: (_) =&gt; Counter(), child: const MyApp(), ), );}class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( body: Center(child: Text('${Provider.of&lt;Counter&gt;(context).count}')), ), ); }} Get 由于全局单例带来的问题–重点正如前面提到 Get 通过全局单例，默认以 runtimeType 为 key 进行对象的存储，部分场景可能获取到的对象不符合预期，例如商品详情页之间跳转。由于不同的详情页实例对应的是同一 Class，即 runtimeType 相同。如果不添加 tag 参数，在某个页面调用 Get.find 会获取到其它页面已经存储过的对象。同时 Get 中一定要注意考虑到对象的回收，不然很有可能引起内存泄漏。要么手动在页面 dispose 的时候做 delete 操作，要么完全使用 Get 中提供的组件，例如 GetBuilder，它会在 dispose 中释放。 2050×1722 151 KB GetBuilder 中在 dispose 阶段进行回收: 1234567891011121314151617@overridevoid dispose() { super.dispose(); widget.dispose?.call(this); if (_isCreator! || widget.assignId) { if (widget.autoRemove &amp;&amp; GetInstance().isRegistered&lt;T&gt;(tag: widget.tag)) { GetInstance().delete&lt;T&gt;(tag: widget.tag); } } _remove?.call(); controller = null; _isCreator = null; _remove = null; _filter = null;} Get 与 Provider 优缺点总结Provider ChangeNotifier、Consumer、ChangeNotifierProvider 依赖树机制，必须基于 context 提供了子组件访问上层的能力 Provider 中的 ChangeNotifier、Get 中的 GetController、 或者 Bloc 中的 Bloc。 Get GetController、put、find、GetBuilder 全局单例，任意位置可以存取，很方便。 依赖注入put(getController)、取：find 自带路由，路由跳转方便get.to/ get.back 存在类型重复，内存回收问题 正如前面提到 Get 通过全局单例，默认以 runtimeType 为 key 进行对象的存储，部分场景可能获取到的对象不符合预期，例如商品详情页之间跳转。由于不同的详情页实例对应的是同一 Class，即 runtimeType 相同。如果不添加 tag 参数，在某个页面调用 Get.find 会获取到其它页面已经存储过的对象。同时 Get 中一定要注意考虑到对象的回收，不然很有可能引起内存泄漏。要么手动在页面 dispose 的时候做 delete 操作，要么完全使用 Get 中提供的组件，例如 GetBuilder，它会在 dispose 中释放。 通过本文，我向大家介绍了状态管理的必要性、它解决了 Flutter 开发中的哪些问题以及是如何解决的，与此同时，我也为大家总结了在实践中常见的问题等，看到这里你可能还会有些疑惑，到底是否需要使用状态管理？ 在我看来，框架是为了解决问题而存在。所以这取决于你是否也在经历一开始提出的那些问题。如果有，那么你可以尝试使用状态管理解决；如果没有，则没必要过度设计，为了使用而使用。 其次，如果使用状态管理，那么 Get 和 Provider 哪个更好？ 这两个框架各有优缺点，我认为如果你或者你的团队刚接触 Flutter，使用 Provider 能帮助你们更快理解 Flutter 的核心机制。而如果已经对 Flutter 的原理有了解，Get 丰富的功能和简洁的 API，则能帮助你很好地提高开发效率。","link":"/flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6provider%E5%92%8CGet.html"},{"title":"","text":"内购前准备APP内集成IAP代码之前需要先去开发账号的ITunes Connect进行以下三步操作： 1，后台填写银行账户信息 2，配置商品信息，包括产品ID，产品价格等 3，配置用于测试IAP支付功能的沙箱账户。 填写银行账户信息一般交由产品管理人员负责，开发者不需要关注，开发者需要关注的是第二步和第三步。 配置内购商品沙箱账户内购流程 恢复购买内购有4种：消耗型项目，非消耗型，自动续期订阅，非续期订阅。 其中”非消耗型“和”自动续期订阅“需要提供恢复购买的功能，例如创建一个恢复按钮，不然审核很可能会被拒绝。 123//调起苹果内购恢复接口[[SKPaymentQueue defaultQueue] restoreCompletedTransactions];复制代码 “消耗型项目”和“非续期订阅”苹果不会提供恢复的接口，不要调用上述方法去恢复，否则有可能被拒！！！ “非续期订阅”也是跨设备同步的，所以原则上来说也需要提供恢复购买的功能，但需要依靠app自建的账户体系恢复，不能用上述苹果提供的接口。 内购掉单掉单是用户付款买商品，钱扣了，商品却没到账。掉单一旦发生，用户通常会很生气地来找客服。然后客服只能找开发人员把商品给用户手动加上。显然，伤害用户的体验，特别是伤害付费用户的体验，是一件相当糟糕的事情。 掉单是如何产生的呢？这需要从IAP支付的技术流程说起。 IAP的支付流程： 1，发起支付 2，扣费成功 3，得到receipt（支付凭据） 4，去后台验证凭据获取商品交易状态 5，返回数据，验证成功前端刷新数据 漏单情况一： 2到3环节出问题属于苹果的问题，目前没做处理。 漏单情况二： 3到4的时候出问题，比如断网。此时前端会把支付凭据持久化存储下来，如果期间用户卸载APP此单在前端就真漏了，如果没有协助，下次重新打开app进入购买页会先判断有无未成功的支付，有就提示用户，用户选择找回，重走4，5流程。这一步看产品需求怎么做，可以让用户自主选择是否恢复未成功的支付也可以前端默默恢复就行。 漏单情况三： 4到5的时候出问题。此时后台其实已经成功，只是前端没获取到数据，当漏单处理，下次进入的时候先刷新数据即可。","link":"/ios%E5%86%85%E8%B4%AD.html"},{"title":"","text":"一、oc与swift在内存方面有哪些优化、oc与swift有哪些区别 理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。 数据结构 Swift的数据结构可以大体拆分为：Class，Struct，Enum。 组件关系 组件关系可以分为：inheritance，protocols，generics。 方法分派方式 方法分派方式可以分为Static dispatch和Dynamic dispatch。 内存分配总结 值类型存储在栈区。 每个值类型变量都有其自己的数据副本，并且对一个变量的操作不会影响另一个变量。 引用类型存储在其他位置（堆区），我们在内存中有一个指向该位置的引用。 引用类型的变量可以指向相同类型的数据。 因此，对一个变量进行的操作会影响另一变量所指向的数据。 Struct: String、Array、Dictionary struct默认分布在栈上， 赋值方式是值类型，进行值的拷贝copy，值类型是线程安全的、 Struct 没有引用计数不会循环引用导致内存泄漏，而且调用方式是静态调用，编译期就确定了函数的执行地址，其函数的调用通过内联（inline）的方式进行优化，其内存连续，减少了函数的寻址过程以及内存地址的偏移计算，其运行相比于动态派发更加高效。 Class 内存分布在堆上，引用类型，赋值方式指针拷贝，使用引用计数，又考考虑线程安全加锁，相对struct慢一点儿，调用方式默认动态分派，但可以使用final，private关键字修饰，使得方法或属性只对当前类可见，会认定为静态分派来提升性能 Swift的堆是通过双向链表实现的 从初始化角度，Class相比Struct需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。 优化方式： 对于频繁操作（比如通信软件的内容气泡展示），尽量使用Struct替代Class，因为栈内存分配更快，更安全，操作更快。 Reference countingSwift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。 对于基本数据类型的Struct来说，没有堆内存分配和引用计数的管理，性能更高更安全， 复杂的结构体，包含了引用类型的结构体相比Class，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。 引用计数总结 Class在堆区分配内存，需要使用引用计数器进行内存管理。 基本类型的Struct在栈区分配内存，无引用计数管理。 包含强类型的Struct通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，Class只会有一份。 结构体除了属性的存储更安全、效率更高之外，其函数的派发也更高效。由于结构体的类型被 final 修饰，不能被继承，其内部函数属于静态派发，在编译期就确定了函数的执行地址，其函数的调用通过内联（inline）的方式进行优化，其内存连续，减少了函数的寻址过程以及内存地址的偏移计算，其运行相比于动态派发更加高效。 1.类属于引用类型，结构体属于值类型 2.类允许被继承，结构体不允许被继承 3.类中的每一个成员变量都必须被初始化，否则编译器会报错，而结构体不需要，编译器会自动帮我们生成init函数，给变量赋一个默认值 Method Dispatch 能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。 Static dispatch更快，而且静态分派可以进行内联等进一步的优化，使得执行更快速，性能更高。 多态的情况，我们不能在编译期确定最终的类型，这里就用到了Dynamic dispatch动态分派 动态分派更灵活，但是因为有查表和跳转的操作 动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组 Method Dispatch总结 1Class`默认使用`Dynamic dispatch 使用Static dispatch代替Dynamic dispatch提升性能 我们知道Static dispatch快于Dynamic dispatch，如何在开发中去尽可能使用Static dispatch。 inheritance constraints继承约束 我们可以使用final关键字去修饰Class，以此生成的Final class，使用Static dispatch。 access control访问控制 private关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行Static dispatch。 编译器可以通过whole module optimization检查继承关系，对某些没有标记final的类通过计算，如果能在编译期确定执行的方法，则使用Static dispatch。 Struct默认使用Static dispatch。 Swift快于OC的一个关键是可以消解动态分派。 总结 Swift提供了更灵活的Struct，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。 Protocol TypeExistential ContainerExistential Container是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型Protocol Type，这些数据类型因为不共享同一继承关系（这是V-Table实现的前提），并且内存空间尺寸不同，使用Existential Container进行管理，使其具有存储的一致性。 protocol witness table的引用 管理Protocol Type的方法分派 Protocol Witness Table（PWT）为了实现Class多态也就是引用语义多态，需要V-Table来实现，但是V-Table的前提是具有同一个父类即共享相同的继承关系，但是对于Protocol Type来说，并不具备此特征，故为了支持Struct的多态，需要用到protocol oriented programming机制，也就是借助Protocol Witness Table来实现（细节可以点击Vtable和witness table实现，每个结构体会创造PWT表，内部包含指针，指向方法具体实现）。 Value Witness Table和Protocol Witness Table通过分工，去管理Protocol Type实例的内存管理（初始化，拷贝，销毁）和方法调用。 Protocol Type多态总结 支持Protocol Type的动态多态（Dynamic Polymorphism）行为。 通过使用Witness Table和Existential Container来实现。 对于大数的拷贝可以通过Indirect Storage间接存储来进行优化。 Message dispatch 我们通过上面说明结合Static dispatch VS Dynamic dispatch对方法分派方式有了了解。这里需要对Objective-C的方法分派方式进行说明。 熟悉OC的人都知道，OC采用了运行时机制使用obj_msgSend发送消息，runtime非常的灵活，我们不仅可以对方法调用采用swizzling，对于对象也可以通过isa-swizzling来扩展功能，应用场景有我们常用的hook和大家熟知的KVO。 大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。 Swift可以通过关键字dynamic对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。 注意：我们常见的关键字@ObjC并不会改变Swift原有的方法分派机制，关键字@ObjC的作用只是告诉编译器，该段代码对于OC可见。 总结来说，Swift通过dynamic关键字的扩展后，一共包含三种方法分派方式：Static dispatch，Table dispatch和Message dispatch。下表为不同的数据结构在不同情况下采取的分派方式： 1.MRC: 任何一个对象，刚创建的时候，初始的引用计数为1 当使用alloc、new或者copy创建一个对象时，对象的引用计数器默认就是1 当没有任何人持有这个对象时，系统才会回收这个对象, 也就是说 当对象的引用计数器为0时，对象占用的内存就会被系统回收 retain消息，引用计+1， release,计数-1 dealloc方法 当一个对象的引用计数器值为0时，这个对象即将被销毁，其占用的内存被系统回收 对象即将被销毁时系统会自动给对象发送一条dealloc消息(因此，从dealloc方法有没有被调用,就可以判断出对象是否被销毁) 野指针：一个指针指向已经释放的对象 autorelease的原理实质上是什么？ autorelease实际上只是把对release的调用延迟了，对于每一个autorelease，系统只是把该对象放入了当前的autorelease pool中,当该pool被释放时,该pool中的所有对象会被调用release。 2、ARC ARC判断一个对象是否需要释放不是通过引用计数来进行判断的，而是通过强指针来进行判断的。那么什么是强指针? 强指针 默认所有对象的指针变量都是强指针 不允许调用对象的 release方法 不允许调用 autorelease方法 重写父类的dealloc方法时，不能再调用 [super dealloc]; 局部变量释放对象随之被释放 清空指针对象随之被释放","link":"/swift%E7%9B%B8%E5%AF%B9oc%E7%9A%84%E4%BC%98%E5%8C%96.html"},{"title":"","text":"1、项目流程总结立项、需求与交互评审、技术评审、排期、开发、测试、验收、回归、上线 需求评审：逻辑和细节问题提早确认，风险点提出，尽量避免中后期需求变更的可能性 技术评审：现在各端都需要出技术评审文档，说明项目难点，技术方案，风险点等。当我觉得可以适当按照项目评级来定，看各端需求侧重点在服务端还是前端。现在工作中写各个流程文档比较多，可能大点儿厂现在都这样，但适当删减能提高效率，适当的卷能够提高员工的一些产出，太卷并不能提高效率。 排期：各个细分任务排期表，每日项目进度表。 2、图片图片缓存处理：1、图片展示组件都有一个大图片和一个小图，对应大图片没有加载完，先小图请求uri：mini。然后用大图替换。 2、 iOS 图片缓存策略 大小没有限制，时间默认为一周， 使用LRU淘汰算法缓存 3、Url做为key，首先从内存中获取，如果内存没有就从磁盘中获取，如果磁盘中也没有，那就从网络上获取这张图片，再缓存到内存和磁盘上。 网络优化：1、针对我们电商图片、视频处理很重要，大部分都是图片、和视频展示，优化图片加载也是网络优化的一部分。 3、业务模块1、营销导购：首页、营销落地页、短视频、商详、搜索 2、交易售后：购物车、加购 3、账户：个人中心、登陆注册、国际化语言等 4、路由组件化方案对比**URL RouterTarget-ActionProtocol-Class 5、OC、swift、flutter、RN优缺点5、网络优化1、DNS优化 【核心解决安全问题】 防止DNS的劫持，Eg：百度App Feed业务，OS劫持率由0.12%降低到0.0002%，Android劫持率由0.25%降低到0.05% 降低网络时延，在调度不准确的情况下，会增大网络的时延，降低用户的体验 2、连接优化【核心解决速度问题】待补充 降低延迟 提升成功率 3、弱网优化 【核心解决弱网问题】 问题点1：移动网络环境如此复杂，我们如何确定当下就是弱网环境 问题点2: 确定为弱网环境下，我们如何提升弱网下的成功率，降低弱网下的时延，进而提升用户的网络体验 *解决方案***： 主动网络探测：就是触发某些条件后，主动的进行网络探测，并按照一定的条件检测出是否弱网状态 大概逻辑步骤 ① 网络请求成功时，如何进入弱网状态？检查weakhttprtt的阀值（eg：95分位）大于这个值就会进入弱网检测，为了防止频繁触发探测加了时间间隔维度（eg：10分钟） ② 网络请求成功时，如何退出弱网状态？检查goodhttprtt的阀值（取决业务的设定），小于这个值证明要切换回正常网络状态，为了防止频繁触发探测加了时间间隔维度（eg：30秒） 线下模拟测试得出：只要小于这个阀值，检测结果必然是正常状态，如果大于或者等于这个阀值，不能证明一定不是正常网络，所以需发起网络探测（成功回调里，加上时间间隔30秒，还加入阶梯次数限制） ③ 网络请求失败时，如何判断进入弱网状态？首先会判断连续失败次数，及ping和dns query的探测 被动网络采集：每一次网络请求的所有细节都进行记录，并按照一定的条件将信息进行上报，上层根据条件判断是否是弱网状态。百度App基于cronet的NQE进行二次定制开发（待研究） 优化收益： 1.弱网开启QUIC后，网络连接成功率提升，平均耗时降低 2.弱网开启QUIC预连接后，QUIC协议的pv从XX涨到XX 3.弱网开启复合连接后，bad状态下耗时降低XX%，offline状态下耗时降低XX% 四、弱网优化之性能优化1.网络状态设置：无网络提示 2.设定不同网络状态下的超时时间 3.多子模块请求的“延迟性” 对一次请求所有接口数据页面，可以进行分段“延迟”请求 优先模块：数据量少，业务上优先显示 延迟模块：数据量大，延迟加载处理等 4.固定模块加入缓存机制、或增量更新机制 有些页面数据进行数据缓存处理，一定有效时间内再次请求可直接从缓存读取，可避免空白页影响体验 5、前后端采用gzip方式请求和响应,数据压缩和解压, 请求header添加：”content-encoding” 为 “gzip” QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征： QUIC 协议的主要目的，是为了整合 TCP 协议的可靠性和 UDP 协议的速度和效率。 1）利用缓存，显著减少连接建立时间； 2）改善拥塞控制，拥塞控制从内核空间到用户空间； 3）没有 head of line 阻塞的多路复用； 4）前向纠错，减少重传； 5）连接平滑迁移，网络状态的变更不会影响连接断线。 QUIC 协议非常复杂，因为它做了太多事情： 为了实现传输的可靠性，它基本上实现并且改进了整个 TCP 协议的功能，包括序列号，重传，拥塞控制，流量控制等； 为了实现传输的安全性，它又彻底重构了 TLS 协议，包括证书压缩，握手消息，0RTT 等。虽然后续可能会采用 TLS1.3 协议，但是事实上是 QUIC 推动了 TLS1.3 的发展； 为了实现传输的并发性，它又实现了 HTTP2 的大部分特性，包括多路复用，流量控制等。","link":"/wholee%E6%80%BB%E7%BB%93.html"},{"title":"","text":"1、chatgpt创作文案 2、配音神器 3、33帧","link":"/%E5%88%9B%E4%BD%9C%E8%A7%86%E9%A2%91.html"},{"title":"","text":"会员动态化json:js.md 会员动态化json/js 这一套思想实现的技术点都是js和原生交互，把通用的、基础的功能抽成原生组件，而动作、传值(组件之间、界面之间)通过js来完成 // &quot;delegate&quot;,&quot;realHide&quot;,&quot;subComponentModels&quot;,&quot;parentComponent&quot;,&quot;valChangeSubject&quot; { &quot;pageTitle&quot;: &quot;设置会员体系&quot;, &quot;pageId&quot;: &quot;页面id&quot;, &quot;script&quot;: &quot;member_system_step_one.js&quot;, // 当前模板页对应的js上下文 &quot;onload&quot;: &quot;onload()&quot;, // js上下文中的onload()方法 &quot;onChange&quot;: &quot;&quot;, &quot;leftBarConfig&quot;: { &quot;title&quot;: &quot;返回&quot;, &quot;action&quot;: &quot;onLeftBtnClicked()&quot; }, &quot;rightBarConfig&quot;: { &quot;title&quot;: &quot;下一步&quot;, &quot;action&quot;: &quot;onRightBtnClicked()&quot; }, &quot;header&quot;: { &quot;components&quot;: [] }, &quot;components&quot;: [ { &quot;component&quot;: &quot;组件名称(唯一性)&quot;, &quot;config&quot;: { &quot;id&quot;: &quot;s_0_4(具体模板中的id)&quot;, &quot;name&quot;: &quot;对应上传/下发时的key&quot;, &quot;value&quot;: &quot;即当前组件上传/下发的值&quot;, &quot;subpage&quot;: &quot;子页面&quot;, &quot;subComponents&quot;: [子组件], &quot;parentComponent&quot;：&quot;父组件(原生代码中使用)&quot;, &quot;preValue&quot;: &quot;初始值&quot;, &quot;prop&quot;: { &quot;title&quot;: &quot;▪︎ 结束日期&quot;, &quot;placeholder&quot;: &quot;必选&quot;, &quot;requiredTip&quot;: &quot;请设置结束日期项&quot; }, &quot;style&quot;: { //样式 &quot;descTextColor&quot;: &quot;0xff0000&quot; }, &quot;realHide&quot;: &quot;组件隐藏&quot;, } } ], &quot;footer&quot;: { &quot;components&quot;: [] }, } &nbsp; 解析 jsonModel -&gt; item -&gt; view 模板页 解析成原生对象(此时components仍是Array) 加载&quot;script&quot;指定的js文件 由components生成对应的组件model、item，给models设置value(有的化)、尝试设置组件预览状态、通知各model数据准备完成、尝试执行组件的onChange/onload方法(同时存在只执行onload)、执行整个页面的onload方法、reload页面 原生/js交互 1、原生调用js onload onChange willChangeFunctionName onPackageInputParam buttonAction &quot;value&quot;: &quot;js:getShopsFromLastPage()&quot; &quot;action&quot;: &quot;subpageDeleteTriggerTimePrivilege()&quot; &nbsp; 2、js调用原生 JSExecutor.log() // log JSExecutor.alertMsg()、JSExecutor.alertMsgTitlesAction() // 弹窗提示 JSExecutor.getVal()、JSExecutor.setVal() // 获取/设置组件的值 JSExecutor.getProp()、JSExecutor.setProp() // 获取/设置prop的属性 JSExecutor.getExtendInfo // 获取聚合数据 JSExecutor.getFormDataCallBack // 获取所有组件的value JSExecutor.requestWithAction() // 提交数据 JSExecutor.routeWithUrl()、JSExecutor.routeWithUrlCallBack() // 路由跳转 JSExecutor.removePage()、JSExecutor.exit() // 活动页返回/退出 JSExecutor.gotoPage() // 跳转到下个json配置页，释放之前的页面 JSExecutor.gotoSubpage() // 跳转到下个json配置页 JSExecuter.changeLeftBarConfig()、JSExecutor.changeRightBarConfig() // 导航按钮 JSExecuter.changePageTitle() // 页面标题 JSExecuter.execFuncWithParamsInPage() // 执行前一个页面的js方法 &nbsp; 扩展性 初始化接口 ASCComponentModelProperty JSExecutor &nbsp; &nbsp; &nbsp;","link":"/%E5%8A%A8%E6%80%81%E5%8C%96json%EF%BC%9Ajs.html"},{"title":"","text":"RunLoop卡顿检测 在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责. 众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿. 在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题. 寻找卡顿的切入点监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的: 1int32_t __CFRunLoopRun(){ //通知即将进入runloop __CFRunLoopDoObservers(KCFRunLoopEntry); do { // 通知将要处理timer和source __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); __CFRunLoopDoBlocks(); //处理非延迟的主线程调用 __CFRunLoopDoSource0(); //处理UIEvent事件 //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); // 即将进入休眠 __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); // 等待内核mach_msg事件 mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts(); // Zzz... // 从等待中醒来 __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); // 处理因timer的唤醒 if (wakeUpPort == timerPort) __CFRunLoopDoTimers(); // 处理异步方法唤醒,如dispatch_async else if (wakeUpPort == mainDispatchQueuePort) __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() // UI刷新,动画显示 else __CFRunLoopDoSource1(); // 再次确保是否有同步的方法需要调用 __CFRunLoopDoBlocks(); } while (!stop &amp;&amp; !timeout); //通知即将退出runloop __CFRunLoopDoObservers(CFRunLoopExit);} 不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿. 量化卡顿的程度要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下: 1static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ MyClass *object = (__bridge MyClass*)info; object-&gt;activity = activity;}- (void)registerObserver{ CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL}; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);} 只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手. 为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下: 1static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ MyClass *object = (__bridge MyClass*)info; // 记录状态值 object-&gt;activity = activity; // 发送信号 dispatch_semaphore_t semaphore = moniotr-&gt;semaphore; dispatch_semaphore_signal(semaphore);}- (void)registerObserver{ CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL}; CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); // 创建信号 semaphore = dispatch_semaphore_create(0); // 在子线程监控时长 dispatch_async(dispatch_get_global_queue(0, 0), ^{ while (YES) { // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms) long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC)); if (st != 0) { if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting) { if (++timeoutCount &lt; 5) continue; NSLog(@&quot;好像有点儿卡哦&quot;); } } timeoutCount = 0; } });} 记录卡顿的函数调用监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下: 1PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];NSData *data = [crashReporter generateLiveReport];PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter withTextFormat:PLCrashReportTextFormatiOS];NSLog(@&quot;------------\\n%@\\n------------&quot;, report); 当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了! 文章示例代码下载:PerformanceMonitor.zip","link":"/%E5%8D%A1%E9%A1%BF%E6%A3%80%E6%B5%8B.html"},{"title":"","text":"+ 结合js+json实现客户端业务逻辑 [TOC] 引言在客户端传统开发中，主要的页面渲染和逻辑都是用原生代码实现，这便有个缺点：当业务逻辑太多，组件太多，各种条件判断写起来长又繁琐，可读性差，添加新功能或者更改小需求也都不那么清爽容易。那么我们便需要有一个框架可以实现： 页面组件拆分，属于组件自己的逻辑，委托给组件自己处理：如View是否要更换隐藏；数据是否更改等； 基本组件View和逻辑可只写一份，无限使用，有效减少代码重复。如：文字输入长度及对长度的判断等。 采用动态化编程，在运行过程中，需要的时候，再把函数引进来（那就是js了） 页面配置及函数逻辑可提取出来，ios和android共用一份，有效避免了需求点客户端不一致的问题。 后期可以把页面配置和业务逻辑用服务器下发给客户端，这样更改一些配置和逻辑时，就可用服务器直接下发更改，不用发新包让用户升级更新了。 而本次介绍的框架满足了以上所有的需求。 简介页面配置和业务逻辑实现客户端共用，页面配置用json实现，实现业务逻辑的函数用js实现。页面配置以组件为单位，每个组件有自己的属性和方法。业务逻辑自然是在和用户操作互动中调用的。 ##流程图 页面从开始到渲染结束的流程图： 12345678910graph TDA[开始]--&gt;B[从服务器及本地内存获取页面的初始化数据init_data]B--&gt;C[服务器及本地内存获取页面的展示数据entity_data]C--&gt;D[指定页面的json文件和js文件]D--&gt;E[解析json文件]E--&gt;F[根据对应场景执行对应的js方法] json解析json结构： 页面的基本信息，如本页面所用的js文件名，页面唯一id等(必须) header基本配置（如页面顶部部分内容不跟随页面上下滚动，则为header，非必须） 主页面的基本组成（非必须，但一般情况都肯定有） footer基本配置（如页面底部部分内容不跟随页面上下滚动，则为footer，非必须） json解析流程图 12345graph TDA[开始]--&gt;B[解析表单配置,如pageTitle,pageId,onload,components,header,footer等]B--&gt;C[解析header/footer/components中的组件并加载]C--&gt;D[页面加载完成]D--&gt;E[执行json模板onload方法及组件的onload/onchange方法,onload在对应js实现] #表单json配置 ##pageTitle 页面标题 ##pageId 页面标识 ##script json对应的js文件名，此json中配置的函数名在js中实现 ##onload 页面初始化时调用的js函数名 ##onChange 页面数据更改时或初始化时调用的js函数名 ##header 不随页面滚动的页面头部配置 components ： 由头部不滚动组件组成 ##footer 不随页面滚动的页面底部配置 components ： 由底部不滚动组件组成 ##rightBarConfig 右上角按钮配置 title : 按钮显示名称 action : 点击按钮后的操作，js函数名 ##leftBarConfig 左上角按钮配置 title : 按钮显示名称 action : 点击按钮后的操作，js函数名 ##components 页面主体组件列表,是随页面滚动的所有组件组合。每个组件配置查看components中组件配置 #components中组件配置 components中每个组件是拥有独立逻辑的最小View组件。是json解析中的重头戏。每个组件配置分为：component和config ##component 目前有64种组件类型。 在开发过程中，查看需要的组件是否已存在，如果不存在，则需新建一个通用组件，尽量写的通用一些，方便后期多出调用；如果新建的只是针对特殊情况的组件最好把使用范围加入到组件名称中 secTitle用于显示分类的题目 使用场景：只有左边有文字，右边为空的题目。支持图片显示、题目描述等； 特有属性： rightTextLink：查看样例。 ###input 输入内容，内容长度一般在6个字符左右。内容类型和用户输入的内容在同一行展示 使用场景：需要用户在当前页面弹出手机键盘输入内容 特有属性： verify：正则判断 keyboardType：键盘类型 maxLen：最长长度 minLen：最小长度 lenVerTip：长度不匹配提醒 ###multiInput 输入内容，内容长度一般在20个字符以上。内容类型和用户输入的内容分行显示 使用场景：需要用户自定义编辑，会跳转到输入文本界面 特有属性： navTitle：输入文本界面标题 verify：正则判断 keyboardType：键盘类型 maxLen：最大长度 minLen：最小长度 lenVerTip：长度不匹配提醒 editPageConfig：编辑页面的配置 number输入数字 使用场景：需要用户在当前页面弹出手机数字键盘输入数字 特有属性： keyboardType：弹出键盘类型；Number:整数；DotNum：有小数点的数字 min：允许输入的最小值 minVerTip：小于最小值时的提醒 max：允许输入的最大值 rate：倍率 regex：代码中没被使用 imageSelect添加图片 使用场景：调用手机图库或者手机相机添加图片在页面上 select在特定范围值中做出选择 使用场景：指定可选择的内容，让用户进行选择，指定的内容在页面下方弹出框中展示 switch开关 使用场景：功能设置，用户可选择是否需要此功能 特有属性： previewLink ： 预览消息内容跳转链接 date以滚动方式选择日期 使用场景：活动设置日期时 time以滚动方式选择时间 使用场景：活动设置时间时 week选择每周中的某些天 使用场景：以每周为单位，选择每周哪些天设置有效 text文字提示 使用场景：只展示提示文字，没有任何其他功能 特有属性： isFill：是否填充颜色 button按钮 特有属性： isFill：是否填充颜色 action: 点击之后执行的js函数名。 lineChart折线统计图表。 agree用于一些协议/活动方案的同意 特有属性： content：显示内容 ph：占位符 protocol：协议 showTitle：点击之后弹出对话框的标题 showDetail：点击之后弹出对话框的内容 shopSelect选择门店，跳转到内页门店列表进行选择 特有属性： chainOnly：只在连锁类型展示；已废弃，可用hideInXX代替 shopsPageTopTip：选择门店的顶部提示 shopFilterService：过滤器。请求使用门店的服务器类型、地址及参数。 addCoupon添加优惠券，跳转到优惠券的页面选择优惠券进行添加。 特有属性： max：最多能添加max中不同的优惠券 itemMax：最多优惠券数量 targetEntityIdKey：只见json中配置的地方，没有看到用的地方。 nextPageConfig：下一页数据配置 numTitle：每张添加的优惠券每人赠送张数 filter：点击添加优惠券之后。获取优惠券的过滤器。通过配置参数获取到服务端满足条件的优惠券加以展示 dateSelect选择日期时间段。可设置多个“日期时间段” forwardText跳转文字。点击文字，可以跳转到详细设置页面。如：优惠券-&gt;现金券-&gt;券的有效期设置 特有属性： unclickAbleInPreview: 只读模式下是否可点击。（值为1不可点击，到跳转页面的箭头隐藏。值为0/默认：展示，且可点击到跳转页面 actionOfValueTextProvider: 跳转下一页的js函数名。带括号 fixSpace空白占位。可设置高度。 menuSelect 多商品选择组件 guide活动页面头部提示性文字, 通常结构包括提示文字, 右下角链接文字, 右下角链接地址 coupon营销活动中用到的的优惠券券面及优惠券数量 kouBeiTicketHeader口碑优惠券详情页面标题栏 multiSelect多选组件 couponCount优惠券的统计。 createCoupon添加单品现金券 koubeiShopSelect口碑适用门店 customSet设置内容后返回。精准营销-&gt;短信设置/公众号设置 brieflyDisplayInfo列表展示组件。展示内容比较简单 addMemberCard添加会员卡。 discountTermSelect选择优惠方式 multiGoodsSelect多商品选择，已废弃，使用menuSelect替代 dfireTag标签选择。二维火标签组件, 点击选择相应的标签 smsInfo短信余量信息。 selfRechargeSwitch火小二自助充值开关专用组件。包含大量特定逻辑 selfRechargeSwitch火小二自助充值开关专用组件, 大量特定逻辑写在这个组件中 addSingleCoupon只能添加一张优惠券，可对发放优惠券的数量进行设置(不常用)；使用地方：微信小游戏中-&gt;活动商品兑换设置-&gt;添加优惠券 addExchange添加兑换（不常用）使用地方：微信小游戏中-&gt;添加兑换 discountSelect选择优惠方案。使用地方：新客有礼-&gt;打折方式选择‘按优惠方案“-&gt;请选择优惠方案 （本组件可用select代替） addTriggerTimePrivilege添加满次优惠。消费有礼-&gt;满次优惠 addTriggerAmountPrivilege添加满额优惠。消费有礼-&gt;满额优惠 officialAccount设置公众号公众号。节日营销中用到 customDateMM月dd日形式的数据格式，节日营销中用到 share分享活动。微信小游戏数据报表-&gt;分享活动 singleCouponList活动商品兑换设置。微信小游戏活动设置-&gt;活动商品兑换设置 addMenu添加商品。爆品活动-&gt;添加商品（爆品活动已不再使用） menu爆品活动中（爆品活动已不再使用） discountEffortsDetail列表展示组件。口碑营销计划方案详情。 provideTips提示：二维火提供，样式 ：-text- postCard活动卡片内容设置。 addRechargeDiscount添加充值优惠组件。卡充值优惠设置-&gt;添加充值优惠 fillDataByType按类型选择数据组件；标签-&gt;添加筛选条件 officialAccount添加公众号。节日营销-&gt;添加公众号 addDiscountNPrivilege组合优惠设置促销活动优惠 addZuHeGoods添加组合优惠的商品 memberSystemLevel会员等级设置 stepIndicator会员三个等级的进度条 cardSelectBackground选择卡片背景 addNewRechargeDiscount添加充值优惠。 会员管理-&gt;设置会员等级-&gt;v1等级，添加充值优惠 sectionsForBalanceUsage消费区间扣款设置；会员等级设置第三部-&gt;消费区间扣款设置 discountForCashier会员体系打折方案选择；会员管理-&gt;v2等级-&gt;打折方案。 picWordList图文详情排版;精准营销-&gt;图文详情排版 couponPreview优惠券的预览； 精准营销-&gt;已获得以下优惠券 特有属性： type:当前券的类型。4为优惠券。 groupTitle精准营销的图文详情排版的题目。可点击 showPreview精准营销-&gt;活动页面预览 materialSet翻盘游戏界面 textPreview消息通知渠道的短信预览 addFlopGameMenu翻牌大作战-&gt;添加活动菜品 flopGameStepView翻牌大作战中的步骤指示器 kouBeiPlanSummary口碑优惠方案优惠力度概述 appletShow没有被用 ##config config配置主要参数：id 、name、prop、style id控件id,该component代码中的唯一识别。 name控件名称。个人认为是多余的 prop与业务有关的配置。详细介绍见prop options单选的所有选项。当component类型为“select“时，需要配置此项 value组件的默认值配置 adapter适配器。目前用于优惠券列表展示。目前只与component类型为“createCoupon”一起用 属性： modelFormat: 适配器填充数据合法化 Components:在适配器中展示的组件 subpage子页面。已弃用。用JSExecutor.gotoSubpage代替。 subComponents与组件有从属关系的组件。比如，“switch”开启之后展示的组件,便可以配置成“switch”的subComponents style用于配置组件填充色、边框、圆角、高度等布局样式。 ##prop 与业务有关的数据配置，所有值为0/1的字段，默认值为0 ###title 组件展示名称 ###maxLen 对组件字符长度的限制 ###lenVerTip 输入长度非法时的提示内容，与maxLen的要求长度保持一致 ###required 是否必须有值，1必须，0，非必须； ###requiredTip 与required对应，如果required为1时，配置此项；用户没有填写此required组件时，提示。 invalidTip值不对的提示。命名不错。但是没有普及型。目前只用在“优惠券过期，请先删除”的提示。要不要和willChangeTip合用想一个合适的名字 willChangeTip非基础提示。经用户的修改之后对修改内容不正确的提示。使用时，需开发在原生代码中进行非法判断。 ###placeholder 用户未输入时的默认显示 ###disable 是否可用:1不可用，0 可用； 使用场景：只为展示，不可操作 ###hide 是否隐藏 1 隐藏；0 显示 ###onload js脚本函数名，View加载时调用 ###onChange js脚本函数名，View数据变化时调用 inputParam用户已设置过的参数配置。 actionNamejs脚本函数名。具体实现在对应的js中。目前此参数主要用于页面中跳转。 remark组件描述。灰色小字 customRemark组件特定样式描述：带有样式的非常见的灰色小字样式。 组成属性：1.text:显示的文字 2.color:字体颜色 3.value:text中参数的值 isShowLine是否显示下划线。 styleVersion样式版本。此参数可以用来给组件设置不同的​样式。 ###willChangeFunctionName js脚本函数名，用以检查value是否合法。 使用场景：改变Value的时候进行验证 e.g : 在添加会员等级时，如果等级1没有被设置，用户便添加等级2，此时便要运用此方法给出用户”请先完成会员等级2设置”，并返回false，阻止用户此次操作 JSExecutor详解JSExecutor作用在客户端开发中，所有与用户行为的交互都是基于View实现的,如：点击一个按钮，滑动一个组件。 如今我们想要用json和js分担一部分本地代码的工作，而这部分工作是：活动的页面及操作。 想要在客户端使用js函数，需要在本地代码中映射js函数，JSExecutor便是用来为JS函数做本地映射。 JSExecutor的所有方法详解setVal(String id, Object value)参数：id,json中每个component的id，为此component的唯一标识；object，想为id赋予的值 作用：赋值 使用场景：赋值 getVal(String id)参数：id,为想要获取值的component的id 作用：取值 使用场景：取值 setProp(String id, String key, Object value)参数介绍： id: 要配置的组件id key: 要配置的prop中的属性名 value: 要配置的属性值 作用：配置特定组件某项属于Prop的属性；如组件是否隐藏 简例：设置id为s_1的组件隐藏 1JSExecutor.setProp('s_1','hide',1) getProp(String id, String key)参数介绍： id: 获取prop中某一项配置的组件id key: 获取配置的属性名 作用：获取指定组件的某项属于Prop的属性值 简例：获取id为s_1的组件filter值 1JSExecutor.getProp(”s_1“, &quot;filter&quot;) setOptions(String id, Object options)参数介绍： id: 获取options的组件id options: 设置组件的options（选择范围）值 作用：配置指定组件（与选择有关）的选择范围 简例：设置组件类型为select的s_1组件选择范围为1、2、3 12345var options = []options.push({'value' : &quot;1&quot;, 'showStr' : &quot;1&quot;})options.push({'value' : &quot;2&quot;, 'showStr' : &quot;2&quot;})options.push({'value' : &quot;3&quot;, 'showStr' : &quot;3&quot;})JSExecutor.setOptions('s_1', options) requestWithAction(String url, int serviceType, final Object params, final Function function)参数介绍： url:请求url serviceType：服务器类型；目前客户端只有1、8有效 params： 请求参数 function：请求成功后执行的方法。 作用：请求服务器，并在请求成功之后继续流程 简例：对页面设置保存到服务器，并在成功保存后退出页面 123JSExecutor.requestWithAction('/coupon/v1/save', 8, params, function (result) { JSExecutor.exit(true);}); alertMsg(String content)参数介绍： content：显示弹出框内容 作用：弹框提示 简例：当用户选择的结束日期小于开始日期时，进行提示 123if (endDate &lt; startDate) { JSExecutor.alertMsg('结束日期不得早于开始日期'); } getFormDataCallBack(Function function)参数介绍： 获取页面数据之后执行function 作用：对页面的所有数据校验，处理 简例：对数据进行校验 ，如果每个数据都是正确的 就保存，如果有数据失败则return false 1234567891011JSExecutor.getFormDataCallBack(function (failed, failedMessage, data) { JSExecutor.log(data) if (failed == 1) { failedMessage += ''; if (failedMessage.length &gt; 0) { JSExecutor.alertMsg(failedMessage); } return false; } //数据保存 }) getExtendInfo()作用 ：获取页面 extendInfo，此数据包含两部分 “init_data”: 页面初始化时需要的数据，一般为一些页面标识字段，如：“id”, “type”等 “entity_data”：页面展示数据 简例： 1var mExtendInfo = JSON.parse(JSON.stringify(JSExecutor.getExtendInfo())) hasDataUnsave()作用：判断页面是否还有数据没有被保存 简例 ：判断如果页面有数据未保存，则弹框让用户选择 1234567if (JSExecutor.hasDataUnsave()) { JSExecutor.alertMsgTitlesAction('内容有变更尚未保存，确定要退出吗？', ['取消', '确定'], function (index) { if (index == 1) { //用户选择确定后进行下一步操作 } });} alertMsgTitlesAction(Object msg, Object btnTexts, final Function action)参数介绍 msg : 弹框内容 弹框按钮 点击按钮之后的操作 简例： 12345JSExecutor.alertMsgTitlesAction('内容有变更尚未保存，确定要退出吗？', ['取消', '确定'], function (index) { if (index == 1) { //用户选择确定后进行下一步操作 } }); execFuncWithParamsInPage(String aPageId, String functionName, Object… args)参数说明： aPageId: 执行的方法所在的page_id functionName : 需要执行的函数名，不带括号 args：函数需传入的参数 作用： 执行page_id里面的函数 简例：执行page_id 为“step_two”中函数名为“updateLevelData”的函数，需传入的参数有两个 1JSExecutor.execFuncWithParamsInPage('step_two', 'updateLevelData', [data, getInitDataByKey(INDEX)]); exit(boolean resultOk)参数说明 resultOk:设置退出页面的结果码(resultCode) 作用 提供给当前页面的调用者（与当前页面不同的Activity/UIViewControllers）的结果码。 简例： 目前每个配置页面都有保存功能和退出功能。 如当前页面有需要保存的数据，当用户点击保存后跳转页面，则在成功保存之后，返回exit(true)标记成功保存，进行页面跳转 1JSExecutor.exit(true); 但是用户并不想保存数据，只想退出，这时候就需要exit(false)来标记用户并没有保存，进行退出的页面跳转 1JSExecutor.exit(false); removePage(Object aPgId)参数 aPgId : 页面的id号 作用： 针对同一个Activity/UIViewControllers 中有不同的页面，回到上一个页面 简例： 在一个分为两步设置的活动中，第一页面设置完毕后到第二页面（pageId: “two”）时想回到第一页面（pageId: “one”)。 1JSExecutor.removePage('two'); 其他1.为啥json配置中，有的action对应的js函数名有括号（），有的没有括号？ ​ 不带括号的一般是需要参数的​ 带括号不需要参数 2.开发过程中，js的调试不是很容易","link":"/%E5%8A%A8%E6%80%81%E5%8C%96%E5%BC%95%E5%85%A5js+json%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91.html"},{"title":"","text":"面试复盘 杭州嗨宝贝有限公司 一面电话面 自我介绍问了项目(着重介绍了json+js+原生的动态化方案)，针对首页是如何架构的 项目中做过哪些优化 iOS 点击事件如何传递与响应的 二面 介绍下你觉得最有成就的项目 动态化UI，目前的json+js方案：组件间耦合问题如何解决，有没有优化方案；如果不用js如何设计组件间通讯 项目上线后做了哪些监控，如何做的 如何做监控接口的响应时长；如何进一步获取接口请求各阶段耗时？ // 获取请求各阶段时长 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics 对今后的规划，然后根据你的回答追问针对此规划做了什么？ 杭州炎魂网络(游戏公司) 一面 自我介绍 合并2个单链表表示的数(链表存储数是head是高位)，用新的链表表示 如何进行分支管理的，问了下分支拉取和合并都是开发自己来做的吗(这个地方有点奇怪，不知道为何如此问？) 有没有遇到深浅拷贝的问题(自己比较注意，没遇到啥问题) 你写的代码有没有出现过线上问题，讲一下。（调了一个逻辑出错的问题讲了下） 有什么想问我的：(表示了自己没接触过游戏，想了解岗位的工作职责，目前的团队情况等) 杭州雅乐集团 一面 介绍 谈一下项目中的问题，讲一下视频列表的优化 swift 逃逸和非逃逸闭包，逃逸闭包会进行值捕获吗 sqlite left join 和 right join的区别 谈谈为什么要在项目中使用swift 项目中使用了flutter，谈谈flutter的优势 面试官：有什么想问我的 二面 介绍下你觉得成就感最高的一个项目 问了url-scheme和target-action路由的问题，如何和h5交互；universal-link了解吗，有何作用；一个universal-link请求过来了如何进行处理 针对项目问了一些问题，rac原理，冷热信号(这里我说反了，冷热搞错了) swift混编如何做到oc和swift相互调用的；为甚pod中swift调用oc不需要bridge文件？ 分主工程和pod，主工程可通过bridge文件让swift调用oc方法，pod不用；pod中有xcode生成pod名+swift.h文件包含暴露给oc的接口 多线程问题，属性中 atomic 能保证线程安全吗，atomic是互斥锁还是自旋锁(回答互斥，不能保证安全)；追问要如何做(通过NSLock对临界区代码加锁)，追问能对该方法进行递归调用吗(不能) 设计一个多线程方案讲一个变量准确累加到2000(通过信号量，gcd栅栏+异步添加累加任务到并行队列无法保证准确累加)；举一个你之前的多线程使用的例子 谈谈iOS的内存管理，进而引导到NSString和NSNumber 的问题(为何lldb输出的有时候是值，有时候是地址) swift混编遇到哪些问题; swift的方法调用方式 说说你用过的设计模式；适配器和桥接模式区别；设计模式主要思想，是为了解决什么问题 安全问题：你们的接口如何设计加密的；敏感信息如何存储；非对称和对称加密有何区别，谈谈应用场景 平时看wwdc吗(回答不喜欢看视频，但是会看文档)，追问你最近看了什么东西，谈一谈(说了苹果改进storeKit的介绍)；接着聊了苹果iap内购丢单串单的问题，如何应对这些问题 三面(leader面) 简单介绍下自己 一个项目来了，你是如何参与到当中，起了什么作用 问了一些原公司项目迭代的问题(说了2周一个版本，中间可能还有日常)；追问，迭代如此快，如何保证项目质量，中间做了哪些工作 谈一谈swift中的协议 了解了之前项目iOS端和安卓端的日活，crash率(我说0.5%左右)；面试官说很高，如果让利设计一个线上监控，你会如何考虑 如何设计一个应用分享组件(分享到微信，QQ这种) 有什么想了解的：问了一些组织结构，项目进度方面的问题","link":"/%E5%A4%8D%E7%9B%98.html"},{"title":"","text":"待学习1、从0-1完整的开发大型商业项目 、 搭建App目录结构，从下到上，使用Pods管理第三方框架，将第三方框架进行二次封装，供给顶层使用，尽可能减少各模块之间的耦合度，只为更清晰。 1、flutter boost 共享同一个引擎的方案老的方案： 我们把共享的 Flutter View 当成一个画布，然后用一个 Native 的容器作为逻辑的页面。每次在打开一个容器的时候我们通过通信机制通知 Flutter View 绘制成当前的逻辑页面，然后将 Flutter View 放到当前容器里面。 新的方案： 主要思路是由 Native 容器 Container 通过消息驱动 Flutter 页面容器 Container，从而达到 Native Container 与 Flutter Container 的同步目的。我们希望做到 Flutter 渲染的内容是由 Naitve 容器去驱动的。 简单的理解，我们想做到把 Flutter 容器做成浏览器的感觉。填写一个页面地址，然后由容器去管理页面的绘制。在 Native 侧我们只需要关心如果初始化容器，然后设置容器对应的页面标志即可。 通过扁平化 key-value 映射的形式去维护当前所有的页面，每个页面拥有一个唯一的 id Native 容器通过消息机制通知 Flutter Coordinator 新的容器被创建 2、flutter优化方案Flutter Inspector检查工具1、通过“Select Widget Mode”我们可以快速查看陌生页面的布局实现方式。 2、点击 “Highlight Repaints” 图标，它会 为所有 RenderBox 绘制一层外框，并在它们重绘时会改变颜色 3、Performance Overlay(性能图层)找卡顿等 Flutter布局优化 1、尽量小的widget。方便代码复用，减少widget重建 2、尽量避免在 build() 中执行耗时操作 3、多用const构造器不用重建 4、建议使用 ListView 和 GridView 的 builder 方法它们只会绘制可见的列表内容。 5、“Highlight Oversizeded Images”，它会识别出那些解码大小超过展示大小的图片，指定 cacheWidth 和 cacheHeight 为展示大小。 尽量不要为 Widget 设置半透明效果，而是考虑用图片的形式代替，这样被遮挡的 Widget 部分区域就不需要绘制了； 控制 build 方法耗时，将 Widget 拆小，避免直接返回一个巨大的 Widget，这样 Widget 会享有更细粒度的重建和复用； 对列表采用懒加载而不是直接一次性创建所有的子 Widget，这样视图的初始化时间就减少了 3、oc与swift相互调用 –桥接oc调用swift:productName-swift.h。@objc swift调用oc:在product-bridgeing.h ProjectName-Bridging-Header.h Alamofireflutter webviewcoregraphicsiOS平台研发和优化经验 技术沙龙2、webview离线化方案 html,js,css,资源文件下载到本地，加载本地文件，减少网络请求 Nsurlprotocol拦截、hook私有apI注册scheme，所有请求会走caninitrequest方法，return ture or false，做本地操作。 body问题丢失，httprequeststream去获取。 下载时机、json配置文件url为key、对应离线开关配置。 3、直播性能监控 4、WKWebview预加载、播放器预热 动态UI更新方案 ai模拟训练师 业务：40 稳定性：20 性能优化：20 团队分享：20","link":"/%E5%BE%85%E5%AD%A6%E4%B9%A0%E3%80%81%E5%BE%85%E5%8A%9E.html"},{"title":"","text":"12.4： 1、了解资金流向，情绪，持续性。 2、有预期时候果断进入，预期落地、利好落地果断兑现出逃。就算后面再继续涨也不关我们的事了，不要想着吃最后一棒。 3、做低位有预期差，首板龙头4、做高胜率，在这基础上仓位。比小仓追高踏实。 12.5：高潮期，高开不要追，盘中出高点（可挂单出局），后持续回落，全天无买点，尾盘价格跌到最低点（看好持续性 的可买小仓）。 如果这时早盘追高，就被套了，心态就不好了，后续也被动了。 低位刚启动的龙头可提前排单不用撤单。(也要看位置，是刚刚启动还是已经到了尾声) 12.12： 大的机会第一时间重仓干，得看持续性如何，调研（观察生活周边事件变化），不要轻易判断结束。大机会大胆拿龙头（资金选出来的），快速切换真宗标题。 越是靠近生活的题材，被大众议论的，会慢慢发酵，持续性越好。 12.13: 持续性: 高标买入的是持续性和高收益，低标标买入的是确定性和持续性。 12.15：分仓：两个票以上，绝对不能单吊一个。如果是加仓，单天挂单T出加仓部分，没成功第二天一定出一半。 仓位：看环境、看大盘位置、看个股位置、持续性，才能决定仓位的高低。 要提前计划买卖，不要临盘头脑发热，被迫追高。 古僄要的是辨识度、代表性 1.41、 仓位：任何票仓位不能大于一半，大于一半心态会变差，因为太关心了。正常分三个仓位。 2、等待:等待时机，不能着急。大多数时候都是在等待，机会只有少数时间。 3、失败：失败时候，单天一定不能再交易，且停止交易2天以上。连续两次失败：停止交易一周 4、成功：案例记录，持续关注的票，提前计划好，挂单交易。 4、左侧：趋势个股、 右侧：底部反转 5、左侧：持续关注趋势个股，结合环境，找回调到均线附近，箱体底部机会再择机，尾盘进入试错。设置对应线止损，跌破出局，5日线止盈，箱体顶部附近止盈。 6、右侧：基本面好的趋势、优质个股持续关注，在底部放量反弹，5日线上，第一天介入。设置5日止损，止盈线，跌破出局。 7、短线：开盘低于预期就需要立刻拉上去，否则9：40之前卖了。10点还没反应也立刻出局一半，10：30全部出局。 1.5：不同阶段，策略不同1、趋势个股、回调均线、箱底位置、尾盘进入 2、错了、节奏没有抓好，就休息两天，越是着急越容易追高做错 1.6不盯盘，不看盘。一定要复盘，选板块、个股，找逻辑、找预期，择时，定策略（非短线）执行力：按策略执行、落实。1、不盯盘，不看盘。白天认真工作，学习。晚上复盘2小时以上。 2、按策略挂单。或者早盘竞价，尾盘竞价。 3、不要追，别怕错过。真的错过了，也是正常的不可能吃到所有板块的涨幅，不要去追了，等回调第二波机会。守好自己的票和板块，有逻辑和基本面改善预期。 4、确定逻辑、预期就定策略加仓，尤其低位的，等风来。 5、二波机会确定性更高。关注厉害的大V的思路，逻辑。 6、分清短线还是中线标的，对应策略不一样，中线标的用短线思维策略套，短线标不要用中线思维和策略。 1.11大盘主升浪的时候大仓位，个股破位5日均线和8日均线死叉点调出；大盘横盘震荡的时候半仓，个股破位5日均线调出；大盘下跌的时候小仓位，个股破位5日均线调出或者破位5小时均线与8小时均线死叉点调出。也就是说，大盘好的时候仓位大，个股止损位也较宽容；大盘差的时候仓位小，个股稍有不满意就卖出 2.31、一般持有不超过4个，不全仓一个，最多2/3仓位一个。 2、不再盯盘，挂单。盘前挂条件单。大胆做T，T出去的挂单买。T飞的不能追。 3、调整心态，不要盯盘，好好学习，好好上班 2.71、5日线上，底部向上的题材，小调整不破5日线不要卖，是介入机会。趋势小步向上，后面会加速。 2.101、最好不要超过4个股票，跟踪不过来，只能提前挂单、条件单（看股性）。 2、优先做好手上的票，优先处理好手上的票 3、低位比什么都重要，低位趋势，符合逻辑的第一时间上 3、短线开盘低于预期直接走，除非开盘迅速拉升，弱转强可以留。 2.131、提前挂好单，明日具体计划提前挂单落实。9:40之前。不追高，不着急，还有低位的机会很多。 2.141、短线不要做成中线成长（第二天不涨停就果断走，如果是低吸的最多容忍2天），5日线破了一定要走（铁一般的纪律） 2、挂条件单，门槛设置低点儿，也会有冲高收益的。尽量不要博大，机会特别多，别舍不得卖。 3、低吸预期，作差。不要博大，提前挂条件单。 2.15牛市猜想 资金喜新厌旧。新技术变革、替代。新技术变革引起的供需缺口引起的涨价。 预期今年下半年会出现牛市起点。 1、复盘，看研报，选正宗 2、优先处理好手上的票。然后按照计划执行。 3、确定持续性好的主线，判断持续性，调整之后，大胆低吸。 4、按照正宗、低位、预期差先后顺序排名。 总结：今天开始写复盘总结、盘前计划写出来。按计划进行。 2.171、集中仓位，做确定性，等待机会。 2、跌破就走（铁律），不要心存侥幸。看大盘，大盘跌破清仓。 跌破均线，卖出。短线看日K替代。中线周K替代。2.20短线条件单，价格低点儿，尽快成交，千万不能撤单 中线看箱顶，看压力位，挂单。 一只优秀的股票，反复做。不要换来唤去。 2.23看见逻辑、利好，不要冲动追高，再好的逻辑，追高都要被打。因为预期已经被打满。如果给机会挂单低吸就接，没有机会就不要追高。 冲动容易追高，只能挂单低吸。 1、看大盘位置，决定是否参与。2、是否有正宗目标，没有目标就等等。3、区分当前环境、题材阶段。 2.28卖在一致，买在分歧。出利好，高位，更不能追，这是卖的时候。 出利好，低位，跌下来的，可以3%以下小仓试 1、同2.23，出利好，大家一致性看好，是卖出时机。出利空等跌透，再右侧抄底。 把那些冒绿光的通通买进。 每日复盘！确定明日决策，提前设置条件单确定板块趋势后，挂多个条件单-5%以下买入。-5%以下买到谁都可以。不要盯盘！不要盯盘！不要盯盘！不要追高！不要追高！不要追高！挂单低吸！挂单低吸！挂单低吸!挂单高抛！挂单高抛！挂单高抛!提前挂条件单买！提前挂条件单卖！不要撤单！不要撤单！不要撤单！仓位控制、仓位控制、仓位控制，最多半仓。先做好手上的票，先做好手上的票，先做好手上的票卖在一致，买在分歧。敬畏市场。挂单规则：只能在绿盘买，只能在红盘上卖，否则不交易。竞价规则：早盘尽量买绿盘，红盘竞价不超过3%，10点之前。市场企稳，主线方向、趋势挂单低吸。不符合条件则不动。 5日线，箱体，趋势，主线没有跌破，就信，就稍微等一等。 选主线、核心逻辑、趋势、大波段，尽量少做短线。努力学习，深入研究，看公告，调研，研报等，确定逻辑。 结束：是主线的话没有那么快结束。看主线是否结束，看逻辑是否变化，趋势时候破位。 确定逻辑之后，跌下来就是最大的利好。 不要贪心什么都要，什么都想买，卖了去追。确定一两个逻辑正，跌下来的。 复盘方案总结大盘：大盘位置，趋势向上、向下、震荡。 国内政策：主线政策决定未来大反向、国内货币政策。（是否变化） 国际环境：国际冲突、国际国币政策，国际龙头公司走势。 1、拥抱主线：题材大小（只做主线题大题材） 2、判断当前题材阶段、看大盘位置、是否有正宗目标 3、仓位：孕期期：大、爆发期：大、荡调整：中、退潮期：无 复盘：大盘位置，市场环境、国际环境、是否交易，是否新开仓，是否继续持股，压力位在哪，题材持续性，是否是主线题材。个股是否正宗，环境是否变化。个股是中线、短线、超短 决策：提前挂条件单。不盯盘。 中线：（看周线趋势，忽略小波动，1-2月），调整低吸。 短线：（2-5天）看日K。5日线，题材发酵情况，挂条件单做T 超短：次日。不涨停，无论涨跌都要出。 做不好时，适当的休息、休息！ 3.21今日错误 1、盯盘 2、追高，未挂单低吸。3、杀跌。不要盯盘、挂单低吸、挂单高抛。选好主线，提前计划好，提前挂单交易。 先做好手上的票，手上的票做完了，不要马上交易。挂单低吸。或者复盘按计划挂单。","link":"/%E8%AE%B0%E5%BD%95.html"},{"title":"","text":"对象创建 懒加载、对象复用 布局计算 后台线程提前计算好视图布局、并且对视图布局进行缓存 图片解码当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 图像的绘制 图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）： 12345678910- (void)display { dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); });} CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染 不要设置透明的背景，把多个视图预先渲染为一张图片来显示 Runloop 任务分发Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件 全局并发控制创建不同优先级的，与CPU核数相等的全局串行队列 预排版当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。 预渲染对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗，为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容 异步绘制在异步绘制时，Layer 会传递一个 BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。 滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费， 我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。","link":"/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93.html"},{"title":"","text":"1、Swift中struct和class有什么区别？ struct是值引用，更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可继承。 2、Swift中的方法调用有哪些形式？ 答：直接派发、函数表派发、消息机制派发。派发方式受声明位置，引用类型，特定行为的影响。为什么Swift有这么多派发形式？为了效率。 参考文章：深入理解 Swift 派发机制 3、Swift和OC有什么区别？ Swift和OC的区别有很多，这里简要总结这几条： 4、从OC向Swift迁移的时候遇到过什么问题？ 可以参考这篇文章：OC项目转Swift指南 里的混编注意事项。 5、怎么理解面向协议编程？ 面向对象是以对象的视角观察整体结构，万物皆为对象。 面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。 面向协议能够解决面向对象的菱形继承，横切关注点和动态派发的安全性等问题。 参考喵神的面向协议编程与 Cocoa 的邂逅 (上) 分类中能不能定义实例变量，为什么？答案：不能。类的内存布局在编译时期就已经确定了，category是运行时才加载的早已经确定了内存布局所以无法添加实例变量，如果添加实例变量就会破坏category的内部布局。继续追问：1：为什么说category是在运行时加载的？2：不能添加实例变量，那为什么能添加属性？ 因为方法和属性并不“属于”类实例，而成员变量“属于”类实例。我们所说的“类实例”概念，指的是一块内存区域，包含了isa指针和所有的成员变量。所以假如允许动态修改类成员变量布局，已经创建出的类实例就不符合类定义了，变成了无效对象。但方法定义是在objc_class中管理的，不管如何增删类方法，都不影响类实例的内存布局，已经创建出的类实例仍然可正常使用。 分类并不会改变原有类的内存分布的情况，它是在运行期间决定的，此时内存的分布已经确定，若此时再添加实例会改变内存的分布情况，这对编译性语言是灾难，是不允许的。 利用runtime为其手动添加setter和getter方法/objc_getAssociatedObject / objc_setAssociatedObject，让一个对象保持对另一个对象的引用，获取得到另一个对象 ####OC语法 1、Block是如何实现的？Block对应的数据结构是什么样子的？__block的作用是什么？它对应的数据结构又是什么样子的？ block本质是一个对象，底层用struct实现。 数据结构如下： 12345678910111213141516struct Block_descriptor { unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);};struct Block_layout { void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */};复制代码 isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。 __block的作用是可以获取对应变量的指针，使其可以在block内部被修改。通过反编译的代码我们可以看到该对象是这样的： 12345678struct __Block_byref_i_0 { void *__isa; __Block_byref_i_0 *__forwarding; int __flags; int __size; int val; //变量名};复制代码 对于block的深入了解，可以参考《Objective-C高级编程》第二章或者唐巧的这篇谈Objective-C block的实现 2、GCD中的Block是在堆上还是栈上？ 堆上。可以通过block的isa指针确认。 3、NSCoding协议是干什么用的？ 一种编码协议，归档时和解档时需要依赖该协议定义的编码和解码方法。Foundation和Cocoa Touch中的大部分类都遵循了这个协议，一般被NSKeyedArchiver做自定义对象持久化时使用。 4、KVO的实现原理 利用Runtime生成一个中间对象，让原对象的isa指针指向它，然后重写setter方法，插入willChangeValueForKey和didChangeValueForKey方法。当属性变化时会调用，会调用这两个方法通知到外界属性变化。 5、NSOperation有哪些特性，比着GCD有哪些优点，它有哪些API？ NSOperation是对GCD的封装，具有面向对象的特点，可以更方便的进行封装，可以设置依赖关系。 API可以查看NSOperation文档。 6、NSNotificaiton是同步还是异步的，如果发通知时在子线程，接收在哪个线程？ 同步。子线程。 ####UI 1、事件响应链是如何传递的？ 手势的点击会发生两个重要事情，事件传递和事件响应。 事件传递：从UIApplication开始，到window，再逐步往下层（子视图）找，直到找到最深层的子视图，其为first responder。用到的判断方法是pointInside:withEvent和hitTest:withEvent。 事件响应：从识别到的视图（first responder）开始验证能否响应事件，如果不能就交给其上层（父视图）视图，如果能相应将不再往下传递，如果直到找到UIApplication层还没有相应，那就忽略该次点击。用到的判断方法是touchesBegan:withEvent、touchesMoved:withEvent等。 这两个过程大致的相反的。 2、什么是异步渲染？ 异步渲染就是在子线程进行绘制，然后拿到主线程显示。 UIView的显示是通过CALayer实现的，CALayer的显示则是通过contents进行的。异步渲染的实现原理是当我们改变UIView的frame时，会调用layer的setNeedsDisplay，然后调用layer的display方法。我们不能在非主线程将内容绘制到layer的context上，但我们单独开一个子线程通过CGBitmapContextCreateImage()绘制内容，绘制完成之后切回主线程，将内容赋值到contents上。 这个步骤可以参照YYText中YYTextAsyncLayer.m文件中的实现方式。 3、layoutsubviews是在什么时机调用的？ init初始化不会触发。 addSubview时。 设置frame且前后值变化，frame为zero且不添加到指定视图不会触发。 旋转Screen会触发父视图的layoutSubviews。 滚动UIScrollView引起View重新布局时会触发layoutSubviews。 4、一张图片的展示经历了哪些步骤？ 这个可以参考我之前写的一篇文章iOS开发图片格式选择 中的前半部分内容。 5、什么是离屏渲染，什么情况会导致离屏渲染？ 如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。 以阴影为例，为什么它会导致离屏渲染。因为GPU的渲染是遵循“画家算法”，一层一层绘制的，但阴影很特殊，它需要全部内容绘制完成，再根据外轮廓进行绘制。这就导致了，阴影这一层要一直占据一块内存区域，这就导致了离屏渲染。 类似导致离屏渲染的情况还有： cornerRadius+clipsToBounds group opacity 组透明度 mask 遮罩 UIBlurEffect 毛玻璃效果 6、CoreAnimation这个框架的作用什么，它跟UIKit的关系是什么？ CoreAnimation虽然直译是核心动画，但它其实是一个图像渲染框架，动画实现只是它的一部分功能。 看这张图我们可以知道，它是UIKit和AppKit的底层实现，位于Metal、Core Graphics和GPU之上之上。 苹果官方文档：About Core Animation ####引用计数 1、ARC方案的原理是什么？它是在什么时候做的隐式添加release操作？ ARC(Automatic Reference Cunting)自动引用计数，意即通过LLVM编译器自动管理对应的引用计数状态。ARC开启时无需再次键入retain或者release代码。 它是在编译阶段添加retain或者release代码的。 2、循环引用有哪些场景，如何避免？ 循环引用及两个及以上对象出现引用环，导致对象无法释放的情况。一般在block，delegate，NSTimer时容易出现这个问题。 解决方案就是让环的其中一环节实现弱引用。 3、为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？ block外界声明weak是为了实现block对对象的弱持有，而里面的作用是为了保证在进到block时不会发生释放。 4、Autoreleasepool是实现机制是什么？它是什么时候释放内部的对象的？它内部的数据结构是什么样的？当我提到哨兵对象时，会继续问哨兵对象的作用是什么，为什么要设计它？ Autoreleasepool的原理是一个双向列表，它会对加入其中的对象实现延迟释放。当Autoreleasepool调用drain方法时会释放内部标记为autorelease的对象。 12345678910class AutoreleasePoolPage { magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;};复制代码 哨兵对象类似一个指针，指向自动释放池的栈顶位置，它的作用就是用于标记当前自动释放池需要释放内部对象时，释放到那个地方结束，每次入栈时它用于确定添加的位置，然后再次移动到栈顶。 关于自动释放池的底层探究可以看draveness的这篇自动释放池的前世今生 —- 深入解析 autoreleasepool 5、哪些对象会放入到Autoreleasepool中？ 有两种情况生成的对象会加入到autoreleasepool中： 非alloc/new/copy/mutablecopy 开始的方式初始化时。 id的指针或对象的指针在没有显示指定时 引用计数带来的一次讨论 **6、weak的实现原理是什么？当引用对象销毁是它是如何管理内部的Hash表的？（这里要参阅weak源码） runTime会把对weak修饰的对象放到一个全局的哈希表中，用weak修饰的对象的内存地址为key，weak指针为值，在对象进行销毁时，用通过自身地址去哈希表中查找到所有指向此对象的weak指针，并把所有的weak指针置位nil。 ####Runtime 1、消息发送的流程是怎样的？ OC中的方法调用会转化成给对象发送消息，发送消息会调用这个方法： 12objc_msgSend(receiver, @selector(message))复制代码 该过程有以下关键步骤： 先确定调用方法的类已经都加载完毕，如果没加载完毕的话进行加载 从cache中查找方法 cache中没有找到对应的方法，则到方法列表中查，查到则缓存 如果本类中查询到没有结果，则遍历所有父类重复上面的查找过程，直到NSObject 2、关联对象时什么情况下会导致内存泄露？ 关联对象可以理解就是持有了一个对象，如果是retain等方式的持有，而该对象也持有了本类，那就是导致了循环引用。 3、消息转发的流程是什么？ 消息转发是发生在接收者（receiver）没有找到对应的方法（method）的时候，该步骤有如下几个关键步骤： 消息转发的时候，如果是实例方法会走resolveInstanceMethod:，如果是类方法会走resolveClassMethod:，它们的返回值都是Bool，需要我们确定是否进行转发。 如果第一步返回YES，确定转发就会进到下个方法forwardingTargetForSelector，这个方法需要我们指定一个被用receiver。 methodSignatureForSelector用于指定方法签名，forwardInvocation用于处理Invocation，进行完整转发。 如果消息转发也没有处理即为无法处理，会调用doesNotRecognizeSelector，引发崩溃。 更多了解可以参考iOS开发·runtime原理与实践: 消息转发篇(Message Forwarding) (消息机制，方法未实现+API不兼容奔溃，模拟多继承) 4、category能否添加属性，为什么？能否添加实例变量，为什么？ 可以添加属性，这里的属性指@property，但跟类里的@property又不一样。正常的@property为：实例变量Ivar + Setter + Getter 方法，分类里的@property这三者都没有，需要我们手动实现。 分类是运行时被编译的，这时类的结构已经固定了，所以我们无法添加实例变量。 对于分类自定义Setter和Getter方法，我们可以通过关联对象（Associated Object）进行实现。 5、元类的作用是什么？ 元类的作用是存储类方法，同时它也是为了让OC的类结构能够形成闭环。 对于为甚设计元类有以下原因； 在OC的世界里一切皆对象（借鉴于Smalltalk），metaclass的设计就是要为满足这一点。 在OC中Class也是一种对象，它对应的类就是metaclass，metaclass也是一种对象，它的类是root metaclass，在往上根元类（root metaclass）指向自己，形成了一个闭环，一个完备的设计。 如果不要metaclass可不可以？也是可以的，在objc_class再加一个类方法指针。但是这样的设计会将消息传递的过程复杂化，所以为了消息传递流程的复用，为了一切皆对象的思想，就有了metaclass。 关于这一话题的深入讨论可以参考这两篇文章： 为什么要存在MetaClass 为什么要设计metaclass 6、类方法是存储到什么地方的？类属性呢？ 类方法和类属性都是存储到元类中的。 类属性在Swift用的多些，OC中很少有人用到，但其实它也是有的，写法如下： 1234567@interface Person : NSObject// 在属性类别中加上class@property (class, nonatomic, copy) NSString *name;@end// 调用方式NSString *temp = Person.name;复制代码 需要注意的是跟实例属性不一样，类属性不会自动生成实例变量和setter，getter方法，需要我们手动实现。具体实现方法可以参考这个文章：Objective-C Class Properties 7、讲几个runtime的应用场景 hook系统方法进行方法交换。 了解一个类（闭源）的私有属性和方法。 关联对象，实现添加分类属性的功能。 修改isa指针，自定义KVO。 ####Runloop 1、讲一下对Runloop的理解？ Runloop就是一个运行循环，它保证了在没有任务的时候线程不退出，有任务的时候即使响应。Runloop跟线程，事件响应，手势识别，页面更新，定时器都有着紧密联系。 深入了解推荐ibireme的这篇深入理解RunLoop 2、可以用Runloop实现什么功能？ 检测卡顿 线程保活 性能优化，将一些耗时操作放到runloop wait的情况处理。 性能优化 1、对TableView进行性能优化有哪些方式？ 缓存高度 异步渲染 减少离屏渲染 2、Xcode的Instruments都有哪些调试的工具？ Activity Monitor（活动监视器）：监控进程的CPU、内存、磁盘、网络使用情况。是程序在手机 运行真正占用内存大小 Allocations（内存分配）：跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史 Core Animation（图形性能）：显示程序显卡性能以及CPU使用情况 Core Data：跟踪Core Data文件系统活动 Energy Log：耗电量监控 File Activity：检测文件创建、移动、变化、删除等 Leaks（泄漏）：一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录 Network：用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接 System Usage：记录关于文件读写，sockets，I/O系统活动，输入输出 Time Profiler（时间探查）：方法执行耗时分析 Zombies：测量一般的内存使用，专注于检测过度释放的野指针对象。也提供对象分配统计以及主动分配的内存地址历史 3、讲一下你做过的性能优化的事情。 这个根据自己情况来说吧。 4、如何检测卡顿，都有哪些方法？ FPS，通过CADisplayLink计算1s内刷新次数，也可以利用Instruments里的Core Animation。 利用Runloop，实时计算 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 两个状态区域之间的耗时是否超过某个阀值 子线程检测，每次检测时设置标记位为YES，然后派发任务到主线程中将标记位设置为NO。接着子线程沉睡超* 时阙值时长，判断标志位是否成功设置成NO，如果没有说明主线程发生了卡顿。参考ANREye的实现 5、缩小包体积有哪些方案？ 图片压缩，无用图片删除 一些大图可以动态下发 删除无用类，无用方法 减少三方库的依赖 ####计算机相关 1、项目编译的流程是什么？手机上的应用程序自点击图标开始到首屏内容展示都经历了哪些步骤？ 编译流程： 预处理：处理宏定义，删除注释，展开头文件。 词法分析：把代码切成一个个token，比如大小括号等于号还有字符串 语法分析：验证语法是否正确，合成抽象语法树AST 静态分析：查找代码错误 类型检查：动态和静态 目标代码的生成与优化，包括删除多余指令，选择合适的寻址方式，如果开启了bitcode，会做进一步的优化 汇编：由汇编器生成汇编语言 机器码：由汇编语言转成机器码，生成.o文件 应用启动的流程： 启动的前提是完成编译，运行程序即运行编译过后的目标程序，它分为main函数前和main函数后： main前 加载可执行文件（App的.o文件集合） 加载动态链接库（系统和应用的动态链接库），进行rebase指针调整和bind符号绑定 Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查 初始化，包括执行+load()、attribute(constructor)修饰的函数的调用、创建C++静态全局变量 main后 首页初始化所需要配置文件的读写操作 首页界面渲染 2、对于基本数据类型，一般是存储到栈中的，它有没有可能存在堆上，什么情况下会存储到堆上？ 栈和堆都是同属一块内存，只不过一个是高地址往低地址存储，一个从低地址往高地址存储，他们并没有严格的界限说一个值只能放在堆上或者栈上。所以基本数据类型也是可以存储到堆上的。 当该基础类型变量被__block捕获时，该变量连同block都会被copy到堆上。 3、数据库中的事务是什么意思？ 事务就是访问并操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行。如果其中一个步骤出错就要撤销整个操作，回滚到进入事务之前的状态。 4、使用过什么数据库（我回答的Sqlite，Realm），Realm在使用时有哪些注意事项，如何实现批量操作？ 对于Realm感兴趣的同学可以看下其官方文档。 Realm需要注意的主要就是不能直接跨线程访问同一对象。 批量操作可以在一个单独的事务中执行多个数据库的修改。 5、LRU算法是否了解，如何实现一套LRU算法？ LRU（Least recently used 最近最少使用）算法是一个缓存淘汰算法，其作用就是当缓存很多时，该淘汰哪些内容，见名知意，它的核心思想是淘汰最近使用最少的内容。实现它的关键步骤是： 新数据插入到链表的头部 每当缓存命中时，则将数据移动到链表头部 链表满时，将尾部数据清除 这个算法在SDWebImage和Kingfisher等需要处理缓存的库中都有实现。 6、知道哪些设计模式，怎么理解设计模式的作用？ 工厂模式、观察者模式、中介者模式、单例模式。这个根据实际情况说吧。 7、如果有1000万个Int类型的数字，如何对他们排序？ 这里的隐藏含义是，内存不够用时如何排序，还有一个隐藏含义是硬盘足够大。这是可以采用分而治之的方法，将数据分成若干块，使每一小块满足当前内容大小，然后对每块内容单独排序，最后采用归并排序对所有块进行排序，就得到了一个有序序列。 8、设计一套数据库方案，实现类似微信的搜索关键词能快速检索出包含该字符串的聊天信息，并展示对应数量（聊天记录的数据量较大） 可以对聊天记录的文本值加上索引。正常情况下数据库搜索都是全量检索的，加上索引之后只会检索满足条件的记录，大大降低检索量。 ####简历相关问题 1、Lottie实现动画效果的原理是什么？ iOS里的动画基本都是基于CoreAnimation里的API实现的，Lottie也是如此。在AE上实现动画效果，通过插件导出对应的json文件，Lottie的库解析该json，转成对应的系统API方法。图片的引用可以使用Base64编到json里，也可以通过项目集成，通过路径引用。 2、OClint实现静态分析的原理是什么，它是如何做到的？ 具体可以参考我之前写的如何通过静态分析提高iOS代码质量。 3、MVVM和MVC有什么区别？ 对比架构时，可以从是否职责分离，可测试性，可易维护性三个维度对比。 更多对比可以参考我翻译的一篇文章：【译】iOS 架构模式–浅析MVC, MVP, MVVM 和 VIPER 4、静态库和动态库的区别是什么？ 静态库：链接时被完整复制到可执行文件中，多次使用就多份拷贝。 动态库：链接时不复制，而是由系统动态加载到内存，内存中只会有一份该动态库。 5、了解Flutter吗？它有没有使用UIKit？它是如何渲染UI的？ UIKit是基于CoreAnimation渲染的，而Flutter并没有用到它，而是自己基于C++实现了一套渲染框架。 6、二进制重排的核心依据是什么？ 修改链接顺序，减少启动时的缺页中断。 实践步骤可以参考李斌同学的这篇iOS 优化篇 - 启动优化之Clang插桩实现二进制重排 7、如何设计一套切换主题的方案？ 核心思路是观察者模式+协议（通知），当获取到主题切换时，通知各个实现了主题协议的类进行更新。 8、AVPlayer和IJKPlayer有什么区别？用IJKPlayer如何实现一个缓存视频列表每条视频前1s的内容？ 因为对IJKPlayer和FFmpeg了解的不是很深，这个我也没有确切答案，如果有了解的小伙伴可以评论告知我。 9、类似微博的短视频列表，滑动停留播放，如何实现？ 这个主要就是检测contentOffset和屏幕中间位置，设置一些边界条件，处理滑动过程中的切换行为。 10、使用python做过哪些事？如何理解脚本语言？ 多语言管理，csv多语言文件读取，然后写入到项目Localizable.strings中；抓取项目中的多语言字符串。 脚本（script） 其实就是一系列指令，计算机看了指令就知道自己该做什么事情。像常见的Python，Shell，Ruby都是脚本语言，他们通常不需要编译，通过解释器运行。 ####数据结构与算法 1、什么是Hash表，什么是Hash碰撞，解决Hash碰撞有什么方法？ 哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。我们常用的Dictionary就是一种Hash表。 那什么是Hash碰撞呢，我们知道Hash表的查找是通过键值进行定位的，当两个不同的输入对应一个输出时，即为Hash碰撞，也被称为Hash冲突。 如果使用字典的例子你可能联想不到冲突的情况，我们假设另一种情况：假设hash表的大小为9（即有9个槽），现在要把一串数据存到表里：5,28,19,15,20,33,12,17,10。我们使用的hash函数是对9取余。这样的话会出现hash(5)=5，hash(28)=1，hash(19)=1。28和19都对应一个地址，这就出现了Hash冲突。 解决Hash冲突的方式有开放定址法和链地址法。 2、如何遍历二叉树？ 二叉树的遍历有三种方式，对于上面这棵二叉树，他们的遍历结果为： 前序遍历：根节点 &gt; 左子节点 &gt; 右子节点。 10，6，4，8，14，12，16 中序遍历：左子节点 &gt; 根节点 &gt; 右子节点。 4，6，8，10，12，14，16 后序遍历：左子节点 &gt; 右子节点 &gt; 根节点。 4，8，6，12，16，14，10 3、简述下快速排序的过程，时间复杂度是多少？ 快排的思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行。 一个简单的Swift实现方式如下： 1234567891011func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] { guard a.count &gt; 1 else { return a } let pivot = a[a.count/2] let less = a.filter { $0 &lt; pivot } let equal = a.filter { $0 == pivot } let greater = a.filter { $0 &gt; pivot } return quicksort(less) + equal + quicksort(greater)}复制代码 快速排序是有好几种的，他们的区别在于如何实现filter和分区基准值的选取。 快排的时间复杂度是O(nlogn)，空间复杂度是O(logn) 4、有一个整数数组，如何只遍历一遍就实现让该数组奇数都在前面，偶数都在后面？ 这个是《剑指offer》里的一道题，leedcode也有对应题目：剑指offer 21 这个相对比较简单，因为不要求有序，可以采用收尾遍历的方式，进行交换，我这有个参考答案： 1234567891011121314151617181920func sorted( _ nums: inout [Int]) -&gt; [Int] { guard !nums.isEmpty else { return [] } var start = 0 var end = nums.count - 1 while start &lt; end { if nums[start] % 2 != 0 { start += 1 continue } if nums[end] % 2 == 0 { end -= 1 continue } (nums[start], nums[end]) = (nums[end], nums[start]) } return num}复制代码 5、假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ leetcode 20 6、给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转 leetcode 7 7、有红、黄、蓝三种颜色的气球。在牛客王国，1个红气球+1个黄气球+1个蓝气球可以兑换一张彩票 2个红气球+1个黄气球可以兑换1个蓝气球。 2个黄气球+1个蓝气球可以兑换1个红气球。 2个蓝气球+1个红气球可以兑换1个黄气球。 现在牛牛有a个红气球，b个黄气球， c个蓝气球，牛牛想知道自己最多可以兑换多少张彩票。 这个是牛客网里的一道算法题，这里有个题解可以参考。","link":"/%E9%9D%A2%E8%AF%95%E9%A2%98.html"},{"title":"","text":"app性能优化1.提高启动速度2.内存泄漏检测(MLeaksFinder)3.卡顿检测4.网络优化5.缩小包体积6.Bugly crash 排查分析7、组件化 8、首页容器化 9、多线程专项优化，10离线化处理 11、启动任务分发，data段注册 TableView优化1.动态的高度，缓存高度2.异步渲染 ：开一个子线程通过CGBitmapContextCreateImage()绘制内容，绘制完成之后切回主线程，将内容赋值layer的contents，例如YYText中的YYTextAsyncLayer.m 3.离屏渲染，使用 Core Graphics,贝塞尔曲线 为 UIView 加圆角。避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染，少用ClearColorlayer的阴影、蒙版、模糊、光栅化、圆角等操作，因为这些操作会进行多个渲染结果的合并，需要一个额外的渲染区来暂存渲染结果单图层的时候并不会触发离屏渲染，只有处理多图层时并且这时候masksToBunds设置为YES才会触发、 圆角的处理：Core GraPhics框架处理或者配合贝塞尔曲线设置 layer层的蒙版使用layer.mask：添加自定义view来达到我们做到的效果 模糊效果：CoreImage提供的方法实现。阴影的处理我们可以使用shadowPath来处理阴影效果 4.耗时操作可以等进入runloopbeforewaitting后进行 5、instruments 检查影响性能。 Instruments1.CPU,内存,磁盘,网络,能耗等监控, 2.内存泄露 3.方法执行耗时分析 提高启动速度 3.6s左右减低到1.9-2,2.1秒1、加载可执行文件2、加载动态链接库（系统和应用的动态链接库），进行rebase指针调整和bind符号绑定3、Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查4、初始化+load()等方法5、main方法、UIApplicationDelegate生命周期application:willFinishLaunchingWithOptions:和application:didFinishLaunchingWithOptions、applicationDidBecomeActive 6、启动业务，首屏渲染等 1、减少不必要的 framework，因为动态链接比较耗时，动态库合并，动态库转静态库2、排查删除无用类和方法。3、+ load方法，减少耗时操作，异步加载，部分任务移动+initialize3、分必要和非必要延后加载，比如wkwebView的预加载播放器预热功能，提前创建好播放器。这个优化的主要设计难点在于如何选取预热的时机。通过埋点数据分析可以确认一个时机为弹窗弹出时，此时用户会等待一段时间看弹窗，非常适合做资源预加载。但不是每次启动都有弹窗，因此还需要另一个时机。看如下Trace，在启动首屏后会有一段时间在等待网络请求，runloop出于空闲状态，那么这个时机在启动首屏后。4、使用Instruments调试，app lauch找到启动时的高频次方法或者耗时方法，可以做缓存处理，Trace打点调试5、动态库懒加载，合并6、二进制重排7、首屏渲染分阶段数据请求8、首刷请求提前，首刷请求会紧接着网络库的初始化之后发送，并做好数据解析9、数据解析后就开始图片和视频预加载 10、防止劣化，线下防劣化采用了ByTest（质量平台）指标防劣化方案，其整体流程如下。每天会触发两次性能防劣化服务，每次触发服务后会构建一个性能防劣化包交付ByTest进行自动化测试。App在启动后上报启动相关埋点数据到(端监控平台），ByTest在获取埋点数据后通过算法排除掉异常数据，判断劣化情况并发送通知 监控启动时间：1、自定义AAA命名的动态库放在所有动态库加载的第一位， +load 方法中进行埋点作为 APP 的启动时间。Cocoapods会排序加载顺序，OTHER_LDFLAGS中可以看出来。2、通过调试commit() 首屏渲染时间： didFinishLaunch监听进入kCFRunLoopBeforeTimers状态的时间。 动态库懒加载1、pod install之后，会生成Pods-xxx-frameworks.sh和Pods-xxx.release.xcconfig这两个文件，其中Pods-xxx-frameworks.sh文件脚本负责架构剔除和重签名等功能，而Pods-xxx.release.xcconfig文件则负责静态库和动态库的链接配置，我们自定义的动态库想要进行懒加载，只需要修改xxx.xcconfig配置文件，将需要懒加载的动态库从配置文件中移除，这样保证懒加载的动态库参与签名和拷贝，但是不参与链接。2、原有动态库的调用方式需要修改成Runtime动态调用的形式，在使用某个动态库中的类时，先动态获取该类，如果获取不到，则通过dlopen的方式动态加载该动态库： 二进制重排 虚拟内存：当我们向系统申请内存时，系统并不会给你返回物理内存的地址，而是给你一个虚拟内存地。只有我们开始使用申请到的虚拟内存时，系统才会将虚拟地址映射到物理地址上，需要通过操作系统维护的一张映射表映射之后才可以真正访问到，而映射表是以页（Page）为单位进行管理的。 当进程要访问的一个虚拟内存页在经过映射表映射之后发现对应的物理内存页不存在时，会触发一次缺页中断Page Fault。 Instruments Trace工具：File Backed Page In就是Page Fault的次数 APP 启动过程中，会加载大量的类和方法，两个方法分布在不同的内存页时，产生Page Fault，繁触发Page Fault，产生不可小视的耗时。获取启动的这些方法，按顺序排列在同一个内存页,或者连续的内存页中1.基于 Clang 静态插桩的方式来获取启动过程中的所有函数符号，写到order_file中，2.Clang 静态插桩收集符号的原理就是，利用编译期在每一个函数内部插入回调函数3.Other C Flags，Other swift Flags添加配置4.多线程问题：启动的相关方法可能在不同的线程执行，使用原子队列收集 对于进程间通信，比如使用系统库获取一些必要数据，去获取keychain中的数据，获取idfa、udid等等。一种是在使用前在后台线程提前获取并缓存在内存中，当使用时直接使用缓存数据，此方案必须需要考虑的问题是系统库是否线程安全。另一种是在第一次获取后就写入持久化缓存，比如YYCache和MMKV等，之后使用时只需要读取本地缓存即可。 监控内存泄漏1、MLeaksFinder 则是在控制器销毁时，延迟 3s 后再向监测对象发送消息，根据监测对象能否响应消息判断其是否泄漏。 FBRetainCycleDetector。当传入内存中的任意一个 OC 对象，FBRetainCycleDetector 会递归遍历该对象的所有强引用的对象，以检测以该对象为根结点的强引用树有没有循环引用。 1、hook 掉 UIViewController 和 UINavigationController 的 pop 跟 dismiss2、为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(3秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。3、遍历该 UIViewController 上的所有 view，依次调 -willDealloc 采用stack的方式，对某个对象获取所有被其强引用的对象，然后依次以递归思想将这些对象入栈，如果某次入栈的对象已经存在stack中，说明该对象在stack中的位置直到当前为止，存在引用环。 如何获取强引用成员变量： 1、类的成员变量：runtime的class_getIvarLayout获取描述该类成员变量的布局信息，ivar_getOffset遍历获取成员变量在类结构中的偏移地址,然后获取强引用变量的集合。 2、block强引用变量的获取：依据block引用的对象总是基于block地址偏移整个结构体的size,并且被持有的对象按照强引用在前，弱引用在后的顺序排列，因为block强引用的对象都会进行copy到堆上和release对象引用的操作，因此可以通过接收类FBBlockStrongRelationDetector构造detector对象，然后用block的dispose_helper方法调用，判断如果detector对象调用release方法，就说明当前对象是强引用对象，然后获取block持有的所有强引用变量的集合 3、Instruments工具调试leaks内存泄漏 如何检测卡顿 利用Runloop，通过开辟一个子线程来监测主线程的 RunLoop，当两个状态区域的耗时大于设定的阈值时，即为一次卡顿,实时计算 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 。检测到卡顿：可以借助开源库 PLCrashReporter上传堆栈调用。 连续3次超时80ms 卡死：预先设定一个卡死的阈值T（默认是8s）。 卡死：死锁、死循环，当应用启动过程中，没有在限定时间内完成初始化工作也会被系统杀死。 在超过卡死阈值T的时候，获取全线程的堆栈，并保存至本地文件中。之后每隔一段时间（采样间隔，默认是1s），会进行一次采样。采样的目的不是为了获取新的堆栈，而是为了更新卡死持续的时间，将该信息保存至本地文件中。 直至到某一个时间节点，系统把App杀死。当App下一次启动时，卡死模块会根据上一次启动中保留的本地文件信息，还原出卡死的堆栈、持续时间等信息，并上报卡死异常。 FPS 降低 CPU 占用率很高 主线程 Runloop 执行了很久 CPU,GPU的处理结果错过了下一次垂直同步信号（v-sync）到来时，这样显示屏还是之前帧的内容。结合主线程监控、FPS 监控，以及 CPU 使用率等指标，作为判断卡顿的标准。Bugly 的卡顿检测也是基于这套标准 参考ANREye的实现 网络优化及监控 DNS，它的作用是根据域名查出IP地址一 短连接优化方案1、域名合并：客户端修改huiyuan.api.2dfire.com、tuangou.api.2dfire.com合并api.2dfire.com/huiyuan 、api.2dfire.com/tuangou ，服务端Server Load Balancing中还原转发到不同业务服务器优势：1）域名得到了收编，减少了DNS调用次数，降低了DNS劫持风险；2）针对同一域名，可以利用Keep-Alive来复用Http的连接；3）客户端业务层不需要修改代码，后端业务服务也不需要进行任何修改。 2、IP直连客户端架设自己的DNS服务1）程序启动的时候拉取“api.2dfire.com”对应的所有的IP列表；2）对所有IP进行跑马测试，找到速度最快的IP（后续所有的HTTPS请求都将域名更换为跑马最快的IP即可）。比如：经过跑马测试发现域名“api.dianping.com”对应最快的IP是“1.23.456.789”。URL“http://api.2dfire.com/ad/command?param1=123”将被替换为“http:// 1.23.456.789/ad/command?param1=123”优势：1）摒弃了系统DNS，减少外界干扰，摆脱DNS劫持困扰；2）自建DNS更新时机可以控制；3）IP列表更换方便。 3、代理长连模式客户端与代理服务器之间的长连通道是通过IP建立的，与DNS没有关系。客户端的HTTP请求被转换为二进制数据流送到代理服务器，也不需要进行DNS解析。代理服务器转发请求到业务服务器时，都处于同一内网，因此可以自己搭建DNS服务，减少对公网DNS服务的依赖。相比公网http通道，代理服务器与业务服务器之间的网络通道也可以进行优化，通过架设专线或者租用腾讯云等方式可以大大提升通道服务质量 应用层、传输层、网络层、数据链路层、物理层HTTP请求是基于Socket设计的，请求发起之前会经历三次握手，断开时又会进行四次挥手http：无连接无状态 udp： 1、UDP是无连接的、不可靠的一种数据传输协议，所以速度更快一些请求速度弱网适应安全保障 TCP：传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议 1、可靠的、面向连接的。 2、TCP建立连接三次握手，断开四次分手 TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。 三次握手： 1、客户端发送syn报文给服务端，syn_send状态。客户端发送消息正常 2、服务端接收到后，返回给客户端一个syn+ack报文答复，syn_rcvd状态。服务端：接收消息正常，发送正常 3、客户端接收到后，想服务端发送一个ack报文，双方都处于ESTABLISHED状态（已建立）。：告诉服务端，客户端接收消息也正常 四次挥手 1、客户端向服务端一个FIN报文段，FIN_WAIT_1状态，表示：没有数据要发送给你了。 2、服务端收到FIN报文，回复一个ACK，FIN_WAIT_2状态，：同意你的关闭请求。 3、服务端想客户端发送FIN报文，请求关闭连接，服务端进入LAST_ACK状态 4、客户端收到FIN报文，向服务端发送ACK，客户端进入TIME_WAIT。服务端收到ACK报文就关闭连接。客户端等待2MSL后还未收到回复则证明服务端已经关闭，客户端也可以关闭连接了。 对方处于LAST_ACK状态下的Socket可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 HTTP和TCP关系 我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。 Socket Socket可以更方便的使用TCP/IP协议栈，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等。 Socket长连接 短连接：连接→数据传输→关闭连接； 长连接：连接→数据传输→保持连接(心跳包,双方发检测包)→数据传输→保持连接(心跳)→……→关闭连接； 长连接多用于操作频繁，点对点的通讯。TCP提供了发送心跳包机制，setInterval设置发送时间，监听heartbeat 如果想要使传输的数据有意义，则必须使用到应用层协议比如Http。 基于TCP协议上自定义自己的应用层的协议需要解决的几个问题： 心跳包格式的定义及处理 报文头的定义，就是你发送数据的时候需要先发送报文头，报文里面能解析出你将要发送的数据长度 你发送数据包的格式，是json的还是其他序列化的方式 客户端先发送报文头，在发送内容数据，另外一个定时器发送心跳数据 Socket连接池就是维护着一定数量Socket长连接的集合，它能自动检测Socket长连接的有效性，剔除无效的连接，补充连接池的长连接的数量。 一个请求过来，首先去资源池要求获取一个长连接资源，如果空闲队列里面有长连接，就获取到这个长连接Socket,并把这个Socket移到正在运行的长连接队列。如果空闲队列里面没有，且正在运行的队列长度小于配置的连接池资源的数量，就新建一个长连接到正在运行的队列去，如果正在运行的不下于配置的资源池长度，则这个请求进入到等待队列去。当一个正在运行的Socket完成了请求，就从正在运行的队列移到空闲的队列，并触发等待请求队列去获取空闲资源，如果有等待的情况。 layoutsubviews触发时机 init初始化不会触发。 addSubview时。 设置frame且前后值变化，frame为zero且不添加到指定视图不会触发。 旋转Screen会触发父视图的layoutSubviews。 滚动UIScrollView引起View重新布局时会触发layoutSubviews。 Runloop 检测卡顿 线程保活 性能优化，将一些耗时操作放到runloop wait的情况处理。 深入了解推荐ibireme的这篇深入理解RunLoop 12345- kCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行- UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）- kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式- UIInitializationRunLoopMode：在刚启动App时第进入的第一个Mode，启动完成后就不再使用- GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { 状态 kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit // 即将退出Loop}; 控制线程的生命周期【线程保活】 解决NSTimer在滑动过程中停止工作的问题及衍生问题 监控应用卡顿，kCFRunLoopBeforeSources和kCFRunLoopAfterWaiting两个状态耗时。 性能优化，监控runloopbeforewaitting时候做一些耗时工作 Runtime运行时机制 说说你对 runtime 的理解。——主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。OC 是动态语言 Runtime 解决如何在运行时期找到调用方法 Runtime使用 objc_msgSend 函数，通过给类发送 SEL 以传递消息，找到匹配的 IMP 类中的 super_class 指针可以追溯整个继承链 实例变量：instance -&gt;isa -&gt; class -&gt; method列表 -&gt; SEL -&gt; IMP -&gt; 实现函数实例对象中存放 isa ,isa指针找到实例对象所属类，类中存放着实例方法列表，方法列表中 SEL 作为 key，IMP 作为 value。IMP 其实就是函数指针指向了最终的函数实现。 调用实例方法，通过 isa 指针找到实例对应的 class 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy). 调用类方法，通过 isa 指针找到实例对应的 metaclass 并且在其中的缓存方法列表以及方法列表中进行查询，如果找不到则根据 super_class 指针在父类中查询，直至根类(NSObject 或 NSProxy). (根据此前的开篇中的图，Root Meta Class 还是有根类的。) 还没有找到方法，进入动态消息解析1.通过 resolveInstanceMethod 得知方法是否为动态添加，YES则通过 class_addMethod 动态添加方法，处理消息，否则进入下一步。dynamic 属性就与这个过程有关，当一个属性声明为 dynamic 时 就是告诉编译器：开发者一定会添加 setter/getter 的实现，而编译时不用自动生成。2.这步会进入 forwardingTargetForSelector 用于指定哪个对象来响应消息。如果返回nil 则进入第三步。这种方式把消息原封不动地转发给目标对象，有着比较高的效率。如果不能自己的类里面找到替代方法，可以重载这个方法，然后把消息转给其他的对象。3.这步调用 methodSignatureForSelector 进行方法签名，这可以将函数的参数类型和返回值封装。如果返回 nil 说明消息无法处理并报错 unrecognized selector sent to instance，如果返回 methodSignature，则进入 forwardInvocation ，在这里可以修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果依然不能正确响应消息，则报错 unrecognized selector sent to instance. +initializ和+load+load:在main函数之前调用类被加载进runtime时候，只调用一次。父类的load先调用, +load中添加method swizzling +initialize：在第一次接收到消息之前被调用，线程安全的。父类先调用，子类没有实现的+initialize会调用父类的+initialize，所以+initialize会被调用多次。 KVO利用Runtime创建一个新的继承自这个对象的class的subclass，让原对象的isa指针指向它，然后重写setter方法，插入willChangeValueForKey和didChangeValueForKey方法。当属性变化时会调用，会调用这两个方法通知到外界属性变化。 run time会创建一个新的继承自这个对象的class的subclass。在这个新的subclass中，它会重写所有被观察的key的setter，然后将对象的isa指针指向新创建的class(这个指针告诉Objective-C运行时某个对象到底是什么类型的)。所以实例对象神奇地变成了新的子类的实例。完成以上操作后，通过调用setter方法进行相关属性的变化时，操作的就是这个中间的子类 KVC-(id)valueForKeyPath:(NSString *)keyPath;-(id)valueForKey:(NSString *)key;-valueForKey: 首先查找以键 -getKey、 -key 或 -isKey 命名的 getter 方法，它将在对象内部查找名为 _key 或 key 的实例变量。最后没找调用 valueForUndefinedKey: 方法。 组件化之组件生命周期管理先注册各个启动组件，在 AppDelegate 的各个代理方法里，手动调一遍各个组件的对应方法，如果组件实现了对应的代理方法，就执行 为什么要用swift如果从大点儿的维度来说的话，想oc和swift、Java和kotlin、c++和新发布的carbon。他们都是原有语言的继承者。开发者会因为更现代的语法喜欢新的语言，而新的语言使用全新的思路去打破原来的僵局。语法、性能速度、更适合初级者快速上手等。 它是一个类型安全语言，变量和方法都有明确的类型，并且有比 OC 更严格的编译时静态类型检查，检测出更多的错误，还有有类型推导机制，写起来更加简洁方便。它包含面向对象编程语言和函数式编程语言的所有特性，还可面向协议编程， 不局限于某种特定编程的范式。在oc基础上添加很多新的特性。 Swift和OC的区别：Swift静态、OC:动态语言，最大的特点就是面向对象，万物皆对象，封装、继承、多态，方法的调用就是动态发送消息去查找对应的方法Swift有元组，option类型面向协议编程可菱形继承struct 分配在栈中,值引用、 class 分配在堆中，类型引用.String，Array和 Dictionary都是结构体，因此赋值直接是拷贝，而NSString, NSArray 和NSDictionary则是类，所以是使用引用的方式。 OC接入swift遇到问题早之前使用Bridging-Header.h文件的方式，将需要暴露给swift的oc类包含进去。Swift 访问 OC可以直接import xxx，Objective-C 访问 Swift，#import ProductName-Swift.hOC调用Swift，需要在属性和方法名前面加上@objc，方法调用：直接调用，函数表调用，消息转发,swift性能更高，消息转发主要靠缓存来提升效率swift面向协议编程，通知名由字符串变成了NSNotification.Name的结构体。oc中kvo监听Swift的属性，需要加上dynamic。Swift对enum的使用做了很大的扩展，可以支持任意类型，而OC枚举仅支持Int类型Swift中Int和Float是不能直接做运算的，必须要将他们转成同一类型才可以运算对于初始化方法OC先调用父类的初始化方法，然后初始自己的成员变量。Swift先初始化自己的成员变量，然后在调用父类的初始化方法。 OC中id类型被Swift调用时会自动转成AnyObjectid 指向任何类的对象，可以代表所有继承于NSObject的对象AnyObject可以代表任何class类型的实例。Any可以代表任何类型，甚至包括func类型。 closure和block closure是匿名函数、block是一个结构体对象 closure通过逃逸闭包来在内部修改变量，block 通过 __block 修饰符 逃逸闭包@escaping 概念：一个接受闭包作为参数的函数，该闭包可能在函数返回后才被调用，也就是说这个闭包逃离了函数的作用域，这种闭包称为逃逸闭包。当你声明一个接受闭包作为形式参数的函数时，你可以在形式参数前写@escaping来明确闭包是允许逃逸。 非逃逸闭包 概念：一个接受闭包作为参数的函数， 闭包是在这个函数结束前内被调用 为什么要分逃逸闭包和非逃逸闭包 ：逃逸闭包会强引用它捕获的所有对象，比如在闭包中访问当前对象中的属性或方法，会持有当前对象，很容易导致循环引用。 直接调用、静态派发 函数声明位置的不同也会导致派发方式的不同值类型对象的函数的调用方式是静态调用，即直接地址调用，调用函数指针，这个函数指针在编译、链接完成后，当前函数的地址就已经确定了，在执行代码的过程中就直接跳转到这个地址来执行当前对应的方法，存放在代码段，而结构体内部并不存放方法。因此可以通过地址直接调用。函数表调用函数表的本质就类似于我们理解的数组，声明在class内部的方法在不加任何关键字修饰的过程中，连续存放在我们当前的地址空间中。class中函数来说，是通过V-Taable，其本质就是一个连续的内存空间（数组结构） extension中的方法是直接调用的 struct是值类型，其中函数的调度属于直接调用地址，即静态调度。class是引用类型，其中函数的调度是通过V-Table函数表来进行调度的，即动态调度。extension中的函数调度方式是直接调度。final修饰的函数调度方式是直接调度。@objc随时的函数调度方式是函数表调度，如果OC中需要使用，class还必须继承NSObject。dynamic修饰的函数的调度方式是函数表调度，是函数具有动态性。@objc + dynamic组合修饰的函数调度，是执行的是objc_msgSend流程，即动态消息转发。 优选struct 安全性 struct是值引用,值类型是自动线程安全的、 Struct 没有引用计数不会循环引用导致内存泄漏 速度 栈由系统分配速度更快 继承OC某些类的的时候使用class 使用struct不需要考虑内存泄漏和多线程读写的问题，因为在传递值的时候它会进行值的copy struct存储在stack中，class存储在heap中，struct为什么更快，栈由系统分配速度更快 为什么要用flutterflutter是跨平台框架，可用来为移动、桌面和 Web 平台构建应用程序。 基于dart语言，干净简洁，易于上手，Dart是类型安全的语言，支持静态类型检测，所以可以在编译前就发现一些类型的错误，并排除潜在问题依赖于 C/C++ 内置的图形渲染引擎，可生成非常快速且性能出众的应用程序。热重载、节省人力，修改的UI实时显示。 OC接入flutter遇到问题为了复用Element从而减少频繁创建和销毁RenderObject 因为Widget是非常轻量级的，实例化耗费的性能很少， 则只需要修改RenderObject的配置，不用进行耗费性能的RenderObject的实例化工作了 Element是被抽离开来的，所以你不需要经常和它们打交道。每个Widget的build（BuildContext context）方法中传递的context就是实现了BuildContext接口的Element flutter核心原理flutter中一切都是Widget，根据新的状态state来重新构建UI。widget创建element, element生成对应的renderobject，renderobject是真正负责渲染的BuildContext就是widget对应的ElementBuildContext来获取主题(theme)或者另一个Widget的引用，Scaffold.of(context)来得到它，其中context就是上下文信息，通过of()来往上搜索树，直到找到最近的Scaffold 父Widget的配置数据改变-&gt;重新构建对应的Element树-&gt;判断原来Element是否可以复用 renderobject从顶部向下传递约束，从底部向上传递布局信息 flutter_boost 、flutter_bloc:state,event,bloc,view flutter生命周期CreateState-&gt;initState-&gt;didChangeDependencies(inheritedWidget)-&gt;build-&gt;didUpdateWidget-&gt;deactivate(dispose) createState：StatefulWidget 中用于创建 State总体介绍一下生命周期,大致可以看成三个阶段:初始化 (插入渲染树🌲) initState、didChangeDependencies、build状态改变 (在渲染树中存在) didUpdateWidget、build销毁 (从渲染树中移除) deactivate、disposeinitState: 插入渲染树时调用只调用一次, widget创建执行的第一个方法, 可以再里面初始化一些数据,以及绑定控制器didChangeDependencies: 当State对象的依赖发生变化时被调用build: 它主要用户构建Widget字树的,调用次数:多次,初始化之后开始绘制界面,当调用setState触发的时候会再次被调用didUpdateWidget：当组件的状态改变的时候就会调用didUpdateWidget, 比如调用setState,deactivate: 当State被暂时从视图树中移除时,会调用这个函数.页面切换时也会调用它,因为此时State在视图树中的位置发送了变化,需要先暂时移除后添加dispose: 当State对象从树中被永久移除时调用; 通常在此回调中释放资源.———————————————— Flutter Boost Flutter Boost插件分为平台和Dart两端，两头通过Message Channel连贯。平台侧提供了Flutter引擎的配置和治理、Native容器的创立/销毁、页面可见性变动告诉，以及Flutter页面的关上/敞开接口等。而Dart侧除了提供相似原生Navigator的页面导航接口的能力外，还负责Flutter页面的路由治理。 未使用，flutter_boost对于连续的 Flutter 页面（Widget）只需要在当前 FlutterViewController 打开即可，对于间隔的 Flutter 页面我们初始化新的引擎 老的引擎共享方案：我们把共享的 Flutter View 当成一个画布，然后用一个 Native 的容器作为逻辑的页面。每次在打开一个容器的时候我们通过通信机制通知 Flutter View 绘制成当前的逻辑页面，然后将 Flutter View 放到当前容器里面 新的方案： 由Native容器Container通过消息驱动Flutter页面容器Container，从而达到Native Container与Flutter Container的同步目的。Flutter渲染的内容是由Naitve容器去驱动的。 把Flutter容器做成Webview浏览器一样。填写一个页面地址，然后由容器去管理页面的绘制。 当一个Native的页面容器存在的时候，FlutteBoost保证一定会有一个Widget作为容器的内容 在Native初始化容器，设置容器对应的页面标志 老方案在 Dart 层维护单个 Navigator 栈结构用于 Widget 的切换。而新的方案则是在 Dart 侧引入了 Container 的概念，不再用栈的结构去维护现有的页面，而是通过扁平化 key-value 映射的形式去维护当前所有的页面，每个页面拥有一个唯一的 id。这种结构很自然的支持了页面的查找和切换，不再受制于栈顶操作的问题，之前的一些由于 pop 导致的问题迎刃而解 所有页面路由操作，打开或者关闭页面，实际上都是对 Native 页面容器的直接操作 无论路由请求来自何方，最终都会转发给 Native 去实现路由操作。这也是接入 FlutterBoost 的时候需要实现 Platform 协议的原因。 单引擎 所有路由操作都汇总到原生端进行管理 每个页面都有一个pageId作为唯一标识，iOS使用的是container vc实例对象的hash值 页面生命周期使用container vc的生命周期为准，并同步到dart端 把Flutter容器做成Webview浏览器一样。填写一个页面地址，然后由容器去管理页面的绘制。** 多引擎模式混合方案：主要问题是如何去处理交替出现的Flutter和Native页面。对于连续的Flutter页面（Widget）只需要在当前FlutterViewController打开即可，对于间隔的Flutter页面我们初始化新的引擎。 4.离线化、本地服务 5.os_unfair_lock替代了自旋锁 自旋锁 等待锁的线程会一直处于忙等待状态，一直占用着资源，最大的问题是：出现优先级反转，低优先级的线程先获得了锁，如果等待锁的线程优先级高，它会一直占用这cpu资源，优先级低的锁就无法释放 struct并不是全部存放在栈上的，也有存放在堆上的 oc创建常量与swift创建的常量有什么区别 2.flutter与native通信MethodChannel _channe= const MethodChannel(‘battle_power’)_channel.invokeMethod 一种类型是method channel，数据在Dart侧进行序列化，然后会将数据发送到原生侧，你可以在原生侧编写代码响应交互，然后回传序列化后的数据。 Event Channel: 用于数据流（event streams）的通信，持续通信，收到消息后无法回复此次消息，通常用于Native向Dart的通信，如：手机电量变化，网络连接变化，陀螺仪，传感器等 isolate是怎么进行通信和实例化的？1、isolate实际就是一个隔离的Dart执行的上下文环境(或者容器) 2、isolate是有自己的内存和单线程控制的事件循环 3、isolate之间的内存在逻辑上是隔离的，不像Java一样是共享内存的 4、任何Dart程序的并发都是运行多个isolate的结果。Dart没有共享内存的并发； isolate线程之间的通信主要通过port来进行，这个port消息传递过程是异步的 Isolate每一个isolate都有一个event loop，用于管理异步任务的运行，这些任务可能来自于两个队列之中：microtask queue，或者`event queue耗时任务同一个isolate上运行，使用async也没用。 通过运行在不同的Isolate来并行处理，提供了compute()处理 如果代码片段不能被中断，则使用正常的同步过程（一个方法或多个相互调用的方法）；await..async 如果代码片段可以独立运行而不影响应用程序的流动性，请考虑通过使用Futures来使用事件循环； 如果繁重的处理可能需要一些时间才能完成并且可能会影响应用程序的流动性，请考虑使用Isolates。 怎么减少Widget的重新构建首先要做的就是将大的Widget树重构成较小的单个的Widget，每一个Widget都有它自己的build方法。尽可能的使用const构造函数，这将告知Flutter不需要重建这个widget。使stateful widget的子树尽可能的小，如果stateful widget有一个widget子树，那么为这个stateful widget创建一个自定义widget，并为其提供一个child参数。 ValueListenableBuilder从下到上或者横向共享数据，他的功能是监听一个数据源，如果数据源发生变化，则会重新执行其 builder 异步UI更新（FutureBuilder、StreamBuilder）现在改成使用flutter_bloc Flutter provider/ flutter_bloc 实现及原理，作用provider 中使用InheritedWidget ()作用InheritedWidget的data发生变化时，就会更新依赖它的子孙组件，也就是会调这些子孙组件的didChangeDependencies()方法和build()方法。 子组件如果使用了共享数据，在子组件获取父组件的数据时，可以通用dependOnInheritedWidgetOfExactType、getElementForInheritedWidgetOfExactType区别就是前者会注册依赖关系，而后者不会.ChangeNotifierProvider中return InheritedProvider extends InheritedWidget, 状态管理框架 Flutter bloc:state,event,bloc,view 解决了视图逻辑分离与可测试性问题 数据流方式：决定项目的 分层结构 与 业务逻辑 间的解耦程度。 BlocProvider 负责储存 传入XxxBloc加以储存 提供的of方法，在子节点获取到储存的XxxBloc 页面构建的适用BlocBuilder获取state Bloc 封装了Stream一系列对象,封装了关闭Stream流的操作等 flutter事件机制 组件只有通过命中测试才能响应事件。 一个组件是否通过命中测试取决于 hitTestChildren(…) || hitTestSelf(…) 的值。 组件树中组件的命中测试顺序是深度优先的。 组件子节点命中测试的循序是倒序的，并且一旦有一个子节点的 hitTest 返回了 true，就会终止遍历，后续子节点将没有机会参与命中测试。这个原则可以结合 Stack 组件来理解。 大多数情况下 Listener 的 HitTestBehavior 为 opaque 或 translucent 效果是相同的，只有当其子节点的 hitTest 返回为 false 时才会有区别。 HitTestBlocker 是一个很灵活的组件，我们可以通过它干涉命中测试的各个阶段。 Widget组件的大小是由自身决定的，而组件的位置是由父组件决定的 Flutter 调用其 createElement() 方法，创建其对应的 Element flutter的Element 根据什么来确定控件是否改变呢flutter 中的 Widget 一直在重建，每次重建之后，Element 都会判断新控件跟之前引用旧控件是否有所改变，如果没改变则只需要做更新操作，如果前后不同则会重创建。那么，Element 根据什么来确定控件是否改变呢？它会比较 Widget 以下两个属性： 组件类型：是否是同一个类所创建的，Key 即为每个控件的唯一标识。 Widget 的 Key （如果有） 如果不是同一个类型，那就把Widget、Element、RenderObject分别从它们的树（包括它们的子树）上移除，然后创建新的对象； 如果是一个类型，那就仅仅修改RenderObject中的配置，然后继续向下遍历 flutter高性能长列表容器 PowerScrollView，动画框架 Fish-Lottie，游戏引擎 Candy 热修复OCRunner： 前后端分离：PatchGenerator把修改代码生成二进制补丁，上传到服务器，app中下载解析，OCRunner 解释执行补丁 Hook Objective-C 方法 JSPatch ，通过将类的目标方法替换为 objc_msgForward，同时将 forwardInvocation: 方法的 IMP 替换为 JPForwardInvocation 函数，当目标方法被调用时触发消息转发，在 JPForwardInvocation 函数中获取 NSInvocation 的各个参数值，再使用 JavaScriptCore 调用相应的函数，再将得到的结果设置到 NSInvocation 的返回值。 动态更新方案总结React Native使用了react的设计模式，但是其UI渲染、动画效果、网络请求等均是由原生来实现的。开发者编写JS代码，通过React Native的中间层转化为原生控件，并进行操作。也就是说通过JS代码来调用原生的组件，从而实现相应的功能 2、动态化UI和服务端约定好的规则，数据格式。更具指定规则数据变化来动态展示页面。 1、动态化UI这一套思想实现的技术点都是js和原生交互，和RN实现很像每个页面会对应一个json,一个js文件，我们编写页面只需要一个人编写json,和js， Android和ios通用，共同维护一个库。基础的功能抽成原生组件，通过一个plist文件也就是字典来维护所有的组件，在页面的json中就是把一个个组件拼接起来。每个组件都有对应的id，component，value等等。json对应页面和设置，而具体业务逻辑等代码由js来完成，动作、传值(组件之间、界面之间)等等通过set、getCompontValue(id)设置获取组件值在开发过程中，查看需要的组件是否已存在，如果不存在，则需新建一个通用组件，尽量写的通用一些，方便后期多出调用这些json,js，最后可以通过服务费下发的方式来加载。如果一个页面有问题，只需要修改json,js，通过服务端来发布。 1234567891011121314151617181920{ &quot;component&quot;: &quot;input&quot;, &quot;config&quot;: { &quot;id&quot;: &quot;name&quot;, &quot;name&quot;: &quot;name&quot;, &quot;value&quot;: &quot;&quot;, &quot;prop&quot;: { &quot;title&quot;: &quot;标签名称（12个字以内）&quot;, &quot;placeholder&quot;: &quot;必填&quot;, &quot;maxLen&quot;: 12, &quot;lenVerTip&quot;: &quot;标签名称必须在12字以内&quot;, &quot;keyboardType&quot;: &quot;&quot;, &quot;remark&quot;: &quot;&quot;, &quot;disable&quot;: 0, &quot;required&quot;: 1, &quot;requiredTip&quot;: &quot;标签名称不能为空&quot; }, &quot;style&quot;: {} }} **组件化过程 **路由：tdf-manager://2dfire.com/member/scan模块间解耦 • 模块重用依赖中间层的库专门来定义跳转方法：TDFMediatorKit， A库调用TDFMediatorKit，通过performTarget：action:，target:是B库的分类Target_merber ，action:Action_controller [self performTarget:MemberModule action:ActiontoVC params:nil] 组件化——AppDelegate 生命周期 Carthage动态库转静态库 基于 CocoaPods 的组件二进制化实践 问题：组件越来越多，打包时间真加到1个小时， 将非开发中的组件预先编译打包成静态 / 动态库并存放至某处，待集成此组件时，直接使用二进制包，对比源码依赖，二进制依赖的组件只需要进行链接而无需编译 1、二进制化需求 2、制作二进制包：Carthage打包，存储，3.切换依赖方式，双私有源单版本 Genkins持续集成 GitLab CI 集成实践1.仓库的 Setting -&gt; CI/CD,设置 .gitlab-ci.yml路径， ，按照注册GitLab Runner2.gitlab-ci.yml、stages设置对应的阶段和脚本- component_check - lint - test - package - publish - report。一个 stage 中可以有多个 job，多个job并行的，job中包含script、tags、only。stage 的失败条件是任务最后一个执行的命令返回非零结果component_check 这个入口主要对组件进行一些简单快速的校验，比如我们针对目前团队组件中存在的一些问题，设置的 podspec 校验:1、校验依赖限制 2、校验业务线私有组件包含关系debug库等 GitLab CI 与组件自动化发布 genkins：编写打包脚本，主要是：我们有接入flutter，切换flutter库分支，pod update，fastlane打包，非release版本上传本地服务器，通知钉钉。如果是release，上传包到app connect store，上传符号表到buggly，自动增加build。 GitFlow 工作流 设计模式 工厂模式、观察者模式、中介者模式、单例模式 对比架构时，可以从是否职责分离，可测试性，可易维护性三个维度对比。 更多对比可以参考我翻译的一篇文章：【译】iOS 架构模式–浅析MVC, MVP, MVVM 和 VIPERMVC Model模型是数据所在的地方。 诸如持久性，模型对象，解析器，管理器和网络代码之类的东西都在这里。 View视图层是应用程序的外观。 它的类通常不包含任何特定于域的逻辑，因此通常可以重用。`Controller*通过委派模式在 View 和模型之间进行中介。 在理想情况下，控制器实体将不知道其处理的具体视图，它将通过协议与抽象进行通信。 一个经典的示例是 UITableView 通 UITableViewDataSource 协议与其数据源进行通信的方式。MVC缺点 分层设计弱，控制器几乎在这里处理所有事情，它处理业务逻辑和表示逻辑，包括更新 UI，动画等。 由于业务逻辑，表示逻辑和 UIKit 成员在控制器中混合在一起，因此难以进行单元测试。 可测试的类不应依赖任何 UIKit 成员无法轻易扩大规模。 难以维护，当项目成长时，控制器将变得混乱和沉重。 MVP 这里的 View 与 Model-View-Controller 模式中的 View 相同，除了 View 不应直接与 Model 交互，View 只能与 Presenter 交互。Model 也与 Model-View-Controller 模式中的模型相同，但是 Model 也不能直接与 View 交互，它应该仅与 Presenter 交互Presenter 是 Model-View-Presenter 模式引入的新层，如图所示，Presenter 是一个中间层，用于处理 View 和 Model 之间的通信。 它解决了许多 MVC 问题，例如可测试性，可维护性，可伸缩性。缺点：视图的渲染放在 Presenter 中，所以视图和 Presenter 的交互会过于频繁。如果 Presenter 过多地渲染视图，往往会使得它与特定的视图的联系过于紧密。 MVVM 1、 View 与 ViewModel 之间的通过数据绑定实现通信。2、ViewModel提供了业务/表示逻辑与 View / ViewController 之间的连接。视图（UI）通过将输入数据（由模型定义）传递给 ViewModel 来响应用户输入。反过来，ViewModel 评估输入数据，并根据业务逻辑工作流以适当的 UI 呈现进行响应。ViewModel 易于测试和重用 双向绑定时，当 Model 变化时，View-Model 会自动更新，View 也会自动变化。 View 的功能进一步的强化，具有控制的部分功能。 控制器的功能大部分移动到 View 上处理，大大的对控制器进行了瘦身。 MVVM搭配这RAC使用 缺点数据绑定使得 Bug 很难被调试。数据双向绑定不利于代码重用。大的模块，model 很大，不利于内存的释放。 RAC 如何实现双向绑定 1.Model—-&gt;View 这种流向很简单，你请求数据之后，通过Block的回调，最终更新UI2.View—–&gt;Model 反向绑定也一样，View触发事件，更新对面ViewModel里面绑定的数据源，例如登录注册的Textfield，你输入和删除的时候，你的Model字段会对应更新，当你提交的时候，读取ViewModel的字段，就是已经更新的最新数据。这是一种方式，我个人感觉如下图的另一种更容易理解，比如你选择某个cell或者点赞的时候，View事件触发，更新绑定的ViewModel字段，拥有ViewModel的控制器，用RACObserve来进行该字段开关的读取，如果监听到YES，就刷新对应的页面UI ![image-20211224152905126](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20211224152905126.png) 热信号一般在开发中充当的角色如下图所示： RAC中的RACSiganl类中几乎都是冷信号，初始化一个RACDynamicSignal保存一个block，等到有订阅者去订阅，如果没有订阅者的话，一直不会被调用，也就是冷信号被调用的前提是要有订阅者，这就是冷信号。 热信号就是使用RACSubject对象订阅源信号，而其他的订阅者订阅RACSubject，等待有值发出的时候，就会告诉所有的订阅者 RACSubject这个类会保存所有的订阅者，一旦被订阅，就会保存订阅者，等待有值发出的时候，就会告诉所有的订阅者。 LRU算法 LRU（Least recently used 最近最少使用）算法是一个缓存淘汰算法，其作用就是当缓存很多时，该淘汰哪些内容，见名知意，它的核心思想是淘汰最近使用最少的内容。实现它的关键步骤是：1.新数据插入到链表的头部 2.每当缓存命中时，则将数据移动到链表头部3.链表满时，将尾部数据清除 维护一个有序链表（我使用的双向链表） 靠近尾部的节点则在时间上越早被访问 当有新数据时，先从头开始遍历链表 如果数据已经在缓存中 遍历后得到数据所在的结点，从这个位置删除 最后插入到链表头部 如果数据没在缓存中，再次分为两种情况 如果缓存的空间没有满 直接把这个数据所在的结点插入到链表头部 如果缓存空间已满 先删除尾结点 把新数据的结点插入到链表头部 （这个思路不包含哈希表） weak的实现原理是什么？当引用对象销毁是它是如何管理内部的Hash表的？ runTime会把对weak修饰的对象放到一个全局的哈希表中，用weak修饰的对象的内存地址为key，weak指针为值，在对象进行销毁时，用通过自身地址去哈希表中查找到所有指向此对象的weak指针，并把所有的weak指针置位nil。 什么是哈希表？ 哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 哈希表hashtable(key，value) 的做法其实很简单，就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。 而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。 数据结构链表：二分搜索：一种在有序数组中查找某一特定元素的搜索算法二叉树 算法冒泡排序：两两相互比较，较大的交换位置后移。稳定选择排序：在未排序队列选出最小值，放在已排序队列的后面插入排序：未排序的值依次与有序队列的值对比，小于则交换位置，插入有序序列的适当位置。稳定，时间O(N2)， 空间O(1)归并排序：递归把数组对半分成若干个，两个数组排序合并， 设定两个指针i,j指向两个已经排序序列的起始位置，比较两个指针所指向的元素，选择相对小的元素放入到临时数组中，并移动指针到下一位置。稳定，时间O(NlogN), 空间O(n)快速排序：随机选择一个数作为基准，小于基准的交换位置与第一个大于基准的数交换，大于基准的数不动。可以确定基准的最终位置。再依次排序基准左边和右边的序列。堆排序：1.构建大顶堆 2.调整堆结构+交换堆顶元素与末尾元素 ，排序列表减一。 ![image-20220804154753630](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220804154753630.png) topK:1、Hash Table法:维护一个Key为Query字串，Value为该Query出现次数的HashTable，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内完成了对该海量数据的处理。300万中找到10个最大的数2、维护一个K(该题目中是10)大小的最小堆，然后遍历300万的Query，分别和堆顶进行对比。 先用Hash表统计每个Query出现的次数，O（N）；然后第二步、采用堆数据结构找出Top 10，N*O（logK）。所以，我们最终的时间复杂度是：O（N） + N’*O（logK）。（N为1000万，N’为300万）。 autoreleaseRunLoop)的每次循环开始时，在主线程创建一个自动释放池，并在每次循环结束时销毁它，在销毁时释放自动释放池中的所有autorelease对象。通常情况下我们不需要手动创建自动释放池，但是如果我们在循环中创建了很多临时的autorelease对象，则手动创建自动释放池来管理这些对象可以很大程度地减少内存峰值 RunLoop循环开始kCFRunLoopEntry，时自动创建AutoreleasePool，kCFRunLoopBeforeExit自动消耗AutoreleasePoolPage是以栈为结点通过双向链表的形式组合而成；遵循先进后出规则，整个自动释放池由一系列的AutoreleasePoolPage组成的自动释放池与线程一一对应；POOL_BOUNDARY为哨兵对象，入栈时插入，出栈时释放对象到此传入的哨兵对象 Core AnimationUIView Animation、CABasicAnimation、CAKeyframeAnimation、CAAnimationGroup、CATransition OClint实现静态分析的原理是什么，它是如何做到的？具体可以参考我之前写的如何通过静态分析提高iOS代码质量。 1、多线程、线程安全、锁1、多条线程访问读写同一数据时,会出现数据错乱的情况,在写之前加一把🔐2、dispatch_semaphore_wait：信号量值为0时会阻塞等待Main Dispatch Queue、Global Dispatch Queue、DISPATCH_QUEUE_CONCURRENT并行队列dispatch_async：异步，dispatch_sync同步dispatch_group_wait、dispatch_oncedispatch_barrier_asyncdispatch_barrier_async一般叫做“栅栏函数”，它就好像栅栏一样可以将多个操作分隔开，在它前面追加的操作先执行，在它后面追加的操作后执行。 多线程举例dispatch_group_wait,notify，多个请求完成获取到数据，结合之后用作其他请求或者dispatch_get_main_queen回主线程UI的更新。多线程对数组的添加删除，给临界区代码加锁等dispatch_semaphore_wait，使用信号量在多线程环境下顺序的添加计数等 死锁：1、串行队列任务中添加同步任务，同步需要等待当前任务完成，而它自身是就在任务当中2、一个线程多次获取同一个非递归锁，则会产生死锁。3、自旋锁spin_lock，线程会死循环的方式等待锁，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片，造成了任务的优先级反转 NSLock：互斥锁@synchronized递归锁NSRecursiveLock递归锁：递归锁有一个特点，就是同一个线程可以加锁N次而不会引发死锁，记录了一个线程加锁次数，直到一个线程所有的锁都被解锁了，其他线程才能得到资源递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作 递归锁：同一个线程可以多次获取同一个递归锁，不会产生死锁。非递归锁：如果一个线程多次获取同一个非递归锁，则会产生死锁。 递归锁是在非递归互斥锁加引用计数器来实现的 NSConditionLock：条件变量锁 atomic：用atomic修饰后，这个属性的setter、getter方法是线程安全的，但是对于整个对象来说不一定是线程安全的。使用的是pthread_mutex(互斥锁，也可设置递归锁、跨平台）原因：当A线程的写操作结束后，B线程进行写操作，然后当A线程需要读操作时，却获得了在B线程中的值，这就破坏了线程安全。 自旋锁: 等待时间比短，竞争不激烈时候。 互斥锁：耗时技术，读写操作等 自旋锁: 线程会死循环的方式等待锁，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片，造成了任务的优先级反转自旋锁：os_unfair_lock:当预计线程等待锁的时间很短，线程反复检查锁变量是否可⽤ 自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。 1、os_unfair_lock 2、OSSpinLock 3、dispatch_semaphore 4、pthread_mutex 5、dispatch_queue(DISPATCH_QUEUE_SERIAL) 6、NSLock 7、NSCondition 8、pthread_mutex(recursive) 9、NSRecursiveLock 10、NSConditionLock 11、@synchronized 2、SDWebimageSDWebImage提供了图片从加载、解析、处理、缓存、清理等一系列功能sd_setImageWithURL-&gt;SDImageCache从缓存中查找-&gt;用以url为key在硬盘缓存目录下查找，回到主线程进行查找结果的回调–&gt;如果硬盘中读取到图片，则将图片添加到内存缓存，并显示图片–&gt;如果硬盘未找到，则SDWebImageDownloader下载图片-&gt;在异步NSOperationQueue中，使用SDWebImageDecoder图片解码，-&gt;下载解析完成后，同时异步保存到内存缓存和硬盘缓存中。 清理缓存： 在app收到内存警告时清理缓存， 在app将要退出时 删除旧的缓存文件， 还有在app进入后台后，删除旧的缓存文件 YYlabel异步渲染YYText 核心思路：在异步线程创建图形上下文，然后利用 CoreText 绘制富文本，利用 CoreGraphics 绘制图片、阴影、边框等，最后将绘制完成的位图放到主线程显示。 (Class)layerClass;自定义CALayer子类作为UIview的layer display方法用来设置contents属性 3、cocoapod各个参数使用 use_frameworks! 时，cocoapods以动态库(dynamic frameworks)的方式引入外部库 不使用 use_frameworks! 时，cocoapods以静态库(static libraries)的方式引入外部库 4、动态库、静态库区别、二进制 **静态库(.a)**：链接时会被完整的复制到可执行文件中，被多次使用就有多分拷贝，但程序包会变的比较大； .a和.framework 动态库：编译时只存储指向动态库的引用，运行时动态加载到内存，系统只加载一次，多个程序共用，节省内存 动态库：.dylib和.framework .h+资源文件+库文件 .a 是单纯的二进制文件，.framework是二进制问价+资源文件。 其中.a 不能直接使用，需要 .h文件配合，而.framework则可以直接使用。 .framework = .a + .h + sorrceFile(资源文件) Framework：是资源的打包方式，和静态库、动态库本质没什么关系。 5、gitlab、genkins添加新的机器方式，快速添加 6、https、afnetworking、dnsHTTPS: 在HTTP的基础下加入了SSL/TLS层，这也HTTPS的安全基础。HTTPS建立连接的阶段也就是非对称加密+对称加密+数字证书协同作用的过程dns:域名系统 (DNS) ,DNS 将域名转换为 IP 地址 SSL协议的握手过程1、客户端向服务器发送支持的SSL/TSL的协议版本号，以及客户端支持的加密方法，和一个客户端生成的随机数2、服务器确认协议版本和加密方法，向客户端发送一个由服务器生成的随机数，以及数字证书3、客户端验证证书是否有效，有效则从证书中取出公钥，生成一个随机数，然后用公钥加密这个随机数，发给服务器4、服务器用私钥解密，获取发来的随机数5、客户端和服务器根据约定好的加密方法，使用前面生成的三个随机数，生成对话密钥，用来加密接下来的整个对话过程 数字证书：包括 公钥和数字签名 公钥通过hash算法可以得到数据摘要，数据摘要使用CA的私钥加密得到数字签名。 （1）生成对话密钥一共需要三个随机数。（2）握手之后的对话使用”对话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密”对话密钥”（非对称加密），无其他作用。（3）服务器公钥放在服务器的数字证书之中。 CA机构加密CA 签发证书的过程，如上图左边部分：首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；最后将 Certificate Signature 添加在文件证书上，形成数字证书；客户端校验服务端的数字证书的过程， 客户端解密验证证书有效性首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 AFNetWorking策略、缓存、安全校验断点续传、分片上传断点续传的主要思路:检查服务器文件信息、检查本地文件、如果比服务器文件小, 断点续传, 利用 HTTP 请求头的 content-range实现断点续传（如果content-range不存在就取Content-Length的大小） AFURLSessionManager/AFHTTPSessionManager： NSURLSession 网络通信模块：负责网络请求的发起，回调处理，是在系统网络相关API上的一层封装。Serialization序列化模块：AFURLRequestSerialization是将传入的参数构造成NSURLRequest、AFURLResponseSerialization主要是将系统返回的NSURLResponse处理成我们需要的responseObject，比如json、xml、imageReachability 网络状态监听模块Security 网络通讯安全策略模块、AFSecurityPolicy https相关的公钥和证书验证逻辑。但 NSURLConnection 和 NSURLSession 并没有验证证书是否合法，无法避免中间人攻击 客户端加密方式客户端：sign：把所有参数拼接成字符串+时间戳timestamp+约定的Key+RSA、SHA256、MD5+salt加密约定的Key可以转换一下或者加密，然后存入Keychaintoken：登录的用户需要把后台返回的token一起上传（Token是否有效根据后台设定refreshToken是否过期判断,过期要重新加载）服务端：服务端对token、timestamp和sign进行验证，服务器缓存：将sign、Token以键值对的形式存放在缓存服务器中,验证sign屏蔽重复请求 8、热修复方案及原理 10、组件化方案对比URL Router App启动时实例化各组件模块，然后这些组件向ModuleManager注册Url，有些时候不需要实例化，使用class注册 当组件A需要调用组件B时，向ModuleManager传递URL，参数跟随URL以GET方式传递，类似openURL。然后由ModuleManager负责调度组件B，最后完成任务 极高的动态性，适合经常开展运营活动的app，例如电商 传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来 参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式 Target-Action 抽离业务逻辑 通过中间层进行调⽤ 中间层使⽤ runtime 反射 中间层代码优化 业务逻辑柔合在Mediator中，可以各个模块写各自的MTMediator扩展 这个方案是基于OC的runtime、category特性动态获取模块，例如通过NSClassFromString获取类并创建实例，通过performSelector + NSInvocation动态调用方法 其实现思路是： 1、利用分类为路由添加新接口，在接口中通过字符串获取对应的类 2、通过runtime创建实例，动态调用实例的方法 需要在mediator 和 target中重新添加每一个接口，模块化时代码较为繁琐 Target_B，Action_B_VC ![image-20220904164900755](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220904164900755.png) Protocol-Class 增加 Protocol Wrapper层 （中间件先注册Protocol和Class对应关系，将protocol和对应的类进行字典匹配） 中间件返回 Protocol 对应的 Class，然后动态创建实例 11、swift优点，为什么使用swift 12、flutter优点，为什么不使用RN React Native使用了react的设计模式，但是其UI渲染、动画效果、网络请求等均是由原生来实现的。开发者编写JS代码，通过React Native的中间层转化为原生控件，并进行操作。也就是说通过JS代码来调用原生的组件，从而实现相应的功能 通过写 JS 代码配置页面布局，然后 React Native 最终会解析渲染成原生控件 13、说一个完全有你主导的项目、优化等 14、说一个你认为最难得，最优秀的项目 15、直播短视频相关优化 动态库懒加载 pagefault原理 OC内存管理机制，autoreleasepool atomic flutter_boost 线上网络监控 域名dns劫持 美团、微信、360等性能监控技术 RAC原理 1、Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送 2、Hot Observable是主动的，多个订阅者，是一对多，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；。 如何将一个冷信号转化成热信号——广播冷信号与热信号的本质区别在于是否保持状态，冷信号的多次订阅是不保持状态的，而热信号的多次订阅可以保持状态。所以一种将冷信号转换为热信号的方法就是，将冷信号订阅，订阅到的每一个时间通过RACSbuject发送出去，其他订阅者只订阅这个RACSubject。 纯函数就是返回值只由输入值决定、而且没有可见副作用的函数或者表达式。这和数学中的函数是一样的 设计模式 如何和h5交互WKWebView1、JS调用OC代码 [self.webView.configuration.userContentController addScriptMessageHandler:self name:@”Share”];2、OC调用JS代码 [self.webView evaluateJavaScript:@”show()” completionHandler:^(id _Nullable response, NSError * _Nullable error) { //TODO }]; 费曼学习法 多问为什么，找为什么 视洞科技：视频，摄像机，录像功能 丁香医生：线上问诊，报告解读，疾病查询，健康百科 回答自信小影一面1、layoutSubviews、layoutIfNeeded、setNeedsLayout、layoutSubviews在runloop哪一阶段 layoutSubviews()：不要直接调用，可以在子类中重写该方法以获得子视图更加精细的布局。 layoutIfNeeded()：同步、立即更新重绘当前视图及子视图，不等待更新周期。 setNeedsLayout()：异步、会等待下一个runloop更新周期时候更新 setNeedDiplay：调用该方法后，系统会自动调用drawRect: Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件，然后统一渲染需要修改的UI 在主 RunLoop 中，包含了一个 Update Cycle当主 RunLoop 中的事件处理完毕之后，将会进入到 Update Cycle, 对界面进行需要的更新在 Update Cycle 中，系统会处理 UI 的布局，约束，显示的更新 当我们对某个 view 进行了一次改变，也就是发起了一次改变请求后，系统就会将这个 view 标识为需要重绘，当在下一个 Update Cycle 时，系统就会对之前标记的 view, 根据相应的改变进行更新 在 iOS 系统中，界面的更新频率是 60 fps(Frames Per Second). 即每秒会传输 60 帧的画面。因此，在每次的需要对 UI 进行计算时，都需要在 1/60 秒内完成，否则，就会造成视觉上的卡顿 LayoutlayoutSubviews做什么 用于对一个 view 及其 subview 进行重新定位以及重置大小 它会对当前的 view 及其 subview 一个位置及大小的值 调用时机 若 view 需要重新计算frame 值时，系统将会调用此方法 注意 这个方法实际上是非常耗费资源的，因为它需要不断调用 view 及其 subview 的对应方法 不要直接调用，而是利用系统提供的机制来间接调用 viewDidLayoutSubviews调用时机 当 layoutSubviews 完成后，将会触发控制器中的这个方法注意 当逻辑需要依赖于布局或 view 大小的时候，将逻辑放到此方法中实现，而不是放到 viewDidLoad 或 viewDidAppear 通知系统 view 的布局状态发生变化自动通知 对一个 view 进行 resize 添加一个 subview 滚动 UIScrollView, layoutSubviews 会在 UIScrollView 及其 superview 上进行调用 屏幕旋转 更新 view 的约束 手动通知 setNeedsLayout layoutIfNeeded setNeedsLayout 触发 layoutSubviews 的消耗最小的方法 并不会立刻更新 view, 而是等待下一个 Update Cycle layoutIfNeeded调用时机 并不会等待下一个 Update Cycle, 而是直接调用 layoutSubviews 当调用了 setNeedsLayout 或设置了上面能自动通知的属性后，再调用此方法，layoutSubviews 将会在那些需要更新的 view 上调用 当调用了此方法，但之前并没有 view 的视图发生了变化，那么，layoutSubviews 不会被调用 当在同一个 RunLoop 调用了两次此方法，并且在两次调用之间没有发生 view 的改变，那么，第二次的调用不会出发 layoutSubviews DisplaydrawRect 重绘机制iOS的绘图操作是在UIView的drawRect中完成的，我们想要在UIView中完成绘图（或者自定义控件），需要在UIView的拓展类（或者子类）中重写drawRect函数，在这里进行绘图的操作，系统会自动调用该函数进行绘图。 重绘也是在drawRect:中完成的 sizeToFit:会计算出最优的 size 而且会改变自己的sizesizeThatFits:会计算出最优的 size 但是不会改变 自己的 size Cocoa animation UIKit的UIview相关动画 CAAnimation ![image-20230418140432263](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230418140432263.png) 2、dealloc使用self发送消息 一般移除一些通知，监听，计时器等 3、多线程：GCD如何控制并发量 4、多线程累加计数 GCD_barrira—-需要写代码 5、for（int i;i &lt; 1000;i++）里边异步并发输出i 6、SDwebimageView 7、代理设置多个对象，内存问题 8、wwdc、学习方法，看过哪些书 storeKit应用内购买（收据验证、发票查询 API 和退款查询 API）、小窗口组件、图文翻译、照片搜索、添加电子钥匙丢单：这里会收到苹果支付的返回凭证，这里要做下本地存储，防止发送后台失败引起的丢单。等后台验证成功再删除本地凭证串单：收到支付结果的时候就可以去取出这个订单号，发送后台进行验证，这样就能有效的规避串单问题。如何没有获取到支付返回的凭证，崩溃了，下次启动时候设置监听获取交易回调，再发给服务端验证 网易： 1、数据库 2、sokets 2、二叉树的根节点，返回值是二叉树的高度 3、多线程 小可智能： 浅 copy ：是对指针的 copy ，指针指向的内容是同一个地址，对象的引用计数+1; 深 copy ：是对内容的 copy ，会开辟新的内存空间，将内容重新 copy 一份； 1、浅拷贝：拷贝指针，不开辟内存地址 深拷贝：拷贝指针和内容，开辟新内存地址（存放拷贝的内容） 不可变对象copy浅拷贝。 可变对象copy、不可变对象mutableCopy、可变对象mutableCopy都是深拷贝。 字符串一般使用copy，不希望改变原来的对象的值。 注意：当使用 copy 修饰的属性赋值时，copy 出来的是一份不可变对象。因此当对象是一个可变对象时，切记不要使用 copy 进行修饰。如果这时使用 copy 修饰，当使用 copy 出来的对象调用可变对象所特有的方法时，会因为找不到对应的方法而 Crash。 修饰属性时用strong还是copy?最安全的做法（推荐）：修饰不可变对象（NSString，NSArray，NSDictionary等）用copy，修饰可变对象（NSMutableString，NSMutableArray，NSMutableDictionary等）用strong 同花顺： 1、链表 2、二叉树 登虹 1、[super instants] 2、UITouch 的 gestureRecognizers 属性中的存储了在寻找第一响应者的过程中收集到的手势，而在不断触发 touches 系列方法的过程中，手势识别系统也在在不停的判断当前这个 UITouch 是否符合收集到的某个手势。当手势识别成功： 被触摸的那个视图，也就是第一响应者会收到 touchesCancelled 的消息，并且该视图不会再收到来自该 UITouch 的 touches 事件 3、自动释放池自动释放池是OC中的一种内存自动回收机制，它可以将加入 AutoreleasePool 中的变量 release 的时机延迟，简单来说，就是当创建一个对象，在正常情况下，变量会在超出其作用域的时立即 release。如果将对象加入到了自动释放池中，这个对象并不会立即释放，会等到 runloop 休眠/超出 autoreleasepool 作用域{}之后才会被释放。其机制如下图所示 autoreleasepool：runloop Entry时候创建，BeforeWaiting和exit时候释放 哪些对象会加入自动释放池：1.主动调用autorelase方法的用alloc, init,copy等方法创建的对象，这些我们自己持有的，我们想让他延迟释放，就调用autorelase方法，这样在自动释放池出栈的时候，对象就会释放掉。2.而对于那种stringwithformt这种从名字来看，没有被调用者持有的情况，要么是自动加到自动释放池里的，要么是常量字符串，不用引用计数来管理。 4、__block 网易1、从0开始搭建app需要注意哪些东西补充 架构选型，根据自身业务选择适合的语言，如果是快速成型的，导入各个基础功能组件库，网络库，定制路由方案，开发设计模式，快速接入一些第三方的监控平台比如bugly,友盟等， 容器化区块化埋点sdwebimage相同url，但图片资源更新验证：Http、Https缓存机制中提供了验证机制，利用Last-Modified 或者Entity Tag（ET）来验证当前已缓存的资源是否与服务端最新资源相同。 WKWebview预加载全局WebView由于初始化过程发生在客户端原生代码中，而大部分方案也是通过前端和客户端协作完成，而全局WebView也是业界采用的比较通用的方案。方法：在客户端刚启动时，就初始化一个全局的WebView待用，并隐藏；当用户访问了WebView时，直接使用这个WebView加载对应网页，并展示。这种方法可以比较有效的减少WebView在App中的首次打开时间。当用户访问页面时，不需要初始化WebView的时间。当然这也带来了一些问题，包括：额外的内存消耗。页面间跳转需要清空上一个页面的痕迹，更容易内存泄露。 光相block重新梳理 组件化重新梳理文字 Carsh定位 runloop与线程的关系 简单地说Runloop就是一种循环机制，让线程在有任务时工作，没有任务时睡眠。避免线程执行完就直接结束 Runloop和线程是绑定的，它们存在一一对应的关系； Runloop是由系统进行创建管理的，你只能获取不能创建； 主线程的Runloop在程序启动时就开启了，子线程的Runloop需要我们手动开启； 计时器nstimer准确吗 使用mach_absolute_time()获取CPU已运行的tick数量。GCD计时器dispatch_source_t SDK .a .framework静态库与动态库的区别？静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。表现形式为 .a和.framework。动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。 表现形式为 .dylib和.framework。注意：动态库只能苹果使用，如果项目中使用了动态库不允许上架(如：jspatch) a与.framework有什么区别？.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。 .a文件不能直接使用，至少要有.h文件配合（微信的SDK就是这种形式），.framework文件可以直接使用。 .a + .h + sourceFile = .framework。 建议用.framework。再者 静态方式开发，一直是iOS SDK开发的主流方式 网络安全WKWebview预加载 组件化方案 多线程问题排查处理离线化客户端技术中台 ？？容器化方案、组件化方案、webview离线化方案、多线程问题专项治理、弱网优化方案、启动速度优化方案、二进制重排、直播性能监控、Instruments性能调优、缩小包体、内存泄露监控、UITableView优化、WKWebview预加载、播放器预热、动态UI更新方案 swift和oc中的初始化方法 swift和oc常量定义有什么不同 ObjC中 const表明的常量类型和数值是在 compilation time 编译时确定的；而 Swift 中 let 只是表明常量（只能赋值一次），其类型和值既可以是静态的，也可以是一个动态的计算方法，它们在 runtime 运行时确定的 Static 什么时候确定的，内存分布 static修饰的变量只会初始化一次，永远都只有一份内存 、finnal，内存分布 内联函数 yykit 绿点1、思路不清晰。 2、架构分层，不清晰 3、oc、swift、flutter、reactNavite 选型分析，基于原理 性能、体验：oc、swift是最优选择，生态环境也稳定。flutter基于dart语言，react 跨端能力： 热更新能力： 4、容器化分层不清晰 5、 刚刚几个问题有哪几点是答错的，可以提点一下吗。 6、 业务主要产品，团队成员情况 7、如果我加入之后会做哪个反向 思享无限1、组件化重新梳理 、多APP间跳转 2、swift 初始化方法 3、swift单例 4、runtime中结构体成员有哪些 5、coroGraphore 绘图， drawRect 6、swift，set,get 方法，super init 构造器的继承和重载 Swift 中的子类不会默认继承父类的构造器。 父类的构造器仅在确定和安全的情况下被继承。 当你重写一个父类指定构造器时，你需要写override修饰符。 7、对于生命周期中会变为nil的实例使用弱引用。相反的，对于初始化赋值后再也不会被赋值为nil的实例，使用无主引用。 不同点是 unowned 是永远有值的。weak可以声明可选型 8、程序安全 flutter问题1、如何定位视图的位置 2、页面返回，刷新数据，如何出发。（原生和flutter混编） ios问题1、多个地方同时hook同一个方法 依次hook,按照被hook的顺序执行，后面hook的先执行。其实就是看+load方法，该类被加载进runtime的时候。 调用顺序：+load父类&gt;子类&gt;分类（加载顺序取决于编译的顺序） 2、多线程nsoperation 如果取消一个任务，任务还会继续吗，任务能完成吗 在NSOperationQueue中已经添加的任务不能被直接移除 对于还没有执行的任务，队列还是要去调用“start”方法，然后任务才能去完成取消这个动作 取消任务这个操作会让任务忽略任何一个依赖关系，而快速去执行“start”方法，从而让任务取消 3、多个组件化细节落实。 4、容器化，细节落实，tableviewcell代理方法生命周期分发，那么cell复用会有问题吗 carsh定位总结 swift单例 学习1、Shell、python脚本语言 2、socket协议 3、手机与设备间的通信协议 Flutter webview Flutter 动画描述： 参与项目技术方案制定、技术评审、代码审核、内部技术交流分享等 参与客户端业务和框架的开发和维护，实现关键技术选型、验证、落地 负责高质量的技术设计和编码、设计良好的代码结构，不断迭代重构 规范文档的编写、维护、以及其他与项目相关工作 学习与探索新技术，提升项目性能与提高开发效率 具备良好的职业素养和团队协作精神，以及较强的学习能力，可独立承担部分的开发任务； 具有良好的沟通能力和团队合作精神，以及较强的学习能力，工作踏实诚恳，认真负责 扎实的iOS开发基础，熟练掌握Objective-C/Swift开发语言,熟悉Xcode开发环境3、熟悉iOS底层、多线程处理，熟悉模块化开发及常见设计模式4、对iOS的基础架构、组件、性能优化、内存优化有深刻的了解 重点负责iOS产品研发，参与客户端技术中台的开发和架构；2、参与移动平台软件框架的研究，设计和实现、关键技术验证和选型等工作；3、体系化梳理和优化架构设计，确保系统的高可用和在线服务的稳定4、优化和迭代已有产品软件的模块结构和流程逻辑；5、跟进iOS的新技术发展，对新技术进行学习、研究和应用 跟踪并修复业务中的bug，保障app达到质量要求 1、参与相关产品的需求分析、交互设计，根据相应资源及时间制定版本计划和技术方案；2、负责相关产品的系统分析，架构设计，模块编码，保证质量、追求性能及思考多国家版本复用；3、掌握性能调优，提供APP稳定性，负责发现并改进现有软件的的架构以及实现缺陷，对网络、链路及协议有一定理解和掌握；4、研究探索前沿技术，满足产品需求、促进业务发展及改进架构、提升效能","link":"/%E5%B0%8F%E7%BB%93.html"}],"posts":[{"title":"AppDelegate组件解耦","text":"在没有实行组件化的项目中，经常会在 AppDelegate 看到各类初始化代码，这一部分代码一般用以配置某些 key 以及 secret ，或者开启某些服务，常见的有第三方推送、统计分析、IM服务等。当然，也有可能是开启一些自身的服务，比如 log 日志、 数据库初始化等。当一个 App 达到一定体量后， 未经整理的 AppDelegate 可能会变得臃肿。那么在实行组件化之后，该如何处理这部分代码呢？ 不管理组件生命周期不对组件生命周期进行管理，那么只能继续将这些初始化代码放在主工程的 AppDelegate 中，而针对上文所说的 AppDelegate 臃肿的问题，也可以通过简单的封装来优化。 但是，这种做法会引发组件独立性问题。比如存在能独立运行的组件 A、B，B 依赖 A， A 生效需要在 App Launch 时调用配置代码 Code-A。如果采用上述做法，那么组件 A 所在示例工程的 AppDelegate 中，需要调用 Code-A 进行配置，而组件 B 因为依赖了 组件 A ，要使组件 B 能成功运行，也需要在 B 的示例工程添加 Code-A 进行配置。同样主工程的 AppDelegate 中也存在一份 Code-A 配置代码。可以看到，这种重复手动配置的做法是比较繁琐和难看的，这也是为什么要对组件生命周期进行管理的原因。 现有实现管理方案从组件和主工程的关系切入，既然组件需要在 App 生命周期的某些阶段处理特定的事务，那么就提供特定的回调方法供组件使用。 App 生命周期各个阶段产生的事件，可以通过让 AppDelegate 遵守 UIApplicationDelegate 协议并实现不同的代理方法进行捕获。 要想把当前阶段 App 产生的事件分发给各个组件，最简单的方案就是如 limboy 所说，在 AppDelegate 的各个代理方法里，手动调一遍组件的对应方法，如果组件实现了对应的代理方法，就执行： 123456789101112131415- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ [MGJApp startApp]; [[ModuleManager sharedInstance] loadModuleFromPlist:[[NSBundle mainBundle] pathForResource:@&quot;modules&quot; ofType:@&quot;plist&quot;]]; NSArray *modules = [[ModuleManager sharedInstance] allModules]; for (id&lt;ModuleProtocol&gt; module in modules) { if ([module respondsToSelector:_cmd]) { [module application:application didFinishLaunchingWithOptions:launchOptions]; } } [self trackLaunchTime]; return YES;} 不过这种方式缺点也很明显，组件需要依赖主工程的 AppDelegate 是否实现了 UIApplicationDelegate 的代理方法，如果没有的话，即使组件方实现了对应的代理方法，依然无法捕获到事件。 再来看下 caojun 的处理方案 YTXModule。 这个方案主要思路是通过 runtime method swizzling，替换 AppDelegate 中实现的 UIApplicationDelegate 代理方法，然后在 swizzled method 中，执行事件分发。 YTXModule 提供了一些宏定义，精简了方法替换流程： 123456789101112131415161718192021@implementation UIApplication (YTXModule)- (void)module_setDelegate:(id&lt;UIApplicationDelegate&gt;) delegate{ static dispatch_once_t delegateOnceToken; dispatch_once(&amp;delegateOnceToken, ^{ SWIZZLE_DELEGATE_METHOD(applicationDidFinishLaunching:); ... }); [self module_setDelegate:delegate];}@end@implementation YTXModule...+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions{ DEF_APPDELEGATE_METHOD_CONTAIN_RESULT(application, launchOptions);}...@end 这里需要注意的是，由于 method swizzling 是在不同类型载体（AppDelegate对象 &lt;-&gt; YTXModule类）间交换的方法，所以会造成在 +ytxmodule_applicationDidFinishLaunching: 中调用 self 时，获取的并不是 YTXModule类，而是 AppDelegate对象，因为方法替换实际上替换了 IMP，并没有改变实参，参照 objc_msgSend(id self, SEL op, ... ) 的参数排列，可以明确第一个参数是消息接收者，也就是 AppDelegate对象。通过上述分析可以知道，如果直接进行方法替换，不做特殊处理，使用以下代码将会抛出 unrecognized selector 异常 ： 12345+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions{ // self is AppDelegate instance [self ytxmodule_application:application didFinishLaunchingWithOptions:launchOptions];} 而以下代码，是可以正常运行的： 1234+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions{ [YTXModule ytxmodule_application:application didFinishLaunchingWithOptions:launchOptions];} 所以 caojun 在方法替换时，给 AppDelegate 添加了相同命名的实例方法，规避了这个异常 ： 12345678910111213141516171819202122232425void Swizzle(Class class, SEL originalSelector, Method swizzledMethod){ Method originalMethod = class_getInstanceMethod(class, originalSelector); SEL swizzledSelector = method_getName(swizzledMethod); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod &amp;&amp; originalMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } // 这一步给 AppDelegate 添加相同命名的实例方法，并且其 IMP 是 AppDelegate 自身方法的原实现 class_addMethod(class, swizzledSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));} 虽说这种方案也能实现事件的分发，但是在不同类型载体间使用 method swizzling 还是应该避免的，对其他开发者不是很友好。并且这种方案也存在依赖 YTXModule 是否替换了 UIApplicationDelegate 的代理方法问题，如果没有，组件方是无法捕获事件的。 一种更加优雅的方案 分发、代理 看到这两个关键词，可以直接联想到 runtime 的另一重要组成部分，消息转发。以下是我结合消息转发实现的组件生命周期管理方案。 先看下 UML 类图： 首先是 TDFModule ，模块基类，所有想要捕获 App 生命周期事件的模块都需要创建一个继承 TDFModule 的类，并且遵守 TDFModuleProtocol 协议： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** 模块子类必须遵守此协议 */@protocol TDFModuleProtocol &lt;UIApplicationDelegate&gt;@end/** 模块优先级 - TDFModulePriorityVeryLow: 极底 - TDFModulePriorityLow: 低 - TDFModulePriorityMedium: 中 - TDFModulePriorityHigh: 高 - TDFModulePriorityVeryHigh: 极高 */typedef NS_ENUM(NSInteger, TDFModulePriority) { TDFModulePriorityVeryLow = 0, TDFModulePriorityLow = 1, TDFModulePriorityMedium = 2, TDFModulePriorityHigh = 3, TDFModulePriorityVeryHigh = 4,};@interface TDFModule : NSObject+ (instancetype)module;/** 在 load 中调用，以注册模块 */+ (void)registerModule;/** 模块优先级 主工程模块的调用最先进行，剩余附属模块， 内部会根据优先级，依次调用 UIApplicationDelegate 代理 默认是 TDFModulePriorityMedium @return 优先级 */+ (TDFModulePriority)priority;@end@implementation TDFModule- (instancetype)init { if (self = [super init]) { if (![self conformsToProtocol:@protocol(TDFModuleProtocol)]) { @throw [NSException exceptionWithName:@&quot;TDFModuleRegisterProgress&quot; reason:@&quot;subclass should confirm to &lt;TDFModuleProtocol&gt;.&quot; userInfo:nil]; } } return self;}+ (instancetype)module { return [[self alloc] init];}+ (void)registerModule { [TDFModuleManager addModuleClass:self];}+ (TDFModulePriority)priority { return TDFModulePriorityMedium;} 子类需要在 +load 方法中调用 registerModule 才能让模块具备捕获 App 事件的能力。因为 TDFModuleProtocol 直接遵守的 UIApplicationDelegate 协议，子类可以和 AppDelegate 一样，直接实现自己感兴趣的代理方法即可： 123456789101112131415161718192021222324252627282930@interface TDFAModule : TDFModule &lt;TDFModuleProtocol&gt;@end@implementation TDFAModule+ (void)load { [self registerModule];}+ (TDFModulePriority)priority { return TDFModulePriorityHigh;}- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { NSLog(@&quot;%@, %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd)); return YES;}- (void)applicationWillEnterForeground:(UIApplication *)application { NSLog(@&quot;%@, %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));}- (void)applicationDidBecomeActive:(UIApplication *)application { NSLog(@&quot;%@, %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));}- (void)applicationWillTerminate:(UIApplication *)application { NSLog(@&quot;%@, %@&quot;, NSStringFromClass([self class]), NSStringFromSelector(_cmd));}@end 以上就是一个简单的使用示例。 接下来是 TDFModuleManager ，模块管理类。这个单例类主要负责模块的储存，以及在 UIApplication 的 -setDelegate: 中，把原来 delegate 替换成自己的 delegate proxy 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103@interface TDFModuleManager : NSObject { @package TDFApplicationDelegateProxy *_proxy;}@property (strong, nonatomic, readonly) TDFApplicationDelegateProxy *proxy;@property (strong, nonatomic, readonly) NSArray &lt;TDFModule *&gt; *modules;+ (instancetype)shared;+ (void)addModuleClass:(Class)cls;+ (void)removeModuleClass:(Class)cls;@endstatic NSMutableArray const * TDFModuleClassArray = nil;@implementation TDFModuleManager+ (instancetype)shared { static dispatch_once_t onceToken; static TDFModuleManager *singleton = nil; dispatch_once(&amp;onceToken, ^{ singleton = [[self alloc] init]; }); return singleton;}+ (void)addModuleClass:(Class)cls { NSParameterAssert(cls &amp;&amp; [cls isSubclassOfClass:[TDFModule class]]); if (!TDFModuleClassArray) { TDFModuleClassArray = [NSMutableArray array]; } if (![TDFModuleClassArray containsObject:cls]) { [TDFModuleClassArray addObject:cls]; }}+ (void)removeModuleClass:(Class)cls { [TDFModuleClassArray removeObject:cls];}- (void)generateRegistedModules { [self.mModules removeAllObjects]; [TDFModuleClassArray sortUsingDescriptors:@[[[NSSortDescriptor alloc] initWithKey:@&quot;priority&quot; ascending:NO]]]; for (Class cls in TDFModuleClassArray) { TDFModule *module = [cls module]; NSAssert(module, @&quot;module can't be nil of class %@&quot;, NSStringFromClass(cls)); if (![self.mModules containsObject:module]) { [self.mModules addObject:module]; } }}- (TDFApplicationDelegateProxy *)proxy { if (!_proxy) { _proxy = [[TDFApplicationDelegateProxy alloc] init]; } return _proxy;}- (NSArray&lt;TDFModule *&gt; *)modules { return (NSArray&lt;TDFModule *&gt; *)self.mModules;}- (NSMutableArray&lt;TDFModule *&gt; *)mModules { if (!_mModules) { _mModules = [NSMutableArray array]; } return _mModules;}@endstatic void MCDSwizzleInstanceMethod(Class cls, SEL originalSelector, Class targetCls, SEL swizzledSelector) { Method originalMethod = class_getInstanceMethod(cls, originalSelector); Method swizzledMethod = class_getInstanceMethod(targetCls, swizzledSelector); BOOL didAddMethod = class_addMethod(cls, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(cls, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); }}@implementation UIApplication (TDFModule)+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ MCDSwizzleInstanceMethod(self, @selector(setDelegate:), self, @selector(mcd_setDelegate:)); });}- (void)mcd_setDelegate:(id &lt;UIApplicationDelegate&gt;)delegate { TDFModuleManager.shared.proxy.realDelegate = delegate; [TDFModuleManager.shared generateRegistedModules]; [self mcd_setDelegate:(id &lt;UIApplicationDelegate&gt;)TDFModuleManager.shared.proxy];}@end 最后是这个方案的重点，也就是 TDFApplicationDelegateProxy 类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@interface TDFApplicationDelegateProxy : NSObject@property (strong, nonatomic) id &lt;UIApplicationDelegate&gt; realDelegate;@end@implementation TDFApplicationDelegateProxy- (Protocol *)targetProtocol { return @protocol(UIApplicationDelegate);}- (BOOL)isTargetProtocolMethod:(SEL)selector { unsigned int outCount = 0; struct objc_method_description *methodDescriptions = protocol_copyMethodDescriptionList([self targetProtocol], NO, YES, &amp;outCount); for (int idx = 0; idx &lt; outCount; idx++) { if (selector == methodDescriptions[idx].name) { return YES; } } free(methodDescriptions); return NO;}- (BOOL)respondsToSelector:(SEL)aSelector { if ([self.realDelegate respondsToSelector:aSelector]) { return YES; } for (TDFModule *module in [TDFModuleManager shared].modules) { if ([self isTargetProtocolMethod:aSelector] &amp;&amp; [module respondsToSelector:aSelector]) { return YES; } } return [super respondsToSelector:aSelector];}- (id)forwardingTargetForSelector:(SEL)aSelector { if (![self isTargetProtocolMethod:aSelector] &amp;&amp; [self.realDelegate respondsToSelector:aSelector]) { return self.realDelegate; } return self;}- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { struct objc_method_description methodDescription = protocol_getMethodDescription([self targetProtocol], aSelector, NO, YES); if (methodDescription.name == NULL &amp;&amp; methodDescription.types == NULL) { return [[self class] instanceMethodSignatureForSelector:@selector(doNothing)]; } return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];;}- (void)forwardInvocation:(NSInvocation *)anInvocation { NSMutableArray *allModules = [NSMutableArray arrayWithObjects:self.realDelegate, nil]; [allModules addObjectsFromArray:[TDFModuleManager shared].modules]; // BOOL 型返回值做特殊 | 处理 if (anInvocation.methodSignature.methodReturnType[0] == 'B') { BOOL realReturnValue = NO; for (TDFModule *module in allModules) { if ([module respondsToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:module]; BOOL returnValue = NO; [anInvocation getReturnValue:&amp;returnValue]; realReturnValue = returnValue || realReturnValue; } } [anInvocation setReturnValue:&amp;realReturnValue]; } else { for (TDFModule *module in allModules) { if ([module respondsToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:module]; } } }}- (void)doNothing {}@end 先说 -respondsToSelector: ，由于系统内部会调用这个方法，判断是否实现了对应的 UIApplicationDelegate 代理方法，所以这里结合 AppDelegate 以及所有注册的 Module 判断是否有相应实现。 当 -respondsToSelector: 返回 YES 后，程序来到消息转发第二步 Fast forwarding path ，对应方法 -forwardingTargetForSelector:，在这一步，我们判断转发的方法是否为 UIApplicationDelegate 的代理方法，如果不是，并且 realDelegate（也就是 AppDelegate） 能响应，就直接把消息转发给 realDelegate。 如果在上一步中没有把消息转发给 realDelegate，那么就到了消息转发的最后一步 Normal forwarding path ，对应方法 -methodSignatureForSelector: 和 -forwardInvocation:，在这一步我们首先根据协议直接返回代理方法的签名，然后在 -forwardInvocation: 方法中，按照优先级，依次把消息转发给注册的模块。 在不做额外操作的前提下， -forwardInvocation: 中只有最后一次调用的返回值会成为实际返回值，当实现类似 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options 等返回 BOOL 值的代理方法时，就会出现问题。所以这里通过判断返回值是否为 BOOL 类型，去执行不同的操作。如果为 BOOL 类型，则对所有返回值执行逻辑或操作，并将结果设置成实际返回值。 总结起来，流程如下： 经过上面几步，就可以把 App 的事件分发给各个组件了，而且组件对事件的捕获是不依赖于外界（AppDelegate）实现的，只要进行注册就可以了，个人认为还是比较优雅的。","link":"/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/"},{"title":"AsyncDisplayKit","text":"AsyncDisplayKitAsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。具体的代码可以看这里：_ASAsyncTransactionGroup。","link":"/2019/11/12/AsyncDisplayKit/"},{"title":"App瘦身","text":"1 分析当前ipa的组成一般一个ipa会包含： 1） 资源文件 本地文件：数据、配置、数据库等等 字体文件 图片资源 源代码 通过生成linkmap文件，分析源代码生成的编译文件的大小。在Build Settings中Write Link Map File设置为Yes (记住release时候不要设置为Yes)。 编译之后会在build目录中生成两个LinkMap文件： XXX-LinkMap-normal-i386和XXX-LinkMap-normal-x86_64，分别代表在模拟器中32位和64位指令集生成的LinkMap文件。关于LinkMap的文件详细结构解释可以参考：http://blog.cnbang.net/tech/2296/ LinkMap会包含每个可执行文件的偏移量及大小，所以可以很方便的知道每个可执行文件的大小。可以使用LinkMap分析工具：https://github.com/huanxsd/LinkMap 2 资源瘦身无用的图片文件查找无用的图片文件，使用LSUnusedResources（https://github.com/tinymind/LSUnusedResources） 无损压缩图片使用ImageOptim（https://github.com/ImageOptim/ImageOptim）进行png文件的无损压缩 WebP图片压缩WebP是Google提供的一种图片编码格式，通常情况下WebP格式的图片是原始JPG/PNG图片的1/3，所以对于重度依赖图片显示的应用，转换使用WebP可以节省大量的网络传输数据和时间。对于APP瘦身，使用WebP格式可能是一种方式，可以使用WebP格式的图片替代现有的图片资源，可以一定程度的节省空间。 使用WebP转换工具（https://developers.google.com/speed/webp/docs/precompiled）尝试转换了几张较大的图片，效果如下： iOS原生并不支持WebP格式加载，需要引入SDWebImage/WebP，详细可以参考：http://blog.devzeng.com/blog/ios-webp-usage.html 1`NSString *path = [[NSBundle mainBundle] pathForResource:``@&quot;logo&quot;` `ofType:``@&quot;webp&quot;``];``NSData *data = [[NSData alloc] initWithContentsOfFile:path];``UIImage *img = [UIImage sd_imageWithWebPData:data];``self.imageView.image = img;` 使用WebP格式的图片，似乎就抛弃了iOS @2x @3x按照设备加载对应图片的机制，所以应该还可以删除所有@2x图片，不过加载速度比原生较慢。 3 代码瘦身AppCode代码静态检查AppCode提供了非常强大的代码静态检查工具，使用Inspect Code，可以找到很多代码优化的地方。可以参考这篇介绍：AppCode inspections for your code perfection 清除无用代码AppCode搜索出来的无用的Class，会有误报需要仔细检查每一个报错的代码。 使用Fui（https://github.com/dblock/fui）查找发现下列无用文件，同样需要double check避免误删 清除无用的Import Fui（https://github.com/dblock/fui）可以用于查找无用的import，同时也提供[xcfui](https://github.com/jcavar/xcfui) 可以和Xcode集成。 清除无用的Method \\1. 基于AppCode的扫描定期做清理 \\2. 这篇文章提供了一个很好的思路可以一键删除无用方法：http://www.jianshu.com/p/a53480ad0364 查找相似的代码 使用SameCodeFinder (https://github.com/startry/SameCodeFinder)可以查找到相似的代码，最后一位数字代表两个文件的海明距离，数字越小说明两个文件越类似。 清理其他无用的代码 \\1. 已经下线的陈旧代码，AB试验已经下线的代码 \\2. 通过转H5、Hybrid或者RN实现的Native功能，可以定期清理 \\3. 一些非核心Hybrid或者RN模块，可以考虑不要打包进入APP，通过动态下发的方式获取 \\4. 代码的重构，UI组件、业务逻辑的重用等等 4 一些参考文章 iOS可执行文件瘦身：http://blog.cnbang.net/tech/2544/ iOS APP瘦身实践：http://www.jianshu.com/p/c94dedef90b7，资源优化、编译器配置优化、可执行文件优化 滴滴出行iOS端瘦身实践: http://gmtc.geekbang.org/#schedule, 提供了查找无用图片的工具、WebP图片压缩、基于clang plugin实现查找无用代码（https://github.com/kangwang1988/XcodeZombieCode）、查找类似代码（https://github.com/startry/SameCodeFinder） 基于clang插件的一种iOS包大小瘦身方案 减小ipa体积之删除frameWork中无用mach-O文件","link":"/2019/09/02/App%E7%98%A6%E8%BA%AB/"},{"title":"cocoaPods忽略警告","text":"为了减少组件化后的工程集成时间，我们一般都会将三方库放到私有 GitLab 中，这也有利于开发者根据自家业务，对三方库进行定制包装。但是如果有些三方库更新较慢，以至于让新版本的 Xcode 产生很多警告，这就比较烦了，因为大部分情况下，更改三方库并不是一个明智的选择。 Podfile 提供了 inhibit_all_warnings! 以屏蔽所有 pod target 的警告，但其中也包括了非三方组件。同时，Podfile 提供了 inhibit_warnings 去针对单个 pod 的编译警告进行控制，比如： 1pod 'SSZipArchive', :inhibit_warnings =&gt; true 以上代码只会屏蔽 SSZipArchive 组件的警告，这比较符合我们的诉求。不过 inhibit_warnings 只会禁止当前 pod 的警告，并不会一同处理依赖组件的警告，这就要求我们在 Podfile 中显式依赖所有三方组件，并且设置 inhibit_warnings。 12345678910111213141516def add_files_to_build_phases(native_target, test_native_targets) ... flags = compiler_flags_for_consumer(consumer, arc) regular_file_refs = project_file_references_array(files, 'source') native_target.add_file_references(regular_file_refs, flags) ...enddef compiler_flags_for_consumer(consumer, arc) ... if target.inhibit_warnings? flags &lt;&lt; '-w -Xanalyzer -analyzer-disable-all-checks' end flags * ' ' ...end 可以看到，在添加文件至对应 target 时，-w -Xanalyzer -analyzer-disable-all-checks 同时被添加到了文件的 compiler flags （在Target -&gt; Build Phases -&gt; Compile Sources 中可见）。结合 Installer 的 install! 代码： 123456789101112131415161718192021def install! prepare resolve_dependencies download_dependencies validate_targets generate_pods_project if installation_options.integrate_targets? integrate_user_project else UI.section 'Skipping User Project Integration' end perform_post_install_actionsenddef download_dependencies UI.section 'Downloading dependencies' do install_pod_sources run_podfile_pre_install_hooks clean_pod_sources endend generate_pods_project 方法执行了 PodTargetInstaller 的 install! 操作，将文件添加到了 pod target ，那么只能在其之前的 pre_install 设置相关属性了。从上面的代码还可以看出，执行 pre_install 前就已经 resolve_dependencies 了，也就是说我们可以拿到 Analyzer 分析的完整结果 AnalysisResult : 1234567891011121314# @return [Hash{TargetDefinition =&gt; Array&lt;Specification&gt;}] the# specifications grouped by target.#attr_accessor :specs_by_target# @return [Array&lt;Specification&gt;] the specifications of the resolved# version of Pods that should be installed.#attr_accessor :specifications# @return [Array&lt;AggregateTarget&gt;] The aggregate targets created for each# {TargetDefinition} from the {Podfile}.#attr_accessor :targets 上面列出了此次需要涉及到的 AnalysisResult 属性。这里要注意的是 targets 属性是不包含 Pods Target 的，它只包含了 Podfile 里面声明的 target ，一般为组件本身，以及组件Tests。如果不确定要设置哪个 target ，可以手动设置 inhibit_warnings ，然后通过以下代码打印出 hash : 12345678910...pod 'SSZipArchive', :inhibit_warnings =&gt; true...pre_install do |installer| require 'pp' installer.analysis_result.specs_by_target.each_key do |target_definition| pp target_definition.to_hash endend 这里我们对所有涉及到的 target 都进行设置。接着看下 CocoaPods Core 代码中 Podfile 是如何设置 inhibit_warnings 的 : 1234567891011121314151617181920212223242526272829303132def pod(name = nil, *requirements) ... current_target_definition.store_pod(name, *requirements)enddef store_pod(name, *requirements) ... parse_inhibit_warnings(name, requirements) ...enddef parse_inhibit_warnings(name, requirements) ... set_inhibit_warnings_for_pod(pod_name, should_inhibit) ...end# Inhibits warnings for a specific pod during compilation.def set_inhibit_warnings_for_pod(pod_name, should_inhibit) hash_key = case should_inhibit when true 'for_pods' when false 'not_for_pods' when nil return else raise ArgumentError, &quot;Got `#{should_inhibit.inspect}`, should be a boolean&quot; end raw_inhibit_warnings_hash[hash_key] ||= [] raw_inhibit_warnings_hash[hash_key] &lt;&lt; pod_nameend 找到了设置 inhibit_warnings 的 public 方法 set_inhibit_warnings_for_pod。 由于我们的三方库集中放在 cocoapods-repos 的 group 下，最终的 pre_install 长这样 : 1234567891011121314pre_install do |installer| installer.analysis_result.specs_by_target.each_key do |target_definition| installer.analysis_result.specifications.each do |spec| source = spec.attributes_hash['source'] source &amp;&amp;= source['git'] next unless source &amp;&amp; source.include?('cocoapods-repos') targets = (Array(target_definition) + target_definition.children) targets.each do |target| target.set_inhibit_warnings_for_pod(spec.root.name, true) end end endend","link":"/2019/08/30/CocoaPods%E5%BF%BD%E7%95%A5%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A/"},{"title":"CocoaPods组件支持Carthage打包","text":"虽说 CocoaPods 有 cocoapods-packager 这个插件可以生成二进制版本，但这个库的维护者似乎并不活跃，很多 issue 和 pr 过了一两年还堆积着没处理。于是我决定试试 Carthage ，不过不利用 Cartfile 生成依赖，还是用的 CocoaPods 那一套。 要让组件支持 Carthage ，工程里只需要有一个 shared framework target 即可。针对 CocoaPods 生成的工程，我们先在 Podfile 里面设置 use_frameworks! ，来满足 framework target 。 对于剩下的 share 部分，可以用 Add share schemes for development pods 这个 pr 里面的方法解决： 1install! 'cocoapods', :share_schemes_for_development_pods =&gt; false 不过上面的那种方式把所有的 development pods 对应的 target 都 share 了，这里我们可以这样设置特定的 development pods ： 1install! 'cocoapods', :share_schemes_for_development_pods =&gt; ['PodA'] 在 CocoaPods 1.4.0 版本中，share_schemes_for_development_pods 默认是 false 的，所以需要手动在 Podfile 里面去添加这一句。 最后执行一下 pod install ，然后再执行 carthage build --no-skip-current --platform ios 就可以打出 ios 版本的 dynamic framework 了。想利用 Carthage 打出 static framework 的可以查看 Build static frameworks to speed up your app’s launch times。 再进一步，我们可以把这个默认设置写入团队专有的 CocoaPods 插件中，比如 cocoapods-xxx-plugin： 123456789Pod::HooksManager.register('cocoapods-xxx-plugin', :pre_install) do |context, _| first_target_definition = context.podfile.target_definition_list.select{ |d| d.name != 'Pods' }.first development_pod = first_target_definition.name.split('_').first unless first_target_definition.nil? Pod::UI.section(&quot;Auto set share scheme for development pod: \\'#{development_pod}\\'&quot;) do # carthage 需要 shared scheme 构建 framework context.podfile.install!('cocoapods', :share_schemes_for_development_pods =&gt; [development_pod]) end unless development_pod.nil?end 在 Podfile 添加以下代码，让插件生效： 1plugin 'cocoapods-xxx-plugin' 好处就是以后有更多相似配置的话都可以通过更改这个插件解决，而不用每次都去 Podfile 里面改 pre_install。","link":"/2019/12/03/CocoaPods%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81Carthage%E6%89%93%E5%8C%85/"},{"title":"Flutter Tree","text":"我们也可以看到上图中每个控件所形成的树结构中隐含了一些关系，例如在上图中，我们可以说 Text 组件是 Column 组件的子组件，Scaffold 是 AppBar 的父组件，这样的层级关系使得每个控件都清晰的连接到了一起，树结构由此而来（俄罗斯套娃）。 在 Flutter 中，Container、Text 等组件都属于 Widget，所以我们将这种树称为 Widget 树，也可以叫做控件树，它就表示了我们在 dart 代码中所写的控件的结构。 然而，在 Flutter 体系结构中，真正做组件渲染在屏幕上这个任务的并非在 控件层（Widget）层，而是在渲染（Rendering）层，那么我们在代码中所写组件又是怎么通过渲染层显示的呢？Flutter 中又引入了 Element 树和 RenderingObject 树两棵树。 Element 是什么，我们可以把它称之为 Widget 另一种抽象。读者也可以把它看作一个更为实际控件，因为在我们的手机屏幕上显示的控件并非我们在代码中所写的 Widget，我们在代码中所使用的像 Container、Text 等这类组件和其属性只不过是我们想要构建的组件的配置信息，当我们第一次调用 build() 方法想要在屏幕上显示这些组件时，Flutter 会根据这些信息生成该 Widget 控件对应的 Element，同样地，Element 也会被放到相应的 Element 树当中。在 Flutter 中，一个 Widget 通过多次复用可以对应多个 Element 实例，Element 才是我们真正在屏幕上显示的元素。 Element 与 Widget 另一个区别在于，Widget 天然是不可变的（immutable），它如要更新便需要重建，如果想要把可变状态与 Widget 关联起来，可以使用 StatefulWidget，StatefulWidget 通过使用StatefulWidget.createState 方法创建 State 对象，并将之扩充到 Element 以及合并到树中； 这里，为了更为深刻的理解以上描述的含义，我们可以举一个更为形象的例子。Widget 作为大 Boss，他把近期的战略部署，即配置信息，写在纸上下发给经理人 Element，Element 看到详细的配置信息开始真正的开起活来了。我们还需要注意一点，大 Boss 随时会改变战略部署，然后不会在原有的纸上修改而是重新写下来，这时经理人为了减少工作量需要将新的计划与旧的计划比较来作出相应的更新措施。这也是 Flutter 框架层做的一大优化。下面又来了，Element 作为经理人也很体面，当然不会把活全干完，于是又找了一个 RenderObject 的员工来帮它做粗重的累活。 RenderObject 在 Flutter 当中做组件布局渲染的工作，其为了组件间的渲染搭配及布局约束也有对应的 RenderObject 树，我们也称之为渲染树。 熟悉了 Flutter 中的上述三颗树，相信读者会对组件的渲染过程有了一个清晰的认识，这对我们之后学习常用组件有很大的帮助，我们需要用不同的眼光去看待我们所建立的布局和控件，之后我们也会更加深入的去理解其中更不为人知的奥秘。 组件渲染过程简述从上文中，我们知道控件树中的每个控件都会实现一个 RenderObject 对象做渲染任务，并将所有的RenderObject 组成渲染树。Flutter 渲染组件的过程如下： Flutter 的渲染过程由用户的输入开始，当接受到用户输入的信号时，就会触发动画的进度更新，例如我们第一次渲染时的启动动画，或者我们在滚动手机屏幕时单个列表项复用时的移动动画。之后便需要开始视图数据的构建（build），这一步中 Flutter 创建了前文所描述的三棵视图树。 在这之后，视图才会进行布局（layout），计算各个部分的大小，然后进行绘制（paint），生成每个视图的视觉数据，这部分的任务主要就是由 RenderObject 所做。这里，Flutter 中的布局过程可用下图表示，在上述构建完成渲染树后，父渲染对象会将布局约束信息向下传递，子渲染对象根据自己的渲染情况返回 Size，Size 数据会向上传递，最终父渲染对象完成布局过程。 最后一步进行“光栅化”（Rasterize），前一步得到合成的视图数据其实还是一份矢量描述数据，光栅化帮助把这份数据真正地生成一个一个的像素填充数据。在 Flutter 中，光栅化这个步骤被放在了 Engine 层中。 在日常开发学习中，我们只需要在代码层配置好我们的 Widget 树，了解各种 Widget 特性及使用方法，其余的工作都可以交给我们的框架层去实现。 元素树详解我们已经知道了各类控件的作用及其使用方法，这些 Widget 被我们开发人员配置了多个属性来定义它的展现形式，例如配置 Text 组件需要显示的字符串，配置输入框组件需要显示的内容。我们 Element 树会记录这些配置信息。熟悉 React 的读者可能了解过其中的 “虚拟 DOM” 这个概念，上述 Flutter 这种操作也正体现了这一概念。Widget 是不可变，它的改变就意味着要重建，而其重建也非常频繁，如果我们将更多的任务都交给它将会对性能造成很大的损伤，因此我们把 Widget 组件当作一个虚拟的组件树，而真正被渲染在屏幕上的其实是 Elememt 这棵树，它持有其对应 Widget 的引用，如果他对应的 Widget 发生改变，它就会被标记为 dirty Element，于是下一次更新视图时根据这个状态只更新被修改的内容，从而达到提升element-3845797性能的效果。 每次，当控件挂载到控件树上时，Flutter 调用其 createElement() 方法，创建其对应的 Element。Flutter 再将这个 Element 放到元素树上，并持有创建它控件的引用，如下图： 子控件也会创建相应 Element 被放在元素树上： Element 中的状态我们上文提到了 Widget 的不可变性，相应的 Element 就有其可变性，正如我们前文所说的它被标记为 dirty Element 便是作为需要更新的状态，另外一个我们需要格外注意的是，有状态组件（statefulWidget）对应的 State 对象其实也被 Element 所管理，如下图所示。 Flutter 中的 Widget 一直在重建，每次重建之后，Element 都会采用相应的措施来确定是否我对应的新控件跟之前引用旧控件是否有所改变，如果没改变则只需要做更新操作，如果前后不同则会重创建。那么，Element 根据什么来确定控件是否改变呢？它会比较 Widget 以下两个属性： 组件类型 Widget 的 Key （如果有） 组件类型即前后控件的是否是同一个类所创建的，Key 即为每个控件的唯一标识。 渲染树详解我们已经大致知道 Flutter 中的三棵重要的树及 Element 树的工作原理，其中第三棵渲染树的任务就是做组件的具体的布局渲染工作。 渲染树上每个节点都是一个继承自 RenderObject 类的对象，其由 Element 中的 renderObject 或 RenderObjectWidget 中的 createRenderObject 方法生成，该对象内部提供多个属性及方法来帮助框架层中的组件如何布局渲染。 我们在本章之前已经介绍了 StatelessWidget 和 StatefulWidget 两种直接继承自 Widget 的类，在 Flutter 中，还有另一个类 RenderObjectWidget 也同样直接继承自 Widget，它没有 build 方法，可通过 createRenderObject 直接创建 RenderObject 对象放入渲染树中。Column 和 Row 等控件都间接继承自RenderObjectWidget。 主要属性和方法如下： constraints 对象，从其父级传递给它的约束 parentData 对象，其父对象附加有用的信息。 performLayout 方法，计算此渲染对象的布局。 paint 方法，绘制该组件及其子组件。 RenderObject 作为一个抽象类。每个节点需要实现它才能进行实际渲染。扩展 RenderOject 的两个最重要的类是RenderBox 和 RenderSliver。这两个类分别是应用了 Box 协议和 Sliver 协议这两种布局协议的所有渲染对象的父类，其还扩展了数十个和其他几个处理特定场景的类，并实现了渲染过程的细节，如 RenderShiftedBox 和 RenderStack 等等。 布局约束在上面，我们介绍组件渲染流程时，我们了解到了 Flutter 中的控件在屏幕上绘制渲染之前需要先进行布局（layout）操作。其具体可分为两个线性过程：从顶部向下传递约束，从底部向上传递布局信息，其过程可用下图表示。 第一个线性过程用于传递布局约束。父节点给每个子节点传递约束，这些约束是每个子节点在布局阶段必须要遵守的规则。就好像父母告诉自己的孩子 ：“你必须遵守学校的规定，才可以做其他的事”。常见的约束包括规定子节点最大最小宽度或者子节点最大最小的高度。这种约束会向下延伸，子组件也会产生约束传递给自己的孩子，一直到叶子结点。 第二的线性过程用来传递具体的布局信息。子节点接受到来自父节点的约束后，会依据它产生自己具体的布局信息，如父节点规定我的最小宽度是 500 的单位像素，子节点按照这个规则可能定义自己的宽度为 500 个像素，或者低于 500 像素的任何一个值。这样，确定好自己的布局信息之后，将这些信息告诉父节点。父节点也会继续此操作向上传递一直到最顶部。 下面我们具体介绍有哪些具体的布局约束可在树中传递。Flutter 中有两种主要的布局协议：Box 盒子协议和 Sliver 滑动协议。这里我们先以盒子协议为例展开具体的介绍。 在盒子协议中，父节点传递给其子节点的约束为 BoxConstraints。该约束规定了允许每个子节点的最大和最小宽度和高度。如下图，父节点传入 Min Width 为 150，Max Width 为 300 的 BoxConstraints： 当子节点接受到该约束，便可以取得上图中绿色范围内的值，即宽度在 150 到 300 之间，高度大于 100，当取得具体的值之后再将取得具体的大小的值上传给父节点，从而达到父子的布局通信。 自定义一个 Center 控件之后更新，大家也可以看各组件的源码探究其如何应用上面提到的原理。 —2019.07.03 更新 现在，我们可以应用前文中提到的布局约束与渲染树相关的概念自己定义一个类似居中布局的组件 RenderObject 对象渲染在屏幕上。 所以我们称自己自定义组件为 CustomCenter： 12345678910111213141516171819void main() { runApp(MaterialApp( home: Scaffold( body: Container( color: Colors.blue, constraints: BoxConstraints( maxWidth: double.infinity, minWidth: 100.0, maxHeight: double.infinity, minHeight: 100.0), child: CustomCenter( child: Container( color: Colors.red, ), ), ), ), ));} 现在我们来实现我们的 CustomCenter： 123456789class CustomCenter extends SingleChildRenderObjectWidget { Stingy({Widget child}) : super(child: child); @override RenderObject createRenderObject(BuildContext context) { // TODO: implement createRenderObject return RenderCustomCenter(); }} CustomCenter 继承了 SingleChildRenderObjectWidget，表明这个 Widget 只能有一个子控件， 其中，createRenderObject(...) 方法用于真正创建并返回我们的 RenderObject 对象实例， 我们的 RenderObject 为 RenderCustomCenter，代码如下： 1234567891011121314151617181920212223242526272829303132333435class RenderCustomCenter extends RenderShiftedBox { RenderStingy() : super(null); // 重写绘制方法 @override void paint(PaintingContext context, Offset offset) { // TODO: implement paint super.paint(context, offset); } // 重写布局方法 @override void performLayout() { // 布局子元素并向下传递布局约束 child.layout( BoxConstraints( minHeight: 0.0, maxHeight: constraints.minHeight, minWidth: 0.0, maxWidth: constraints.minWidth), parentUsesSize: true); print('constraints: $constraints'); // 指定子元素的偏移位置 final BoxParentData childParentData = child.parentData; childParentData.offset = Offset((constraints.maxWidth - child.size.width)/2, (constraints.maxHeight - child.size.height)/2); print('childParentData: $childParentData'); // 定义自己（CustomCenter）的大小，这里选择约束对象的最大值 size = Size(constraints.maxWidth, constraints.maxHeight); print('size: $size'); }} RenderCustomCenter 继承自 RenderShiftedBox，该类是继承自 RenderBox。RenderShiftedBox 满足盒子协议，并且提供了 performLayout() 方法的实现。我们需要在 performLayout() 方法中布局我们的子元素。?? 我们在使用 child.layout(...) 方法布局 child 的时候传递了两个参数，第一个为 child 的布局约束，而另外一个参数是 parentUserSize， 该参数如果设置为 false，则意味着 parent 不关心 child 选择的大小，这对布局优化比较有用；因为如果 child 改变了自己的大小，parent 就不必重新 layout 了。但是在我们的例子中，我们的需要把 child 放置在 parent 的中心，就是 child 的大小（Size）一旦改变，则其对应的偏移量（Offset） 也会改变，于是 parent 需要重新布局，所以我们这里传递了一个 true。 当 child.layout(...) 完成了以后，child 就确定了自己的 Layout Details。然后我们就还可以为其设置偏移量来将它放置到我们想放的位置。在我们的例子中为 居中。 最后，和 child 根据 parent 传递过来的约束选择了一个尺寸一样，我们也需要为 CustomCenter 选择一个尺寸。 应用视图的构建Flutter App 入口的部分发生于如下代码： 1234import 'package:flutter/material.dart';// 这里的 MyApp是一个 Widgetvoid main() =&gt; runApp(new MyApp()); runApp函数接受一个 Widget类型的对象作为参数，也就是说在 Flutter的概念中，只存在 View，而其他的任何逻辑都只为 View的数据、状态改变服务，不存在 ViewController(或者叫 Activity）。接下来看 runApp做了什么： 12345678910111213void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame();}class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) new WidgetsFlutterBinding(); return WidgetsBinding.instance; }} 在 runApp 中，传入的 widget 被挂载到根 widget 上。这个 WidgetsFlutterBinding 其实是一个单例，通过 mixin 来使用框架中实现的其他 binding 的 Service，比如手势、基础服务、队列、绘图等等。然后会调用 scheduleWarmUpFrame 这个方法，从这个方法注释可知，调用这个方法会主动构建视图数据。这样做的好处是因为 Flutter 依赖 Dart 的 MicroTask 来进行帧数据构建任务的 schedule，这里通过主动调用进行整个周期的 “热身”，这样最近的下次 VSync 信号同步时就有视图数据可提供，而不用等到 MicroTask 的 next Tick。 然后我们再来看 attachRootWidget 这个函数干了什么： 1234567void attachRootWidget(Widget rootWidget) { _renderViewElement = new RenderObjectToWidgetAdapter&lt;RenderBox&gt;( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement);} attachRootWidget 把 widget交给了 RenderObjectToWidgetAdapter这座桥梁，通过这座桥梁，Element 被创建，并且同时能持有 Widget 和 RenderObject的引用。然后我们从上文就知道后面发生的就是第一次的视图数据构建了。","link":"/2020/01/17/Flutter-Tree/"},{"title":"NSBlockOperation","text":"在日常开发中，我们可能会用到 NSBlockOperation 来做一些多线程的操作。 12345NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSBlockOperation *operation = [MyBlockOperation blockOperationWithBlock:^{ // do something}];[queue addOperation:operation]; 因为其使用简单，所以也被广泛使用。 但这个方法也有一个缺点，当 operation 开始执行后，[operation cancel]; 并不能及时取消。 同时，blockOperationWithBlock 没有 operation 的回调参数。有些同学想要通过 operation.isCancelled 进行任务的及时取消，不太清楚应该怎么做，要是使用不当甚至会引入 循环引用 问题。 下面，我们通过几个面试题来一步步了解清楚这个问题。 1.1下面的代码输出什么？ cancelled finish 12345678910111213NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ sleep(2); if (operation.isCancelled) { NSLog(@&quot;cancelled&quot;); } else { NSLog(@&quot;finish&quot;); }}];[queue addOperation:operation];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [operation cancel];}); 答案 finish 分析 初始化时传入了一个 block，block 中含有 operation 对象的访问，即发生了对象的捕获。但是现在是对象的创建过程中，operation 还没有被初始化出来，block这时捕获的是 operation 当前的值，即 operation = nil。 1.2下面的代码输出什么？ cancelled finish 12345678910111213NSOperationQueue *queue = [[NSOperationQueue alloc] init];__block NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ sleep(2); if (operation.isCancelled) { NSLog(@&quot;cancelled&quot;); } else { NSLog(@&quot;finish&quot;); }}];[queue addOperation:operation];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [operation cancel];}); 答案 cancelled 分析 这次加入了 __block 修饰符，捕获变为了指针引用，所以这次 [operation cancel]; 生效了。简单来说就是： 未使用 __block 修饰符，捕获的是当前值。 1234567int i = 0;void(^block)(void) = ^{ i = 1; printf(&quot;%d&quot;, i); // 1};i = 2;block(); 上面这个问题已经有很多文章了，这里不深入说明。 123456NSString *str = @&quot;0&quot;;void(^block)(void) = ^{ NSLog(@&quot;%@&quot;, str); // 0};str = @&quot;1&quot;;block(); 部分同学可能对这个有疑问。其实，两种捕获的原理都是对变量的 “值引用” 进行捕获，捕获的是当前对象的值。之后的修改，不会影响到 block 内部的值。 1.3下面的代码输出什么？ cancelled, -[MyBlockOperation dealloc] 只有 cancelled 12345678910111213141516171819202122@interface MyBlockOperation : NSBlockOperation@end@implementation MyBlockOperation- (void)dealloc { NSLog(@&quot;%s&quot;, __FUNCTION__);}@endNSOperationQueue *queue = [[NSOperationQueue alloc] init];__block MyBlockOperation *operation = [MyBlockOperation blockOperationWithBlock:^{ sleep(2); if (operation.isCancelled) { NSLog(@&quot;cancelled&quot;); } else { NSLog(@&quot;finish&quot;); }}];[queue addOperation:operation];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [operation cancel];}); 答案 只有 cancelled 分析 刚刚分析了 __block 修饰符，捕获变为了指针引用。现在 operation 对象持有 block ，同时 block 通过指针引用捕获了 operation 对象，所以发生了循环引用。 那可能有些同学就要说了，加上 __weak 不就好了？ 1.4下面的代码输出什么？ cancelled, -[MyBlockOperation dealloc] 只有 cancelled 只有 -[MyBlockOperation dealloc] 12345678910111213141516171819202122@interface MyBlockOperation : NSBlockOperation@end@implementation MyBlockOperation- (void)dealloc { NSLog(@&quot;%s&quot;, __FUNCTION__);}@endNSOperationQueue *queue = [[NSOperationQueue alloc] init];__block __weak MyBlockOperation *operation = [MyBlockOperation blockOperationWithBlock:^{ sleep(2); if (operation.isCancelled) { NSLog(@&quot;cancelled&quot;); } else { NSLog(@&quot;finish&quot;); }}];[queue addOperation:operation];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [operation cancel];}); 答案 只有 -[MyBlockOperation dealloc] 这里加入了 __weak 修饰符，对象创建后，发现引用计数为 0 就被释放了，所以 block 不执行。这部分属于内存管理的知识点。 那么我们要怎么做，才能既捕获到 operation 又不会导致循环引用呢？ 1.5下面的代码输出什么？ cancelled, -[MyBlockOperation dealloc] 只有 cancelled 只有 -[MyBlockOperation dealloc] 123456789101112131415NSOperationQueue *queue = [[NSOperationQueue alloc] init];__block __weak MyBlockOperation *wkOp;MyBlockOperation *operation = [MyBlockOperation blockOperationWithBlock:^{ sleep(2); if (wkOp.isCancelled) { NSLog(@&quot;cancelled&quot;); } else { NSLog(@&quot;finish&quot;); }}];wkOp = operation;[queue addOperation:operation];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [operation cancel];}); 答案 cancelled, -[MyBlockOperation dealloc] 分析 为了让 block 访问到初始化之后的值，wkOp 用了 __block 修饰符；同时，为了避免循环引用问题，wkOp 还用了 __weak 修饰符。 operation 初始化后被赋值，这里会有一个隐式的 __strong 修饰，即这里会对 operation 进行强引用，引用计数 +1 。wkOp 为弱引用对象，wkOp = operation; 只是用一个弱引用指针指向 operation ，引用计数不变。与之前不同的是，此时的 operation 的引用计数大于 0，所以不会被立刻释放。 2. 封装为了日常使用方便封装一下就更香了～ 12345678910111213141516171819202122232425262728293031323334353637@interface MyBlockOperation : NSBlockOperation+ (instancetype)blockOperationWithBlock:(void (^)(void))block NS_UNAVAILABLE;+ (instancetype)blockOperationWithOperationBlock:(void (^)(MyBlockOperation *))block;@end@implementation MyBlockOperation- (void)dealloc { NSLog(@&quot;%s&quot;, __FUNCTION__);}+ (instancetype)blockOperationWithOperationBlock:(void (^)(MyBlockOperation *))block;{ __block __weak MyBlockOperation *wkOp; MyBlockOperation *op = [super blockOperationWithBlock:^{ !block ?: block(wkOp); }]; wkOp = op; return op;}@endNSOperationQueue *queue = [[NSOperationQueue alloc] init];MyBlockOperation *operation = [MyBlockOperation blockOperationWithOperationBlock:^(MyBlockOperation *op){ sleep(2); if (op.isCancelled) { NSLog(@&quot;cancelled&quot;); } else { NSLog(@&quot;finish&quot;); }}];[queue addOperation:operation];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [operation cancel];});","link":"/2019/05/16/NSBlockOperation/"},{"title":"GitLab CI","text":"目前团队内部缺少组件发布平台，每次 App 发版都需要组件负责人去发布自己名下涉及的组件。这中间存在组件间依赖以及发布时间差问题，上层组件需要依赖下层组件的发布，负责人之间沟通起来极为耗时。所以团队暂时没有限制私有源仓库的推送权限，当发布时间比较紧时，方便负责人绕过 lint， 直接推送 podspec 到私有源仓库。 虽然这种发布方式能节省一部分时间，但是容易出现下层组件 lint 失败向上层传递的情况。久而久之，lint 不通过的组件将会越来越多。为了尽量避免这种情况的发生，引入 CI 对组件进行 lint 监测是个不错的选择。 以上就是团队当初引入 CI 的初衷。不过 CI 能带来的便利远不止如此，当然，这都是后话了。 GitLab CI 本文使用 GitLab Community Edition 10.4.0 版本 GitLab 在 8.0 版本之后，就集成了 GitLab CI ，随着版本的迭代，其功能越来越强大。使用者只需要在仓库根目录下 （可以通过仓库的 Setting -&gt; CI/CD -&gt; General pipelines settings -&gt; Custom CI config path 设置加载路径，默认根目录）添加 .gitlab-ci.yml 配置文件，并且存在可用的 GitLab Runner ，就可以实现持续集成。 如果在仓库中没有发现 CI/CD 设置项，则需要到 Setting -&gt; CI/CD -&gt; Permissions -&gt; Pipeline 打开设置。 首先需要明确的是和 GitLab CI 任务相关的几个概念： pipeline、stage、job。 pipelinepipeline 实际是一组 stages 中执行 job 的集合，代表着使用者触发的一次构建 。任何提交，包括 MR 在符合配置文件要求的情况下都可以触发 pipeline，其在网页中的体现如下： stagepipeline 中的 jobs 按照构建阶段进行分类，这些分类就是一个个 stage 。如 pipeline 示意图所示，一个 pipeline 中可以定义多个 stage ，比如 build, test, staging, production，其对应配置语法如下： 12345stages: - build - test - staging - production stage 的触发顺序和 stages 字段值定义的顺序一致，并且只有完成当前 stage ， pipeline 才会触发下一个 stage ，如果 stage 失败了，则下一个 stage 将不会被触发，完成所有的 stage 表示此次 pipeline 构建成功。 jobjob 表示 stage 中实际执行的任务。如 pipeline 示意图所示，一个 stage 中可以有多个 job，比如 Test stage 的 test1、test2 job，其对应配置语法如下： 1234567891011121314151617test1: stage: Test script: - xxxx only: - xxxx tags: - xxxx test2: stage: Test script: - xxxx only: - xxxx tags: - xxxx 在有足够 runner （job 执行宿主机） 的情况下，同个 stage 中的 job 是并行的，当 stage 中的所有 job 都执行成功后，该 stage 才算完成，否则视为失败。 GitLab Runner 下文操作基于 macOS 系统 GitLab Runner 和 GitLab 的关系大体如上所示， GitLab Runner 内部会起一个无限循环，根据 check_interval 字段设置的时间间隔，去 GitLab 请求需要执行的任务。更详细的信息可以查看 How shared Runners pick jobs ，How check_interval works。 GitLab Runner 按服务对象可划分 shared runner 和 specific runner ，10.8 版本后还有 group runner，三者应用场景如下： shared runner 主要针对要求配置相似的工程，可以运行不同仓库上的任务。 specific runner 主要针对要求特殊配置的工程，只能运行特定仓库上的任务。 group runner 主要针对某个分组下的所有工程（10.8 及以后版本才有）。 因为团队内部对工程进行了组件化，所以 specific runner 是比较合适的选择，也利于后期向其他业务线推广 CI 。 specific runner 注册需要 shared-runner token ，这个 token 只有 admin 账户可见，一般找 GitLab 的管理人员获取即可。以下为注册成功页（工程页 -&gt; CI / CD -&gt; Runners setting）： 左边为注册的 specific runner ，使用上方显示的 npeoZhFa1nHYvTAsf7f_ token 即可，右边即是注册成功的 shared runner，运行状态为绿色表示正在运行。 接下来看下如何在 macOS 上安装注册 GitLab Runner。 安装 Gitlab Runner In GitLab Runner 10, the name of the executable was renamed from* *gitlab-ci-multi-runner to gitlab-runner 通过 homebrew 安装： 1brew install gitlab-runner 随着 GitLab Runner 10 的发布，其可执行文件已经从 gitlab-ci-multi-runner 更名为 gitlab-runner，如果需要访问旧版本，可以访问这里下载手动安装 。 注册 Gitlab Runner1、注册 runner Currently, the only proven to work mode for macOS is running service in user-mode. 1gitlab-runner register 对应的反向操作： 1234gitlab-runner unregister -u url -t token# url 为下一个步骤输入值# token 可以从网页端或者配置文件中查看 截止到 GitLab Runner 10， MacOS 中已验证可行的运行模式是用户模式，使用系统模式 (sudo) 注册的 Runner 会一直处于 Stuck 状态。 2、输入 GitLab URL 地址 12Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )&gt; GitLab URL 地址 3、输入注册 Runner 需要的 Token 12Please enter the gitlab-ci token for this runner&gt; Token Token 分为 special token 和 shared token，前者在项目设置页可以拿到，后者只能联系 GitLab 管理员或者有 Admin 权限的情况下获得。注册后，会分别成为 special runner 和 shared runner。 4、输入标志 Runner 的 Tags 12Please enter the gitlab-ci tags for this runner (comma separated):iOS,Andriod .gitlab-ci.yml 中可以设置 tags 字段来声明，当前任务只在拥有匹配 Tags 的 Runner 上运行。比如 iOS 编译阶段只能在 Mac Runner 上运行，那么就可以设置这个 Runner 的 Tags 为 ‘iOS’，并且在 iOS 工程中在字段 *tags **中，添加**‘iOS’* 值。 Tags 最好不要随便命名，遵循适当的命名规则会让后期 CI 的维护轻松许多。 5、是否允许运行没有设置 tags 的任务 12Whether to run untagged jobs [true/false]:[false]: false 可以在 GitLab 界面上更改 ，一般为 false。 6、是否锁定当前工程 12Whether to lock Runner to current project [true/false]:[true]: true 在 Runner 是 special 的情况下比较有用，可以在 GitLab 界面上更改。 7、Runner 执行者 12Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shell 一般为 shell。 8、选择 docker 为执行者时，需要设置默认的 docker image 12Please enter the Docker image (eg. ruby:2.1):alpine:latest 非 docker 执行者，没有这一步。 启动/关闭 Gitlab Runner执行以下命令安装 runner 服务，并且启动它： 12gitlab-runner install [--working-directory]gitlab-runner start 关闭操作： 12gitlab-runner stopgitlab-runner uninstall 需要注意的是， 在不加 --working-directory 参数的情况下，runner 工作目录默认为执行 install 命令目录 ，触发了任务后，runner 会在此目录下创建 builds 文件夹 。 更多关于 runner 的命令，可以查看 GitLab Runner Commands 配置GitLab Runner注册后 runner 的配置信息默认保存在 ~/.gitlab-runner/config.toml 文件中，其文件格式如下： 123456789101112131415concurrent = 1check_interval = 0[[runners]] name = &quot;iOS &amp; Android CI Runner on packboy&quot; url = &quot;http://git.2dfire-inc.com/&quot; token = &quot;1ff160dc4d8f9c36e9b138adc4712a&quot; executor = &quot;shell&quot; output_limit = 4096 [runners.cache] [[runners]] name = &quot;xxxx&quot; ... [runners.cache] 文件分为 Global Section 和 [[runners]] Section 两部分，这里只说下常用字段，想要了解更多信息，可以查看 GitLab Runner advanced configuration 。 Global Section 常用部分： Setting Description concurrent 可并发执行的最大任务数，0 不代表无限制 log_level Log 等级 (可选择: debug, info, warn, error, fatal, panic)。优先级比通过命令行 —debug， -l 或 –log-level 设置低 check_interval 设置轮询新任务的周期，单位（秒）。默认值为 3 秒，如果设置为 0 或者比 3 小，此字段使用默认值。 这里需要注意的是， CocoaPods 1.3.0 Release Blog 在 Notable Enhancements 一节指出： Each lint execution now runs in a unique temp folder. This allows for running multiple lint processes in parallel, for example within a CI environment. 也就是说， 在 1.3.0 版本之前，由于共用了承载 lint 操作的文件夹， CocoaPods 并不支持多个组件同时进行 lint。这就需要我们在设置 runner 的 concurrenct 配置时，确认实际使用的 CocoaPods 版本，如果低于 1.3.0 ，concurrenct 必须设置成 1 。 [[runners]] Section 常用部分 Setting Description name runner 名称 url GitLab URL token runner 专有 token (不是注册 runner 时输入的 GitLab token)，unregister 时可以使用 limit 这个 token 下可并发执行的最大任务数，默认 0 ，表示无限制（需要结合上述 CocoaPods 1.3.0 版本以下的限制考虑） builds_dir runner 工作目录，默认会在 install 目录下创建 builds 文件夹 cache_dir cache 保存目录 environment 添加/覆盖环境变量，如 environment = [&quot;ENV=value&quot;, &quot;LC_ALL=en_US.UTF-8&quot;] output_limit 输出 log 大小限制，默认 4096 (4M)，建议设置成 0，不限制大小 pre_clone_script clone 之前执行的脚本，可以用来调整 Git 客户端配置 pre_build_script clone 之后，build 之前执行的脚本 post_build_script build 之后，after_script 之前执行的脚本 clone_url 自定义 clone 仓库的 url 配置 .gitlab-ci.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596before_script: - export LANG=en_US.UTF-8 - export LANGUAGE=en_US:en - export LC_ALL=en_US.UTF-8 - pwd - git clone git@git.2dfire-inc.com:ios/ci-yaml-shell.git - ci-yaml-shell/before_shell_executor.shafter_script: - rm -fr ci-yaml-shellstages: - check - lint - test - package - publish - reportcomponent_check: stage: check script: - ci-yaml-shell/component_check_executor.rb only: - master - /^release.*$/ - tags - CI tags: - iOS lib_lint: stage: lint only: - master - /^release.*$/ - CI retry: 2 script: - ci-yaml-shell/lib_lint_executor.sh tags: - iOS oc_lint: stage: lint only: - master - CI retry: 2 script: - ci-yaml-shell/oclint_executor.sh lint_result after_script: - cat lint_result | python -m json.tool tags: - iOS unit_test: stage: test only: - master - CI retry: 2 script: - ci-yaml-shell/unit_test_executor.sh tags: - iOS package_framework: stage: package only: - tags script: - ci-yaml-shell/framework_pack_executor.sh tags: - iOS publish_pod: stage: publish only: - tags retry: 2 script: - ci-yaml-shell/publish_executor.sh tags: - iOS report_to_director: stage: report script: - ci-yaml-shell/report_executor.sh only: - master - tags when: on_failure tags: - iOS 以上是团队目前采用的 .gitlab-ci.yml 配置，涉及的关键字在官方文档 Configuration of your jobs with .gitlab-ci.yml 有非常详细的介绍，这里不做赘述，只说下这样配置的几点考虑。 1、所有 stage 脚本，都保存在 ci-yaml-shell 仓库中，在执行 global before_script 时下载（通过 ssh ，不受 GitLab CI 权限影响）。这是因为工程在组件化后会产生非常多的仓库 ，这样做有利于 CI 脚本的统一修改和管理，只要在每个仓库的 .gitlab-ci.yml 配置中预留足够多的入口即可，后期修改调试比较方便。比如需要新增 xcpretty 依赖，只需在 before_shell_executor.sh 脚本中添加 gem install xcpretty --no-ri --no-rdoc 即可辐射到所有组件。 2、考虑到组件集成 CI 时，最好能创建相应的调试分支，我们在 check、test、lint 三个 stage 的 only 字段中都添加了 CI 分支。由于在调试阶段，此分支的 CI 执行结果并且不会推送至钉钉。package 和 publish 已经是 CD 阶段了，所以只在提交 tags 时触发。 3、团队采用 GitFlow 工作流 （在组件较多的情况下，维护 master 和 develop 两个相似分支的工作量比较大，后期会考虑优化工作流，比如采用 GitLab Flow，或者自定义 GitHub Flow），在提交 MR （release -&gt; master） 时需要触发 CI ，当 CI 成功后方可合并，所以在 component_check 和 lib_lint 两个 job 的 only 字段中都添加了 /^release.*$/ 正则。 4、report stage 负责在 CI 执行失败后，推送钉钉消息 @ 相应的负责人和触发者，这块思路可以参照 编写自己的 CocoaPods 插件，后期我也重构并优化了这块代码。 publish stage 在发布组件成功后，同样会推送钉钉消息。 5、stage 的失败条件是任务最后一个执行的命令返回非零结果 ($?)，所以在编写 shell 脚本的时候需要注意，如果有 shell 命令执行抛错了，要提前 exit ： 12345# framework_pack_executor.sh...ruby $(dirname &quot;$0&quot;)/validate_specification.rb || { exit 1; }... 否则即使 shell 脚本中间有某些命令执行失败，但最后一个命令执行成功，stage 最终结果也会是成功的。如果是 ruby 脚本，比如上方配置的 component_check 任务 ，就可以规避这个问题，直接 raise 即可。 6、由于所有配置都在 ci-yaml-shell 仓库中，会导致安装的 gem 依赖都是一致的，如果其他业务线使用不同版本的CocoaPods ，可能会导致 CI 报错。所以组件仓库可以添加自己的 Gemfile ，定制 gem 依赖，脚本会对这种情况进行兼容 ： 123456789# publish_executor.sh...if [[ -f &quot;Gemfile&quot; ]]; then bundle install bundle exec pod binary publish --verboseelse pod $(pod_gem_version) binary publish --verbosefi... 7、component_check 这个入口主要对组件进行一些简单快速的校验，比如我们针对目前团队组件中存在的一些问题，设置的 podspec 校验： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# validate_specification.rbrequire 'cocoapods'spec_file = Pathname.glob('*.podspec').firstraise &quot;can`t find specfile at #{Dir.pwd}&quot; if spec_file.nil?spec = Pod::Specification.from_file(spec_file)Pod::UI.section('校验依赖限制') do none_requirement_dependencies = spec.dependencies.select do |dep| dep.requirement.none? end fire_source = Pod::Config.instance.sources_manager.all.select do |s| s.url.downcase.include?('2dfire') end.first if none_requirement_dependencies.any? version_hash = {} none_requirement_dependencies.each do |dep| versions = fire_source.versions(dep.root_name) next if versions.nil? newest_version = versions.sort.last version_hash[dep.root_name] = &quot;#{newest_version.major}.#{newest_version.minor}&quot; end old_require = none_requirement_dependencies.map { |dep| &quot;s.dependency '#{dep.name}'&quot; }.join(&quot;\\n&quot;) new_require = none_requirement_dependencies.map { |dep| &quot;s.dependency '#{dep.name}', '~&gt; #{version_hash[dep.root_name]}'&quot; }.join(&quot;\\n&quot;) err_message = &quot;podspec 依赖需要设置限制，将：\\n#{old_require} \\n依赖更换为：\\n#{new_require}&quot; Pod::UI.puts err_message.red raise err_message endendPod::UI.section('校验版本层级标识') do COMPONENTS_LABELS = %w[ basic weakbusiness business ].freeze labels = COMPONENTS_LABELS.select do |l| spec.summary.start_with?(l) end if labels.empty? err_message = &quot;podspec 需要在 summary 字段中，为组件添加层级标识。分为以下层级 #{COMPONENTS_LABELS}，如:\\ns.summary = '#{COMPONENTS_LABELS.first} #{spec.summary}'&quot; Pod::UI.puts err_message.red raise err_message endendPod::UI.section('校验业务线私有组件包含关系') do SPECIFiC_BUSSINESS_LINE_PODS = %w[ TDFLoginAssistant TDFBossBaseInfoDefaults ].freeze specific_pods = spec.dependencies.select do |dep| SPECIFiC_BUSSINESS_LINE_PODS.include?(dep.root_name) end if specific_pods.any? err_message = &quot;podspec 中不能包含业务线特殊组件/调试组件 #{specific_pods.map(&amp;:name).join(', ')}&quot; Pod::UI.puts err_message.red raise err_message endendPod::UI.section('校验 pch 文件引用') do if spec.prefix_header_file err_message = &quot;podspec 不能设置 pch 属性，删除 prefix_header_file 的设置，调整头文件引用&quot; Pod::UI.puts err_message.red raise err_message endend 这些校验自动监测了组件规范，可以减少一些组件的人工维护成本。 以下分别是 master、tags、release 分支触发 CI 后的 pipeline 截图： master 和 tags 触发的 CI 会将执行结果推送至钉钉，release 分支推送比较频繁，所以只执行了两个必须的 stage，减少 runner 资源的占用。由于 master 是线上分支，必须进行最严格的检查，而 tags 主要是进行 CD 操作，为了加快组件的发布，省略了一些检测任务。为了更加清晰地展示所有组件的 CI 执行结果，可以利用 cocoapods gem 获取私有源的所有组件，并将 pipeline badge 展示在网页上： 在开发中，可能会遇到不想触发 CI 情况，这时只需要让 commit 信息包含 [ci skip] 或者 [skip ci] （不分大小写）即可。 提示汇总编码错误搭建 CI 时，发现只有 shared runner 会因为编码问题而执行失败，special runner 仅仅报了 warning。 根据 CI: How to set UTF-8 in the server? 和 xcpretty US-ASCII encoding problems 上的解答，可以在 before_script 下添加以下配置： 123- - export LANG=en_US.UTF-8- export LANGUAGE=en_US:en- export LC_ALL=en_US.UTF-8 unit test 出现 Scheme is not currently configured for the test action这个问题分为必现和概现两种情况，先说必现的情况。 执行单测时，需要在对应 scheme 下添加 test targets： 一般 Xcode 会在创建工程时，默认添加这些配置。如果发现此栏没有问题， CI 的单测还是提示 action 错误，那就要排查下是否是 .gitignore 引起的问题了。 在我们点击 Edit Scheme / Manager Schemes 后，会发现每个 scheme 都会有个 shared 选项，勾选了之后，就会在 *.xcodeproj/xcshareddata/xcschemes 目录下生成相关文件，里面存储了可以在版本控制系统共享的项目配置。 在没有勾选时，项目配置都保存在 *.xcodeproj/xcuserdata 目录下，一般针对 iOS 工程的 .gitignore 都会包含以下条目： 1xcuserdata/ 这就导致即使本地正确地设置了 scheme ，可以正常运行单测 ，远程 runner 执行相应操作时，还是获取不到正确的配置。所以要添加单测的组件， scheme 这栏一定要勾选 shared 。 接下来说下概现的情况。 先看下的 pod lib create 获取老 pod-template 工程所暴露的问题 ：pod lib create generates a project that randomly crashes when running tests 简单来说，就是有两个 scheme 重名了 （工程 scheme，及 pod 生成的组件 scheme）， xcodebuild 无法找到正确的 scheme 执行单测。 事实上，手动创建的工程也会存在这个问题，其工程结构和老 pod-template 相似。 要规避这两种情况，最简单的方法就是使用 pod lib create 拉取新的 pod-template，将旧工程直接挪过去。我们也可以根据自己的需求，创建私有 pod-template，然后通过指定 --template-url 获取。 Pipeline Job 卡在 Cloning repository…，Runner 宿主机提示输入 Keychain 密码登录 runner 的宿主机后，可以看到提示如下： runner 默认通过 http / https 对代码进行 clone / fetch ，在没有配置用户名密码，或配置错误时，就会出现如上提示。输入密码后，一段时间内可以正常下载代码，过了有效时间，又会弹出上方提示框。 参照 Git-工具-凭证存储，我们使用 store 模式来处理凭证信息（这里更推荐使用 osxkeychain 模式，可以参照 disable git credential-osxkeychain ），创建 .gitconfig 如下： 12345[credential] helper = store --file $HOME/.git-credentials[user] name = gitlab-runner email = xxxx --file 是 store 模式用来自定义存放密码的文件路径（默认是~/.git-credentials）。.git-credentials 文件内容格式如下： 123https://用户名:密码@GitHost# 如 http://gitlab-ci-token:a8mzWa7FKb1Wzbf9MQeS@git.2dfire-inc.com 设置完后，可以使用 git config --list 查看配置信息，注意 helper 的先后顺序会影响最终执行结果。 如果有需要用到 ssh 的情况，可以参考 Using SSH keys with GitLab CI/CD，How do I enable cloning over SSH for a Gitlab runner? xcodebuild 编译时无法找到对应模拟器的 OS 版本xcodebuild 编译时需要指定 -destination 参数，在有多台 runner 的情况下，模拟器对应的 OS 版本是未知的，所以不能在脚本中写死，可以通过以下方式统一使用 iPhoneX ： 123456build_destination(){ devices=$(instruments -s devices) os=$(echo ${devices##*iPhone X} | grep -Eo '[0-9]+[.][0-9]+') destination=&quot;platform=iOS Simulator,name=iPhone X,OS=$os&quot; echo $destination} 兼容 -Example schemexcodebuild 编译时需要指定 -scheme 参数，pod lib create 创建的工程 scheme 名称都以 -Example 结尾，手动创建的工程则一般和文件夹名一致，可以通过以下脚本获取 scheme 的名称： 12345678910111213infors = `xcodebuild -list`.split(&quot;\\n&quot;).map(&amp;:strip)scheme = nilflag = falseinfors.each do |i| flag = true if i == 'Schemes:' if flag &amp;&amp; i.end_with?('Example') scheme = i endendputs scheme 参考GitLab CI/CD Variables GitLab Continuous Integration Configuring GitLab Runners Configuration of your jobs with .gitlab-ci.yml Install GitLab Runner on macOS Introduction to pipelines and jobs A Ruby wrapper and CLI for the GitLab API GitLab Runner advanced configuration Git 工具 - 凭证存储","link":"/2019/03/26/GitLab-CI/"},{"title":"OC接入swift","text":"一、设置桥接文件不管是objective-c调用swift，还是swift调用objective-c，都需要创建桥接文件，通过桥接文件实现两者的相互调用。当我们引入oc或者swift进入另一个语言的项目的时候系统会提示是否自动创建桥接文件，此时可直接创建。但除此之外我们也可以选择手动创建。此时需要我们在新建文件里选择Header File，点击确认创建桥接文件，桥接文件名字一般为：ProjectName-Bridging-Header.h。然后在Build settings里搜索bridging，找到Objective-C Bridging Header的选项，将该文件的路径填写进去，或者直接拉入。这里的路径最好选择相对路径的形式（ProjectName/BridgingFileName.h）。ProjectName为你项目的项目名，BridgingFileName为桥接文件的名字。 二、桥接方法oc项目调用swift文件oc项目针对swift文件会自动创建ProjectName-Swift.h文件，该文件不需要我们去做更改，所以当我们设置完桥接文件之后，只需要在要调用的文件处import该头文件即可，即：import &lt;ProjectName-Swift.h&gt;，其中ProjectName为该项目的工程名。引入该头文件后，即可调用Swift对应的类和方法。 注意点：引入的swift文件需要调用的类和方法需要进行修饰，然后oc项目才能调用。可使用@objcMembers直接修饰类，或者也可以使用@objc分别修饰想要调用给oc的方法和属性，然后oc项目就可调用swift的相关方法了。 swift项目调用oc文件swift项目调用oc文件更为简单，只需要将oc类的头文件导入桥接文件即可，需要调用哪个oc文件就import哪个头文件（#import “ClassName.h”）进去。swift项目调用oc的类和方法不需要引入头文件，所以设置完之后可以直接在swift中直接调用oc方法。 OC调用Swift简单说下OC调用Swift需要注意的点： 1.import $(SWIFT_MODULE_NAME)-Swift.h 1#import &quot;OCAndSwift-Swift.h&quot; 2.调用Swift类时，Swift类必须继承自NSObject 1class SwiftClass: NSObject { var claseName = &quot;SwiftClass&quot;} 3.调用Swift类的方法，属性时，Swift类的方法属性都必须加上@objc关键字 1@objc var retrainConfirmBlock: (() -&gt; Void)?@objc convenience init() 4.如果使用KVC，KVO等监听，需要对监听的属性加上dynamic关键字，因为Swift并不是动态派发的语言，dynamic关键字会让编译器进行动态分发而不是静态分发. 1@objc dynamic var orderNumber: NSNumber? Swift调用OCSwift调用OC需要注意的点： 1.$(SWIFT_MODULE_NAME)-Bridging-Header.h引入OC类头文件. 2.OC类的相关属性及方法在Swift类中都可以直接调用，只需要注意Swift语法即可. 1UIView.animate(withDuration: TimeInterval(time), delay: 0, options: UIView.AnimationOptions.curveLinear, animations: {// animate }) {(finish) in//finish} 3.OC类的多数基本类型如NSArray，NSDictionay，NSError等对象(Object) 都可以通过 as? 和Swift中的基础类型Array，Dictionary，Error等值类型互换. 1let contentAry = info[&quot;content&quot;] as? [String]titleLabel.text = title as? String ?? &quot;&quot;if let failedWith = error as? Error {} 4.OC宏的使用，Swift使用OC的宏，只能直接使用非常简单的值类型宏，对于复杂的宏方法则需要自己重写一个全局方法替代，全局静态常量可以直接使用. 12#define kExpireTime 60 // √#define sharedAppDelegate ((AppDelegate *)([UIApplication sharedApplication].delegate)) // X Swift特性Optional1.简单介绍一下Optional-可选类型，Optional实际上是一个枚举类型： 1public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral {case nonecase some(Wrapped)...} 表示一个数据可能有值也可能为空即nil，类型可以用Optional或者T?（常用）表示. 2.如果一个可选类型有值，那么这个值也是被包装起来的，例如optional(“test”)，如果需要取出值就需要解包 解包方式有 if let 以及！，！表示强解，一般在确定值不为空的时候使用，否则会造成崩溃. 12if let text = OptionalText {print(text)}let text = OptionalText! 3.在与OC混编过程中，因为OC没有可选类型的概念，需要注意可选类型带来的问题.例如 12@objc init(offset: CGFloat? = nil, text: String? = &quot;&quot;) {super.init(frame: .zero)self.type = typeself.offset = offset} 这个方法如果想给OC调用则会报错 1Method cannot be marked @objc because the type of the parameter 1 cannot be represented in Objective-C 提示第一个参数无法用OC表示，因为在OC中CGFloat是值类型，不能为nil，而对于OC中的对象类型NSString （String自动转换）则可以接受. 另外，Swift使用OC定义类型时也要注意是否为可空类型 12@property (nonatomic, strong) NSNumber *number1;@property (nonatomic, strong, nullable) NSNumber *number2; 带nullable关键字的属性可以被Swift转为可选类型，但是不带nullable的属性则默认被！强解，这里需要注意使用OC网络数据等，如果不做判断可以会导致崩溃. 泛型泛型是Swift中的一大利器，许多swift的标准库都是通过泛型代码构建的，例如数组和字典都是泛型集，在系统库或者一些知名三方库中，随处可见的Element，，Where等等占位符或关键字，都是使用泛型在构建代码，引用一段Swift文档对于泛型的描述. Generic code enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner. Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. In fact, you’ve been using generics throughout the Language Guide, even if you didn’t realize it. For example, Swift’s Array and Dictionary types are both generic collections. You can create an array that holds Int values, or an array that holds String values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be. 概括泛型的关键字：自定义，任意类型，灵活，重用，清晰，抽象.篇幅关系，Swift泛型的应用以后再详细总结. 在Xcode7之后，为了“迎合”Swift，苹果对OC也做了许多提升，其中包括Nullability，轻量级泛型和__kindof等等，nullable上文我们提到过，可以在Swift使用OC属性时自动编译为Optional类型，那么在在泛型的混编上应该注意什么呢？ 1.OC种泛型的使用在OC当中对泛型比较常用的方式，例如对数组元素类型的定义 1NSArray&lt;NSString *&gt; *messageArray 一方面可以限制集合类型，一方面可以直接使用点语法，并且在添加，遍历时会有类型提示. 2.OC泛型的定义OC中2种自定义泛型定义： 1__covariant:协变, 子类转父类 __contravariant:逆变 父类转子类 那么什么是协变，逆变呢，我们用一个例子来说明 1@interface Generic&lt;ObjectType&gt; : NSObject@end@interface ViewController ()@property (nonatomic, strong) Generic * generic;@property (nonatomic, strong) Generic&lt;NSString*&gt; * stringGeneric;@property (nonatomic, strong) Generic&lt;NSMutableString*&gt; * mutableGeneric;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; self.generic = self.stringGeneric; self.generic = self.mutableGeneric; self.stringGeneric = self.generic; self.stringGeneric = self.mutableGeneric; // Incompatible pointer types assigning to 'Generic&lt;NSString*&gt; *' from 'Generic&lt;NSMutableString*&gt; *' self.mutableGeneric = self.generic; self.mutableGeneric = self.stringGeneric; // Incompatible pointer types assigning to 'Generic&lt;NSMutableString*&gt; *' from 'Generic&lt;NSString*&gt; *'}@end 从代码警告我们可以看出： 不指定泛型类型的对象generic可以和任意泛型类型对象转换. 指定了泛型类型的对象generic不能和不同泛型类型对象转换(只是警告). 如果你需要主动控制转换关系则需要添加 __covariant 或 __contravariant，效果如下： 12@interface Generic&lt;__covariant ObjectType&gt; : NSObjectself.stringGeneric = self.mutableGeneric; // 子类转父类self.mutableGeneric = self.stringGeneric; // Incompatible pointer types assigning to 'Generic&lt;NSMutableString*&gt; *' from 'Generic&lt;NSString*&gt; *'@interface Generic&lt;__contravariant ObjectType&gt; : NSObjectself.stringGeneric = self.mutableGeneric; // Incompatible pointer types assigning to 'Generic&lt;NSString*&gt; *' from 'Generic&lt;NSMutableString*&gt; *'self.mutableGeneric = self.stringGeneric; // 父类转子类 3.OC泛型在Swift中的使用1.OC中定义的泛型，在Swift中使用时，必须指定泛型类型 1let g = Generic&lt;AnyObject&gt;() 2.使用泛型类型的子类时，如果想要使用父类的方法或属性，建议先使用as转换类型，获取到方法列表或属性列表后，再把as去掉，因为子类无法直接获取到父类的方法属性列表，有点坑. 1let gChild = GenericChild&lt;AnyObject&gt;()(gChild as GenericChild&lt;AnyObject&gt;).genericFunc()gChild.genericFunc() 3.swift并不吃OC泛型的协变，逆变这一套，它只有一个基本原则：类型固定.只要你在初始化时说明了对象的泛型类型，那么他不管怎么转换类型，指针赋值，始终只能转换为他自己的类型. 123let gString = Generic&lt;NSString&gt;()var gMutableString = Generic&lt;NSMutableString&gt;()gMutableString = gString as! Generic&lt;NSMutableString&gt; 4.Swift泛型在OC中的使用不行（可以查看一下$(SWIFT_MODULE_NAME)-Swift.h中是没有将Swift泛型类编译成OC类的哦）. closure1.OC中的blcok与Swift中closure都是经常使用的代码类型，Swift调用OC block会自动转化为closure类型. 12void (^completionBlock)(NSData *, NSError *) = ^(NSData *data,NSError *error) {/* ... */}let completionBlock: (NSData, NSError) -&gt; Void = {data, errorin /* ... */} 2.Swift中closure和function是同一种类型，所以可以将Swift的方法名作为block参数传递给OC. 12let completionBlock: (NSData, NSError) -&gt; Void = {data, error in /* ... */}func completionBlockFunc(_ data:NSData, _ error:NSError) -&gt; Void { /* ... */ } 3.block默认截获变量，如果需要截获引用，则需要加上__block关键字，closure默认截获变量的指针，也就是说closure默认就添加了__block关键字，但是在变量没有改变的情况下，closure会做优化只持有变量的值而不是指针. As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure. 4.循环引用及Weak-Strong Dance OC中未避免循环引用，会对持有对象做weak处理，Swift中修饰对象为弱引用有2种方式. 1234567// 对此对象进行弱引用，此对象引用计数不会增加，修饰的对象为可选类型weak var object// 对此对象进行弱引用，此对象引用计数不会增加，修饰的对象不能为nilunowned var objectself.closure = { [unowned self] in // self 不能为空，否则会造成崩溃 self.viewDidLoad() }self.closure = { [weak self] in // self 是可选类型，此处可以解包self self?.viewDidLoad()} EnumOC中NS_ENUM枚举定义和Swift中的Enum默认是相互转化的，但是秉着简洁清晰的代码原则，Swift把OC中枚举类型名称给yan割了，例如 1typedef NS_ENUM(NSInteger, UITableViewCellStyle) { UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle}; 等价于 1enum UITableViewCellStyle: Int { case Default case Value1 case Value2 case Subtitle} Swift用点语法来使用枚举：（许多系统的枚举类也被改了，如果不知道怎么写，可以把OC的系统枚举写上，会有错误提示帮你更正） 1let cellStyle: UITableViewCellStyle = .Default Swift中的枚举比起OC来强大了很多，OC中的枚举只能定义类型，但是Swift中的枚举可以添加方法和属性，类似于Struct，可以实现很多自定义的功能. 1enum NDDErrCode: Int, CustomStringConvertible { case success = 0 case fail case noData case noMoreData var description: String { switch self { case .success: return &quot;成功&quot; case .fail: return &quot;失败&quot; case .noData: return &quot;没有数据&quot; case .noMoreData: return &quot;没有更多数据&quot; } }} 其他问题ProtocolOC中Protocol更倾向于代理功能，由Protocol协议，代理对象delegate以及委托者组成，主要用于事件回调，页面传值等功能； Swift中的Protocol更多的是面向协议编程，指抽象出不同类的相同行为（方法），特点（属性）等等，实现模块化解耦.还可以通过extension，实现协议的默认方法（OC不行），也无需生命代理对象等. Swift调用OC的Protocol和调用方法一样，OC调用Swift协议时，需要注意创建Protocol时，@objc，optional等关键字和协议类型（any，class，anyObject）等协议遵循限制. RAC and RxSwiftSwift可以使用RAC（不建议，毕竟有正宫娘娘RxSwift），除了语法外，需要注意RAC大部分类也是OC泛型，需要类型转换以获取父子类方法及属性列表. OC无法使用RxSwift. 单例OC单例 1+ (instancetype)sharedInstance { static Singleton *shared = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ shared = [[Singleton alloc] init]; }); return _shared;} Swift单例 1static let sharedInstance = Singleton() json转模型OC中常用json转对象工具MJExtension，Swift中常用工具较多，如HandyJson，ObjectMapper等等，另外Swift4引入的Codable协议也是非常方便的. OC变参方法OC的变参方法无法直接在Swift中被调用，需要对变参方法进行修改，使用va_list对变参进行拼接. 原方法 1+ (void)stringParams:(NSString *)params,...; 重写方法 1+ (void) stringParams:(NSString *)params args:(va_list)args { va_list args_copy; __va_copy(args_copy,args); NSMutableString* format = [NSMutableString stringWithString:@&quot;&quot;]; while (va_arg(args, NSString*)) { [format appendString:@&quot;%@,&quot;]; } va_end(args); if(format.length&gt;0) [format deleteCharactersInRange:NSMakeRange(format.length-1,1)]; NSString* newFormat = [NSString stringWithFormat:@&quot;%@&quot;,format]; NSString * result = [[NSString alloc]initWithFormat:newFormat arguments:args_copy]; va_end(args_copy); NSLog(@&quot;%@&quot;, result);} swift调用 1let args: [CVarArg] = [&quot;i'm&quot;, &quot; funny&quot;] withVaList(args) { (pointer: CVaListPointer) in return ViewController.stringParams(&quot;%@,%@&quot;, args: pointer) }","link":"/2020/03/04/OC%E6%8E%A5%E5%85%A5swift/"},{"title":"Q-Learning-2","text":"算法更新 整个算法乍看起来很复杂, 不过我们拆分一下, 就变简单了. 也就是个 Q learning 主框架上加了些装饰. 这些装饰包括: 记忆库 (用于重复学习) 神经网络计算 Q 值 暂时冻结 q_target 参数 (切断相关性) ##代码模式 首先我们先 import 两个模块, maze_env 是我们的环境模块,maze_env 模块我们可以不深入研究, 如果你对编辑环境感兴趣, 可以去看看如何使用 python 自带的简单 GUI 模块 tkinter 来编写虚拟环境. maze_env 就是用 tkinter 编写的. 而 RL_brain 这个模块是 RL 的大脑部分, 我们下节会讲. 12from maze_env import Mazefrom RL_brain import QLearningTable 下面的代码, 我们可以根据上面的图片中的算法对应起来, 这就是整个 Qlearning 最重要的迭代更新部分啦. 1234567891011121314151617181920212223242526272829303132333435363738def update(): # 学习 100 回合 for episode in range(100): # 初始化 state 的观测值 observation = env.reset() while True: # 更新可视化环境 env.render() # RL 大脑根据 state 的观测值挑选 action action = RL.choose_action(str(observation)) # 探索者在环境中实施这个 action, 并得到环境返回的下一个 state 观测值, reward 和 done (是否是掉下地狱或者升上天堂) observation_, reward, done = env.step(action) # RL 从这个序列 (state, action, reward, state_) 中学习 RL.learn(str(observation), action, reward, str(observation_)) # 将下一个 state 的值传到下一次循环 observation = observation_ # 如果掉下地狱或者升上天堂, 这回合就结束了 if done: break # 结束游戏并关闭窗口 print('game over') env.destroy()if __name__ == &quot;__main__&quot;: # 定义环境 env 和 RL 方式 env = Maze() RL = QLearningTable(actions=list(range(env.n_actions))) # 开始可视化环境 env env.after(100, update) env.mainloop() 代码主结构与上回不一样的地方是, 我们将要以一个 class 形式定义 Q learning, 并把这种 tabular q learning 方法叫做 QLearningTable. 123456789101112class QLearningTable: # 初始化 def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): # 选行为 def choose_action(self, observation): # 学习更新参数 def learn(self, s, a, r, s_): # 检测 state 是否存在 def check_state_exist(self, state): 预设值1234567891011import numpy as npimport pandas as pdclass QLearningTable: def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): self.actions = actions # a list self.lr = learning_rate # 学习率 self.gamma = reward_decay # 奖励衰减 self.epsilon = e_greedy # 贪婪度 self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64) # 初始 q_table 决定行为这里是定义如何根据所在的 state, 或者是在这个 state 上的 观测值 (observation) 来决策. 1234567891011121314def choose_action(self, observation): self.check_state_exist(observation) # 检测本 state 是否在 q_table 中存在(见后面标题内容) # 选择 action if np.random.uniform() &lt; self.epsilon: # 选择 Q value 最高的 action state_action = self.q_table.loc[observation, :] # 同一个 state, 可能会有多个相同的 Q action value, 所以我们乱序一下 action = np.random.choice(state_action[state_action == np.max(state_action)].index) else: # 随机选择 action action = np.random.choice(self.actions) return action 学习我们根据是否是 terminal state (回合终止符) 来判断应该如何更行 q_table. 更新的方式是不是很熟悉呢: update = self.lr * (q_target - q_predict) 这可以理解成神经网络中的更新方式, 学习率 * (真实值 - 预测值). 将判断误差传递回去, 有着和神经网络更新的异曲同工之处. 12345678def learn(self, s, a, r, s_): self.check_state_exist(s_) # 检测 q_table 中是否存在 s_ (见后面标题内容) q_predict = self.q_table.loc[s, a] if s_ != 'terminal': q_target = r + self.gamma * self.q_table.loc[s_, :].max() # 下个 state 不是 终止符 else: q_target = r # 下个 state 是终止符 self.q_table.loc[s, a] += self.lr * (q_target - q_predict) # 更新对应的 state-action 值 检测 state 是否存在这个功能就是检测 q_table 中有没有当前 state 的步骤了, 如果还没有当前 state, 那我我们就插入一组全 0 数据, 当做这个 state 的所有 action 初始 values. 12345678910def check_state_exist(self, state): if state not in self.q_table.index: # append new state to q table self.q_table = self.q_table.append( pd.Series( [0]*len(self.actions), index=self.q_table.columns, name=state, ) )","link":"/2019/04/01/Q-Learning-2/"},{"title":"Q-Learning-1","text":"###Q-Learning 整体算法 Q learning 的算法, 每次更新我们都用到了 Q 现实和 Q 估计, 而且 Q learning 的迷人之处就是 在 Q(s1, a2) 现实 中, 也包含了一个 Q(s2) 的最大估计值, 将对下一步的衰减的最大估计和当前所得到的奖励当成这一步的现实, 很奇妙吧. 最后我们来说说这套算法中一些参数的意义. Epsilon greedy 是用在决策上的一种策略, 比如 epsilon = 0.9 时, 就说明有90% 的情况我会按照 Q 表的最优值选择行为, 10% 的时间使用随机选行为. alpha是学习率, 来决定这次的误差有多少是要被学习的, alpha是一个小于1 的数. gamma 是对未来 reward 的衰减值. 我们可以这样想象. Q-Learning 更新 Q-Learning Gamma 例子:12-o---T# T 就是宝藏的位置, o 是探索者的位置 Q-learning 是一种记录行为值 (Q value) 的方法, 每种在一定状态的行为都会有一个值 Q(s, a), 就是说 行为 a 在 s 状态的值是 Q(s, a). s 在上面的探索者游戏中, 就是 o 所在的地点了. 而每一个地点探索者都能做出两个行为 left/right, 这就是探索者的所有可行的 a 啦. 如果在某个地点 s1, 探索者计算了他能有的两个行为, a1/a2=left/right, 计算结果是 Q(s1, a1) &gt; Q(s1, a2), 那么探索者就会选择 left 这个行为. 这就是 Q learning 的行为选择简单规则. 预设值这一次需要的模块和参数设置: 1234567891011import numpy as npimport pandas as pdimport timeN_STATES = 6 # 1维世界的宽度ACTIONS = ['left', 'right'] # 探索者的可用动作EPSILON = 0.9 # 贪婪度 greedyALPHA = 0.1 # 学习率GAMMA = 0.9 # 奖励递减值MAX_EPISODES = 13 # 最大回合数FRESH_TIME = 0.3 # 移动间隔时间 Q 表对于 tabular Q learning, 我们必须将所有的 Q values (行为值) 放在 q_table 中, 更新 q_table 也是在更新他的行为准则. q_table 的 index 是所有对应的 state (探索者位置), columns 是对应的 action (探索者行为). 1234567891011121314151617def build_q_table(n_states, actions): table = pd.DataFrame( np.zeros((n_states, len(actions))), # q_table 全 0 初始 columns=actions, # columns 对应的是行为名称 ) return table# q_table:&quot;&quot;&quot; left right0 0.0 0.01 0.0 0.02 0.0 0.03 0.0 0.04 0.0 0.05 0.0 0.0&quot;&quot;&quot; 定义动作接着定义探索者是如何挑选行为的. 这是我们引入 epsilon greedy 的概念. 因为在初始阶段, 随机的探索环境, 往往比固定的行为模式要好, 所以这也是累积经验的阶段, 我们希望探索者不会那么贪婪(greedy). 所以 EPSILON 就是用来控制贪婪程度的值. EPSILON 可以随着探索时间不断提升(越来越贪婪), 不过在这个例子中, 我们就固定成 EPSILON = 0.9, 90% 的时间是选择最优策略, 10% 的时间来探索. 12345678# 在某个 state 地点, 选择行为def choose_action(state, q_table): state_actions = q_table.iloc[state, :] # 选出这个 state 的所有 action 值 if (np.random.uniform() &gt; EPSILON) or (state_actions.all() == 0): # 非贪婪 or 或者这个 state 还没有探索过 action_name = np.random.choice(ACTIONS) else: action_name = state_actions.argmax() # 贪婪模式 return action_name 环境反馈 S_, R做出行为后, 环境也要给我们的行为一个反馈, 反馈出下个 state (S_) 和 在上个 state (S) 做出 action (A) 所得到的 reward (R). 这里定义的规则就是, 只有当 o 移动到了 T, 探索者才会得到唯一的一个奖励, 奖励值 R=1, 其他情况都没有奖励. 12345678910111213141516def get_env_feedback(S, A): # This is how agent will interact with the environment if A == 'right': # move right if S == N_STATES - 2: # terminate S_ = 'terminal' R = 1 else: S_ = S + 1 R = 0 else: # move left R = 0 if S == 0: S_ = S # reach the wall else: S_ = S - 1 return S_, R 环境更新接下来就是环境的更新了, 不用细看. 12345678910111213def update_env(S, episode, step_counter): # This is how environment be updated env_list = ['-']*(N_STATES-1) + ['T'] # '---------T' our environment if S == 'terminal': interaction = 'Episode %s: total_steps = %s' % (episode+1, step_counter) print('\\r{}'.format(interaction), end='') time.sleep(2) print('\\r ', end='') else: env_list[S] = 'o' interaction = ''.join(env_list) print('\\r{}'.format(interaction), end='') time.sleep(FRESH_TIME) 强化学习主循环最重要的地方就在这里. 你定义的 RL 方法都在这里体现. 在之后的教程中, 我们会更加详细得讲解 RL 中的各种方法, 下面的内容, 大家大概看看就行, 这节内容不用仔细研究. 12345678910111213141516171819202122232425def rl(): q_table = build_q_table(N_STATES, ACTIONS) # 初始 q table for episode in range(MAX_EPISODES): # 回合 step_counter = 0 S = 0 # 回合初始位置 is_terminated = False # 是否回合结束 update_env(S, episode, step_counter) # 环境更新 while not is_terminated: A = choose_action(S, q_table) # 选行为 S_, R = get_env_feedback(S, A) # 实施行为并得到环境的反馈 q_predict = q_table.loc[S, A] # 估算的(状态-行为)值 if S_ != 'terminal': q_target = R + GAMMA * q_table.iloc[S_, :].max() # 实际的(状态-行为)值 (回合没结束) else: q_target = R # 实际的(状态-行为)值 (回合结束) is_terminated = True # terminate this episode q_table.loc[S, A] += ALPHA * (q_target - q_predict) # q_table 更新 S = S_ # 探索者移动到下一个 state update_env(S, episode, step_counter+1) # 环境更新 step_counter += 1 return q_table 写好所有的评估和更新准则后, 我们就能开始训练了, 把探索者丢到环境中, 让它自己去玩吧. 1234if __name__ == &quot;__main__&quot;: q_table = rl() print('\\r\\nQ-table:\\n') print(q_table)","link":"/2019/03/29/Q-Learning/"},{"title":"Sarsa算法","text":"Sarsa 更新行为准则 同样, 我们会经历正在写作业的状态 s1, 然后再挑选一个带来最大潜在奖励的动作 a2, 这样我们就到达了 继续写作业状态 s2, 而在这一步, 如果你用的是 Q learning, 你会观看一下在 s2 上选取哪一个动作会带来最大的奖励, 但是在真正要做决定时, 却不一定会选取到那个带来最大奖励的动作, Q-learning 在这一步只是估计了一下接下来的动作值. 而 Sarsa 是实践派, 他说到做到, 在 s2 这一步估算的动作也是接下来要做的动作. 所以 Q(s1, a2) 现实的计算值, 我们也会稍稍改动, 去掉maxQ, 取而代之的是在 s2 上我们实实在在选取的 a2 的 Q 值. 最后像 Q learning 一样, 求出现实和估计的差距 并更新 Q 表里的 Q(s1, a2). 对比 Sarsa 和 Q-learning 算法 从算法来看, 这就是他们两最大的不同之处了. 因为 Sarsa 是说到做到型, 所以我们也叫他 on-policy, 在线学习, 学着自己在做的事情. 而 Q learning 是说到但并不一定做到, 所以它也叫作 Off-policy, 离线学习. 而因为有了 maxQ, Q-learning 也是一个特别勇敢的算法. 为什么说他勇敢呢, 因为 Q learning 机器人 永远都会选择最近的一条通往成功的道路, 不管这条路会有多危险. 而 Sarsa 则是相当保守, 他会选择离危险远远的, 拿到宝藏是次要的, 保住自己的小命才是王道. 这就是使用 Sarsa 方法的不同之处. 算法 整个算法还是一直不断更新 Q table 里的值, 然后再根据新的值来判断要在某个 state 采取怎样的 action. 不过于 Qlearning 不同之处: 他在当前 state 已经想好了 state 对应的 action, 而且想好了 下一个 state_ 和下一个 action_ (Qlearning 还没有想好下一个 action_) 更新 Q(s,a) 的时候基于的是下一个 Q(s_, a_) (Qlearning 是基于 maxQ(s_)) 这种不同之处使得 Sarsa 相对于 Qlearning, 更加的胆小. 因为 Qlearning 永远都是想着 maxQ 最大化, 因为这个 maxQ 而变得贪婪, 不考虑其他非 maxQ 的结果. 我们可以理解成 Qlearning 是一种贪婪, 大胆, 勇敢的算法, 对于错误, 死亡并不在乎. 而 Sarsa 是一种保守的算法, 他在乎每一步决策, 对于错误和死亡比较铭感. 这一点我们会在可视化的部分看出他们的不同. 两种算法都有他们的好处, 比如在实际中, 你比较在乎机器的损害, 用一种保守的算法, 在训练时就能减少损坏的次数. 算法的代码形式首先我们先 import 两个模块, maze_env 是我们的环境模块, 已经编写好了, maze_env 模块，我们可以不深入研究, 如果你对编辑环境感兴趣, 可以去看看如何使用 python 自带的简单 GUI 模块 tkinter 来编写虚拟环境.maze_env 就是用 tkinter 编写的. 而 RL_brain 这个模块是 RL 的大脑部分, 我们下节会讲. 12from maze_env import Mazefrom RL_brain import SarsaTable 下面的代码, 我们可以根据上面的图片中的算法对应起来, 这就是整个 Sarsa 最重要的迭代更新部分啦. 123456789101112131415161718192021222324252627282930313233343536373839def update(): for episode in range(100): # 初始化环境 observation = env.reset() # Sarsa 根据 state 观测选择行为 action = RL.choose_action(str(observation)) while True: # 刷新环境 env.render() # 在环境中采取行为, 获得下一个 state_ (obervation_), reward, 和是否终止 observation_, reward, done = env.step(action) # 根据下一个 state (obervation_) 选取下一个 action_ action_ = RL.choose_action(str(observation_)) # 从 (s, a, r, s, a) 中学习, 更新 Q_tabel 的参数 ==&gt; Sarsa RL.learn(str(observation), action, reward, str(observation_), action_) # 将下一个当成下一步的 state (observation) and action observation = observation_ action = action_ # 终止时跳出循环 if done: break # 大循环完毕 print('game over') env.destroy()if __name__ == &quot;__main__&quot;: env = Maze() RL = SarsaTable(actions=list(range(env.n_actions))) env.after(100, update) env.mainloop() 代码主结构和之前定义 Qlearning 中的 QLearningTable 一样, 因为使用 tabular 方式的 Sarsa 和 Qlearning 的相似度极高, 123456789101112class SarsaTable: # 初始化 (与之前一样) def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): # 选行为 (与之前一样) def choose_action(self, observation): # 学习更新参数 (有改变) def learn(self, s, a, r, s_): # 检测 state 是否存在 (与之前一样) def check_state_exist(self, state): 我们甚至可以定义一个 主class RL, 然后将 QLearningTable 和 SarsaTable 作为 主class RL 的衍生, 这个主 RL 可以这样定义. 所以我们将之前的 __init__, check_state_exist, choose_action, learn 全部都放在这个主结构中, 之后根据不同的算法更改对应的内容就好了. 所以还没弄懂这些功能的朋友们, 请回到之前的教程再看一遍. 12345678910111213141516import numpy as npimport pandas as pdclass RL(object): def __init__(self, action_space, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): ... # 和 QLearningTable 中的代码一样 def check_state_exist(self, state): ... # 和 QLearningTable 中的代码一样 def choose_action(self, observation): ... # 和 QLearningTable 中的代码一样 def learn(self, *args): pass # 每种的都有点不同, 所以用 pass 如果是这样定义父类的 RL class, 通过继承关系, 那之子类 QLearningTable class 就能简化成这样: 123456789101112class QLearningTable(RL): # 继承了父类 RL def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): super(QLearningTable, self).__init__(actions, learning_rate, reward_decay, e_greedy) # 表示继承关系 def learn(self, s, a, r, s_): # learn 的方法在每种类型中有不一样, 需重新定义 self.check_state_exist(s_) q_predict = self.q_table.loc[s, a] if s_ != 'terminal': q_target = r + self.gamma * self.q_table.loc[s_, :].max() else: q_target = r self.q_table.loc[s, a] += self.lr * (q_target - q_predict) 学习有了父类的 RL, 我们这次的编写就很简单, 只需要编写 SarsaTable 中 learn 这个功能就完成了. 因为其他功能都和父类是一样的. 这就是我们所有的 SarsaTable 于父类 RL 不同之处的代码. 是不是很简单. 12345678910111213class SarsaTable(RL): # 继承 RL class def __init__(self, actions, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9): super(SarsaTable, self).__init__(actions, learning_rate, reward_decay, e_greedy) # 表示继承关系 def learn(self, s, a, r, s_, a_): self.check_state_exist(s_) q_predict = self.q_table.loc[s, a] if s_ != 'terminal': q_target = r + self.gamma * self.q_table.loc[s_, a_] # q_target 基于选好的 a_ 而不是 Q(s_) 的最大值 else: q_target = r # 如果 s_ 是终止符 self.q_table.loc[s, a] += self.lr * (q_target - q_predict) # 更新 q_table","link":"/2019/04/01/Sarsa%E7%AE%97%E6%B3%95/"},{"title":"app启动时间优化","text":"《Optimizing App Startup Time》议题上，提到了启动分为冷启动和暖启动两种。 常规的优化方式，还包括像动态库懒加载、TTI 任务调度、后台启动、防劣化等。 暖启动：是指内存中包含 App 的相关数据，与我们日常提到的热启动不太一样，连续杀掉 App 的启动也可能是暖启动。 冷启动：是指系统的内核缓存区里没有 App 相关数据。冷暖启动的启动时间会差异比较大，冷启动的数据更能反映 App 真实的启动时长。保证 App 是冷启动的方法，就是通过重启设备，清理系统内核缓存区。 常见的 iOS 启动时长测试方法，主要有以下几种 Xcode Developer Tool： 使用 Instruments 的 Time Profiler 插件，可以检测 App CPU 的使用情况。能看到 App 的启动时间和各个方法消耗的时间； 客户端计算统计： 通过 hook 关键函数的调用，计算获得性能数据。 ![image-20230227114633430](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227114633430.png) App总启动流程 = pre-main (+load,initializer)+ main函数代理（didFinishLaunchingWithOptions）+ 首屏渲染（viewDidAppear），后两个阶段都属于 main函数 执行阶段。 ![image-20210310151027524](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210310151027524.png) ![image-20211114154156099](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20211114154156099.png) main前 加载可执行文件（App的.o文件集合） 加载动态链接库（系统和应用的动态链接库），进行rebase指针调整和bind符号绑定 Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查 初始化，包括执行+load()、attribute(constructor)修饰的函数的调用、创建C++静态全局变量 main后 首页初始化所需要配置文件的读写操作 首页界面渲染 12345678910Total pre-main time: 977.95 milliseconds (100.0%) dylib loading time: 433.20 milliseconds (44.2%) rebase/binding time: 97.24 milliseconds (9.9%) ObjC setup time: 50.13 milliseconds (5.1%) initializer time: 397.36 milliseconds (40.6%) slowest intializers : libSystem.B.dylib : 11.48 milliseconds (1.1%) AgoraRtcKit : 105.87 milliseconds (10.8%) Hestia : 415.46 milliseconds (42.4%) main函数代理阶段1、手动插入代码计算耗时 在 man() 函数开始执行时就开始时间： 1234567CFAbsoluteTime StartTime; // 记录全局变量int main(int argc, char * argv[]) { @autoreleasepool { StartTime = CFAbsoluteTimeGetCurrent(); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 无侵入首屏渲染完成时间我们希望和 MetricKit 对齐，即获取到 CA::Transaction::commit()方法被调用的时间。 CA::Transaction::commit()，CFRunLoopPerformBlock，kCFRunLoopBeforeTimers 这三个时机的顺序从早到晚依次是： ![image-20210311113820158](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210311113820158.png) 可以通过在 didFinishLaunch 中向 Runloop 注册 block 或者 BeforeTimer 的 Observer 来获取上图中两个时间点的回调，代码如下： 123456789101112131415161718192021222324if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 13.0) { //注册kCFRunLoopBeforeTimers回调 CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop]; CFRunLoopActivity activities = kCFRunLoopAllActivities; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, activities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { if (activity == kCFRunLoopBeforeTimers) { NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970]; NSLog(@&quot;runloop beforetimers launch end:%f&quot;,stamp); CFRunLoopRemoveObserver(mainRunloop, observer, kCFRunLoopCommonModes); [HSALaunchManage initLaunchService]; } }); CFRunLoopAddObserver(mainRunloop, observer, kCFRunLoopCommonModes); } else { // 注册block CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop]; CFRunLoopPerformBlock(mainRunloop,NSDefaultRunLoopMode,^(){ NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970]; NSLog(@&quot;runloop block launch end:%f&quot;,stamp); [HSALaunchManage initLaunchService]; }); } iOS13（含）以上的系统采用 runloop 中注册一个 kCFRunLoopBeforeTimers 的回调获取到的 App 首屏渲染完成的时机更准确。 iOS13 以下的系统采用 CFRunLoopPerformBlock 方法注入 block 获取到的 App 首屏渲染完成的时机更准确。 启动时间统计:main()函数启动时间MianStartTime:1617002963.711972 1617002963.862700 首屏结束时间：runloop beforetimers launch end:1617002965.720096 Total pre-main time: 797.23 milliseconds 首屏时间-Mianstart 5.72-3.7119=2.0081 秒 总时间：2.0081+0.977=2.9851 秒 对于 main() 调用之前的耗时可以优化的点有 1、减少不必要的 framework，因为动态链接比较耗时 2、check framework 应当设为 optional 和 required，如果该 framework 在当前 App 支持的所有 iOS 系统版本都存在，那么就设为 required，否则就设为 optional，因为 optional 会有些额外的检查 3、合并或者删减一些 OC 类，关于清理项目中没用到的类 4、删减没有被调用到或者已经废弃的方法 5、将不必须在 + load 方法中做的事情延迟到 + initialize 中或者放延迟到首屏渲染之后，通过监听启动完成后的一个通知，再执行原来的一些耗时逻辑，从而将耗时逻辑尽可能的延后，尽量使用异步处理。 6、高频次方法有些方法的单个耗时不高，但是在启动路径上会调用很多次的，这种累计起来的耗时也不低，比如读 Info.plist 里面的配置： (NSString *)plistChannel{return [[[NSBundle mainBundle] infoDictionary] objectForKey:@”CHANNEL_NAME”];} 修改的方式很简单，加一层内存缓存即可，这种问题在 TimeProfiler 里时间段选长一些往往就能看出来。 2、APP Launch 检测![image-20210312173338839](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210312173338839.png) ![image-20210413111434697](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210413111434697.png) ![image-20210623152404407](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210623152404407.png) ![image-20210623155929385](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210623155929385.png) ![image-20210623154833028](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210623154833028.png) 一、阿里云sdk初始化二、flutter初始化[FlutterBoostPlugin.sharedInstance startFlutterWithPlatform:[RTFlutterRouter shareFlutterRouter] onStart:^(FlutterEngine *engine) {}]; 把flutter初始化延后至首屏渲染之后 三、其他+load方法1、[self configProgressView]; [[FRWLocalizableManager sharedInstance] localizabledImageNamed:imgName inBundle:bundle] 先从缓存取，缓存没有从本地取，然后把图片写入缓存，80ms，已没有用移除。 2、[HVSRCLiveChatRoomUtils initializeRongCloudIM]; 11ms 3、[FRRWebEngine startEngine]; 59ms 实现一个类，负责首屏渲染之后处理初始化 12345678+(void)initLaunchService { //flutter [FlutterBoostPlugin.sharedInstance startFlutterWithPlatform:[RTFlutterRouter shareFlutterRouter] onStart:^(FlutterEngine *engine) {}]; //融云 [HVSRCLiveChatRoomUtils initializeRongCloudIM]; //webView [FRRWebEngine startEngine];} 四、移除部分无用代码和类其他： 之前直觉的就把第三方的初始化放到了 didFinishLaunchingWithOptions 方法里，我专门建了一个类来负责启动事件，区分开可以放在首屏显示之后再初始化的第三方库，以后再引入的时候就会判断一下。 12345/*** 这个类负责所有原来didFinishLaunchingWithOptions和+load中 延迟事件的加载，根据需要减少 didFinishLaunchingWithOptions 里耗时的操作.* 第一类: 比如日志 / 统计等需要第一时间启动的, 仍然放在 didFinishLaunchingWithOptions 中.* 第二类: 部分第三方库的启动、数据处理等业务，不需要放在didFinishLaunchingWithOptions中，延后至首屏显示之后*/ 图片启动难免会用到很多图，有没有办法优化图片加载的耗时呢？用 Asset 管理图片而不是直接放在 bundle 里。Asset 会在编译期做优化，让加载的时候更快，此外在 Asset 中加载图片是要比 Bundle 快的，因为 UIImage imageNamed 要遍历 Bundle 才能找到图。加载 Asset 中图的耗时主要在在第一次张图，因为要建立索引，可以通过把启动的图放到一个小的 Asset 里来减少这部分耗时。 每次创建 UIImage 都需要 IO，在首帧渲染的时候会解码。所以可以通过提前子线程预加载（创建 UIImage）来优化这部分耗时。 有的启动只有到了比较晚的阶段“RootWindow 创建”和“首帧渲染”才会用到图片，所以可以在启动的早期开预加载的子线程启动任务。 二进制重排既然启动的路径上会触发大量的 Page In，那么有没有什么办法优化呢？ 启动具有局部性特征，即只有少部分函数在启动的时候用到，这些函数在中的分布是零散的，所以 Page In 读入的数据利用率并不高。如果我们可以把启动用到的函数排列到二进制的连续区间，那么就可以减少 Page In 的次数，从而优化启动时间： 以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。 链接器 ld 有个参数-order_file 支持按照符号的方式排列二进制。获取启动时候用到的符号主流有两种方式： 静态扫描获取 +load 和 C++静态初始化，hook objc_msgSend 获取 Objective C 符号。 LLVM 函数插桩，灰度统计启动路径符号，用大多数用户的符号生成 order_file。 Facebook 的 LLVM 函数插桩是针对 order_file 定制，并且代码也是他们自己给 LLVM 开发的，目前已经合并到 LLVM 主分支了。 ![image-20210506165105863](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210506165105863.png) Facebook 的方案更精细化，生成的 order_file 是最优解，但是工程量很大。抖音的方案不需要源码编译，不需要对现有编译环境和流程改造，侵入性最小，缺点就是只能覆盖 90%左右的符号。 - 灰度是任何优化都要利用好的一个阶段，因为很多新的优化方案存在不确定性，需要先在灰度上验证。 非常规方案其他启动时间统计工具、启动方法耗时检测工具、二进制重排、动态库懒加载 动态库懒加载最开始我们提到可以通过删代码的方式来减少代码量，那么有没有什么不减少代码总量，就可以减少启动时候要加载代码数量的方式呢？ 答案就是动态库懒加载。 什么是懒加载的动态库呢？正常动态库都是会被主二进制直接或者间接链接的，那么这些动态库会在启动的时候加载。如果只打包进 App，不参与链接，那么启动的时候就不会自动加载，在运行时需要用到动态库里面的内容的时候，再手动懒加载。 懒加载动态库需要在编译期和运行时都进行改造，编译期的架构： 像 A.framework 等动态库是懒加载的，因为并没有参与主二进制的直接 or 间接链接。动态库之间一定会有一些共同的依赖，把这些依赖打包成 Shared.framework 解决公共依赖的问题。 运行时通过-[NSBundle load]来加载，本质上调用的是底层的 dlopen。那么什么时候触发动态库手动加载呢？ 动态库可以分成两种：业务和功能。业务就是 UI 的入口，可以把动态库加载的逻辑收敛到路由内部，这样外部其实并不知道动态库是懒加载的，也能更好地容错。功能库（比如上图的 QR.framework）会有些不一样，因为没有 UI 等入口，需要功能库自己维护 Wrapper： App 对 Wrapper 直接依赖，这样外部并不知道这个动态库是懒加载的 Wrapper 内部封装了动态调用逻辑，动态调用指的是通过 dlsym 等方式调用 动态库懒加载除了启动加载的代码减少，还能长期防止业务增加代码引起启动劣化，因为业务的初始化在第一次访问的时候完成的。 这个方案还有其他优点，比如动态库化后本地编译时间会大幅度降低，对其他性能指标也有好处，缺点是会牺牲一定程度的包大小，但可以用段压缩等方式优化懒加载的动态库来打平这部分损耗。 Background FetchBackground Fetch 可以隔一段时间把 App 在后台启动，对于时间敏感的 App（比如新闻）可以在后台刷新数据，这样能够提高 Feed 加载的速度，进而提升用户体验。 那么，这种类似“后台保活”的机制，为什么能提高启动速度呢？我们来看一个典型的 case： 系统在后台启动 App 时间长因为内存等原因，后台的 App 被 kill 了 这时候用户立刻启动 App，那么这次启动就是一次热启动，因为缓存还在 又一次系统在后台启动 App 这次用户在 App 在后台的时候点了 App，那么这次启动就是一次后台回前台，因为 App 仍然活着 通过这两个典型的场景，可以看出来为什么 Background Fetch 能提高启动速度了： 提高热启动在冷启动的占比 后台启动回前台被定义为启动，因为用户的角度来说这就是一次启动 后台启动有一些要注意的点，比如日活，广告，甚至是 AB 进组逻辑都会受影响，需要做不少适配。往往需要启动器来支撑，因为正常启动在 didFinishLaunch 执行的任务，在后台启动的时候需要延迟到第一次回前台的时候再执行。 资料： 1、去除没有用到的资源： https://github.com/tinymind/LSUnusedResources 2、利用AppCode：https://www.jetbrains.com/objc/ 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code 3、可借助第三方工具解析LinkMap文件： https://github.com/huanxsd/LinkMap 生成LinkMap文件，可以查看可执行文件的具体组成","link":"/2020/03/21/app%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"},{"title":"Runloop","text":"概述 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分： 控制线程的生命周期【线程保活】 解决NSTimer在滑动过程中停止工作的问题及衍生问题 监控应用卡顿 性能优化 一、线程保活线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且让子线程一直存活着,为了避免来回多次创建毁线程的动作, 降低性能消耗. 情景1123456789101112131415161718192021222324252627282930313233343536#import &lt;Foundation/Foundation.h&gt;//定义继承自NSThread线程@interface ZXYThread : NSThread@end@implementation ZXYThread//线程销毁会被调用- (void)dealloc{ NSLog(@&quot;%s&quot;, __func__);}@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; self.thread = [[ZXYThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [self.thread start];}- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];}// 子线程需要执行的任务- (void)test{ NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);}- (void)run { NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); NSLog(@&quot;%s ----end----&quot;, __func__);}@end 当执行完上面的代码后,会发现打印出如下-[子线程也就销毁了] 但是运行完App,当点击App时没有反应,也可以证明此线程已经销毁.如果改进让线程处于随时接受命令的状态呢? 情景2从Runloop中得知,如果Mode里没有任何的Source0/Source1/Timer/Observer, Runloop会立马退出. 所以会想到能不能向其中加入上面中的一个是否可以如下: [run 方法中] 123456789// 这个方法的目的：线程保活- (void)run { NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); // 往RunLoop里面添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];// [[NSRunLoop currentRunLoop] addTimer:[[NSTimer alloc]init] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;%s ----end----&quot;, __func__);} 通过在run方法中加入上面代码,让线程一直不死,打印屏幕界面: 好像上面已经满足了要求,达到了线程不死的状态,但是能不能在销毁页面控制器的时候,也销毁定时器,并且随时停掉定时器. 情景3知识点: 如何停止runloop?通过CFRunLoopStop(CFRunLoopGetCurrent())方法可停掉定时器,但是对于用[[NSRunLoop currentRunLoop] run]的Runloop是不会停掉的,因为通过CFRunLoopStop(CFRunLoopGetCurrent())方法仅仅是停掉了本次的Runloop,而不是停掉所有的,但是[[NSRunLoop currentRunLoop] run]的run方法是一直有runloop循环,所以通过[[NSRunLoop currentRunLoop] run]方法是不可能被停掉runloop的 那应该改成什么样的? —-[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; 下面直接用代码来解释,里面已经写明了代码思路,下面是A页面-&gt;B页面-&gt;A页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@interface ViewController ()//继承自NSThead的子线程@property (strong, nonatomic) ZXYThread *thread;//有个暂停定时器的需求,stopped代表是否点击了暂停@property (assign, nonatomic, getter=isStoped) BOOL stopped;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; //NSThread使用block的方法,消除循环引用 __weak typeof(self) weakSelf = self; self.stopped = NO; self.thread = [[ZXYThread alloc] initWithBlock:^{ NSLog(@&quot;%@----begin----&quot;, [NSThread currentThread]); // 往RunLoop里面添加Source\\Timer\\Observer [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; while (weakSelf &amp;&amp; !weakSelf.isStoped) { [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; } NSLog(@&quot;%@----end----&quot;, [NSThread currentThread]); }]; [self.thread start];}- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ if (!self.thread) return; [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];}// 子线程需要执行的任务- (void)test{ NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);}- (void) stop { if (!self.thread) return; // 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走） [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];}// 用于停止子线程的RunLoop- (void)stopThread{ // 设置标记为YES self.stopped = YES; // 停止RunLoop CFRunLoopStop(CFRunLoopGetCurrent()); NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]); // 清空线程 self.thread = nil;}- (void)dealloc{ NSLog(@&quot;%s&quot;, __func__); [self stop];}@end 如果想将上面的代码抽取出来应该怎么办呢? 情景4此处封装工具类并不是直接继承自NSThread,而是继承自NSObject[因为并不想让别人直接能调用NSThread里面的方法.]这样符合开闭原则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#import &lt;Foundation/Foundation.h&gt;typedef void (^ZXYPermenantThreadTask)(void);@interface ZXYPermenantThread : NSObject/** 在当前子线程执行一个任务 */- (void)executeTask:(ZXYPermenantThreadTask)task;/** 结束线程 */- (void)stop;@end#import &quot;ZXYPermenantThread.h&quot;/** ZXYThread **/@interface ZXYThread : NSThread@end@implementation ZXYThread- (void)dealloc{ NSLog(@&quot;%s&quot;, __func__);}@end/** ZXYPermenantThread **/@interface ZXYPermenantThread()@property (strong, nonatomic) ZXYThread *innerThread;@property (assign, nonatomic, getter=isStopped) BOOL stopped;@end@implementation ZXYPermenantThread#pragma mark - public methods- (instancetype)init{ if (self = [super init]) { self.stopped = NO; __weak typeof(self) weakSelf = self; self.innerThread = [[ZXYThread alloc] initWithBlock:^{ [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode]; while (weakSelf &amp;&amp; !weakSelf.isStopped) { [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; } }]; [self.innerThread start]; } return self;}- (void)executeTask:(ZXYPermenantThreadTask)task{ if (!self.innerThread || !task) return; [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];}- (void)stop{ if (!self.innerThread) return; [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];}- (void)dealloc{ NSLog(@&quot;%s&quot;, __func__); [self stop];}#pragma mark - private methods- (void)__stop{ self.stopped = YES; CFRunLoopStop(CFRunLoopGetCurrent()); self.innerThread = nil;}- (void)__executeTask:(ZXYPermenantThreadTask)task{ task();}@end 上面是针对Runloop在实际开发中的第一个使用场景,那么我们是否在一些好的开源项目中使用过呢或者是看到过呢? 拓展[AFNetworking也使用到了Runloop的线程保活] AFNetworking中的ANURLConnectionOperation是基于NSURLConnection构建,本质是希望能在后台线程接收到Delegate回调.为此AFNetworking单独创建了一个线程, 并在这个线程中开启了一个Runloop: 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }}+ (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} Runloop启动前必须要至少一个Timer/Observer/Source,所以AFNetworking在[runLoop run] 之前创建了NSMachPort添加进去了.通常情况下调用者需要持有这个NSMachPort并在外部线程通过这个port发送消息到loop内 12345678910- (void)start { [self.lock lock]; if ([self isCancelled]) { [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } else if ([self isReady]) { self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } [self.lock unlock];} 当需要这个后台线程执行任务时,AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中 二、NSTimer问题在日常开发中,列表经常会用到NSTimer倒计时问题,或者Interview的时候被面试官问到: NSTimer准时嘛等问题?今天就展开讲述一下原因及方案,最后讲述衍生出来的问题循环引用!争取彻底解决NSTimer带来的疑问? 问题一、 NSTimer定时器不准原因 NSTimer被添加在mainRunloop中,模式是NSDefaultRunLoopMode, mainRunloop负责所有的主线程事件,例如UI界面的操作,负责的运算使当前Runloop持续的时间超过了定时器的间隔时间,那么下一次定时就被延后,这样就造成timer的阻塞 模式的切换,当创建的timer被加入到NSDefaultRunLoopMode时,此时如果有滑动UIScrollView的操作时,runloop的mode会切换为TrackingRunloopMode,这时tiemr会停止回调 解决方案 Mode方式的改变,兼顾TrackingRunloopMode 在子线程中创建timer,在主线程进行定时任务的操作或者在子线程中创建timer,在子线程中进行定时任务的操作,需要UI的操作时再切换到主线程进行操作 GCD操作: dispatch_source_create以及depatch_resume等方法 方案一 主线程的Runloop使用到的主要有两种模式, NSDefaultRunLoopMode与TrackingRunloopMode模式 添加定时器到主线程的CommonMode中 1[[NSRunLoop mainRunLoop]addTimer:timer forMode:NSRunLoopCommonModes]; 方案二 子线程创建timer,主线程执行定时或者子线程创建timer,在子线程执行定时,需要刷新再到主线程 子线程启动NSTimer 12345678910__weak __typeof(self) weakSelf = self; dispatch_async(dispatch_get_global_queue(0, 0), ^{ __strong __typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) { strongSelf.countTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:strongSelf selector:@selector(countDown) userInfo:nil repeats:YES]; NSRunLoop *runloop = [NSRunLoop currentRunLoop]; [runloop addTimer:strongSelf.countTimer forMode:NSDefaultRunLoopMode]; [runloop run]; } }); 主线程更新UI 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ [self.jumpBTN setTitle:[NSString stringWithFormat:@&quot;跳过 %lds&quot;,(long)self.count] forState:UIControlStateNormal]; }); 方案三 使用 GCD 的定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。 1234567891011121314151617dispatch_queue_t queue = dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_SERIAL); //创建定时器 dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); //设置时间（start:几s后开始执行；interval:时间间隔） uint64_t start = 2.0; //2s后开始执行 uint64_t interval = 1.0; //每隔1s执行 dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0); //设置回调 dispatch_source_set_event_handler(timer, ^{ NSLog(@&quot;%@&quot;,[NSThread currentThread]); }); //启动定时器 dispatch_resume(timer); NSLog(@&quot;%@&quot;,[NSThread currentThread]); self.timer = timer; 问题二、NSTimer循环引用常识 这三个方法直接将timer添加到了当前runloop default mode，而不需要我们自己操作，当然这样的代价是runloop只能是当前runloop，模式是default mode: 12345+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block; 下面五种创建，不会自动添加到runloop，还需调用addTimer:forMode: 123456789+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep;- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block; 在实际项目开发中,使用NSTimer解决定时发送任务的需求,但是还是会产生循环引用,今天讲述本项目中的解决方案.循环引用（Circular Reference）是指两个对象之间相互强引用，两者无法按时释放，从而导致内存泄露.如下: 发现两者相互引用,都不能得以释放,造成了循环引用 方案一、给self添加中间件 引入一个对象proxy,proxy弱引用self,然后proxy传入NSTimer. self强引用NSTimer, NSTimer强引用proxy,proxy弱引用着self,这样通过弱引用解决了相互引用,就不会造成环..本项目中使用的方法是引入中间控件HCCProxy1 定义一个继承自NSObject的中间代理对象HCCProxy1,ViewController不持有timer,而是持有HCCProxy1实例, 让HCCProxy1实例弱引用ViewController, timer强引用HCCProxy1实例,如下: 123456789101112131415@interface HCCProxy1 : NSObject+ (instancetype)proxyWithTarget:(id)target;@property (weak, nonatomic) id target;@end@implementation HCCProxy1+ (instancetype)proxyWithTarget:(id)target{ HCCProxy1 *proxy = [[HCCProxy1 alloc] init]; proxy.target = target; return proxy;}- (id)forwardingTargetForSelector:(SEL)aSelector{ return self.target;}@end 在项目中使用如下: 1234- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[HCCProxy1 proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];} 拓展: (id)forwardingTargetForSelector:(SEL)aSelector是什么？ 消息转发，简单来说就是如果当前对象没有实现这个方法，系统会到这个方法里来找实现对象。 本文中由于当前target是HCCProxy1，但是HCCProxy1没有实现方法(当然也不需要它实现)，让系统去找target实例的方法实现，也就是去找ViewController中的方法实现。 方案二、使用继承自NSProxy类HCCProxy的消息转发 123456789101112131415161718192021@interface HCCProxy : NSProxy+ (instancetype)proxyWithTarget:(id)target;@property (weak, nonatomic) id target;@end@implementation HCCProxy+ (instancetype)proxyWithTarget:(id)target{ // NSProxy对象不需要调用init，因为它本来就没有init方法 HCCProxy *proxy = [HCCProxy alloc]; proxy.target = target; return proxy;}- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{ return [self.target methodSignatureForSelector:sel];}- (void)forwardInvocation:(NSInvocation *)invocation{ [invocation invokeWithTarget:self.target];}@end 在项目中使用如下: 1234- (void)viewDidLoad { [super viewDidLoad]; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[HCCProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];} 三、监控卡顿卡顿问题主要是主线程上无法响应用户交互的问题, 如果一个App时不时给你卡一下,有时还长时间没有响应,你还会继续使用嘛?答案当然是显然的 对于iOS开发来说,监控卡顿就是要去找到主线程都做了哪些事情,线程的消息事件依赖于NSRunloop的,所以从NSRunloop入手,就可以知道主线程上都调用了哪些方法.可以监听NSRunloop的状态,就能够发现调用方法是否执行时间过长从而判断是否出现了卡顿.所以推荐的监控卡顿方案是: 通过监控Runloop的状态来判断是否出现卡顿 下面我们讲解一下Runloop的底层常识吧 1、知识-Runloop原理Runloop的目的是,当有事情要去处理时保持线程忙,当没有事件要处理的时候让线程进入休眠.下面通过CFRunloop的源码来分享下Runloop的原理 第一步: 通知observers: Runloop要开始进入loop了,紧接着进入loop,代码如下: 12345//通知 observersif (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);//进入 loopresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); 第二步 开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block. 12345678// 通知 Observers RunLoop 会触发 Timer 回调if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);// 通知 Observers RunLoop 会触发 Source0 回调if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);// 执行 block__CFRunLoopDoBlocks(runloop, currentMode); 接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息 1234if (MACH_PORT_NULL != dispatchPort ) { Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg;} 第三步 回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态. 1234Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);} 第四步 进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒： 基于 port 的 Source 事件； Timer 时间到；*RunLoop 超时； 被调用者唤醒。 等待唤醒的代码如下: 1234567891011do { __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) { // 基于 port 的 Source 事件、调用者唤醒 if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) { break; } // Timer 时间到、RunLoop 超时 if (currentMode-&gt;_timerFired) { break; }} while (1); 第五步 唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下 12if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); 第六步 RunLoop 被唤醒后就要开始处理消息了： 如果是 Timer 时间到的话，就触发 Timer 的回调； 如果是 dispatch 的话，就执行 block； 如果是 source1 事件的话，就处理这个事件。 消息执行完后，就执行加到 loop 里的 block。代码如下：handle_msg: 1234567891011121314151617// 如果 Timer 时间到，就触发 Timer 回调if (msg-is-timer) { __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())} // 如果 dispatch 就执行 blockelse if (msg_is_dispatch) { __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);} // Source1 事件的话，就处理这个事件else { CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) { mach_msg(reply, MACH_SEND_MSG, reply); }} 第七步 根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。代码如下： 12345678910111213if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) { // 事件已处理完 retVal = kCFRunLoopRunHandledSource;} else if (timeout) { // 超时 retVal = kCFRunLoopRunTimedOut;} else if (__CFRunLoopIsStopped(runloop)) { // 外部调用者强制停止 retVal = kCFRunLoopRunStopped;} else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { // mode 为空，RunLoop 结束 retVal = kCFRunLoopRunFinished;} 全部的内部代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/// 用DefaultMode启动void CFRunLoopRun(void) { CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);}/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) { return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);}/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) { /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1\\. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) { Boolean sourceHandledThisLoop = NO; int retVal = 0; do { /// 2\\. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3\\. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4\\. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5\\. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) { Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; } /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); } /// 7\\. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) { mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg } /// 8\\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) { __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) } /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) { __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); } /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else { CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) { mach_msg(reply, MACH_SEND_MSG, reply); } } /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) { /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; } else if (timeout) { /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(runloop)) { /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; } /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 } while (retVal == 0); } /// 10\\. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);} 实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。整个Runloop过程,可以总结如下一张图片 2、如何监测卡顿要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下： 12CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context); 将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。 一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。 开启一个子线程监控的代码如下： 1234567891011121314151617181920//创建子线程监控dispatch_async(dispatch_get_global_queue(0, 0), ^{ //子线程开启一个持续的 loop 用来进行监控 while (YES) { long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC)); if (semaphoreWait != 0) { if (!runLoopObserver) { timeoutCount = 0; dispatchSemaphore = 0; runLoopActivity = 0; return; } //BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿 if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) { //将堆栈信息上报服务器的代码放到这里 } //end activity }// end semaphore wait timeoutCount = 0; }// end while}); 下面是封装的一个工具类HCCMonitor,用于卡顿监测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#import &lt;Foundation/Foundation.h&gt;@interface HCCMonitor : NSObject+ (instancetype)shareInstance;- (void)beginMonitor; //开始监视卡顿- (void)endMonitor; //停止监视卡顿@end#import &quot;HCCMonitor.h&quot;#import &quot;HCCCallStack.h&quot;#import &quot;HCCCPUMonitor.h&quot;@interface HCCMonitor() { int timeoutCount; CFRunLoopObserverRef runLoopObserver; @public dispatch_semaphore_t dispatchSemaphore; CFRunLoopActivity runLoopActivity;}@property (nonatomic, strong) NSTimer *cpuMonitorTimer;@end@implementation HCCMonitor#pragma mark - Interface+ (instancetype)shareInstance { static id instance = nil; static dispatch_once_t dispatchOnce; dispatch_once(&amp;dispatchOnce, ^{ instance = [[self alloc] init]; }); return instance;}- (void)beginMonitor { //监测 CPU 消耗 self.cpuMonitorTimer = [NSTimer scheduledTimerWithTimeInterval:3 target:self selector:@selector(updateCPUInfo) userInfo:nil repeats:YES]; //监测卡顿 if (runLoopObserver) { return; } dispatchSemaphore = dispatch_semaphore_create(0); //Dispatch Semaphore保证同步 //创建一个观察者 CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL}; runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); //将观察者添加到主线程runloop的common模式下的观察中 CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes); //创建子线程监控 dispatch_async(dispatch_get_global_queue(0, 0), ^{ //子线程开启一个持续的loop用来进行监控 while (YES) { long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 20*NSEC_PER_MSEC)); if (semaphoreWait != 0) { if (!runLoopObserver) { timeoutCount = 0; dispatchSemaphore = 0; runLoopActivity = 0; return; } //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿 if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) { // 将堆栈信息上报服务器的代码放到这里 //出现三次出结果// if (++timeoutCount &lt; 3) {// continue;// } NSLog(@&quot;monitor trigger&quot;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{// [HCCCallStack callStackWithType:HCCCallStackTypeAll]; }); } //end activity }// end semaphore wait timeoutCount = 0; }// end while });}- (void)endMonitor { [self.cpuMonitorTimer invalidate]; if (!runLoopObserver) { return; } CFRunLoopRemoveObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes); CFRelease(runLoopObserver); runLoopObserver = NULL;}#pragma mark - Privatestatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ HCCMonitor *lagMonitor = (__bridge HCCMonitor*)info; lagMonitor-&gt;runLoopActivity = activity; dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore; dispatch_semaphore_signal(semaphore);}- (void)updateCPUInfo { thread_act_array_t threads; mach_msg_type_number_t threadCount = 0; const task_t thisTask = mach_task_self(); kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount); if (kr != KERN_SUCCESS) { return; } for (int i = 0; i &lt; threadCount; i++) { thread_info_data_t threadInfo; thread_basic_info_t threadBaseInfo; mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX; if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) { threadBaseInfo = (thread_basic_info_t)threadInfo; if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) { integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / 10; if (cpuUsage &gt; 70) { //cup 消耗大于 70 时打印和记录堆栈 NSString *reStr = HCCStackOfThread(threads[i]); //记录数据库中// [[[HCCDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(id x) {}]; NSLog(@&quot;CPU useage overload thread stack：\\n%@&quot;,reStr); } } } }}@end 四、性能优化当tableview的cell有多个ImageView，并且是大图的话，会不会在滑动的时候导致卡顿，答案是显然意见的。 通过上面讲述Runloop的原理，我们可以使用Runloop每次循环添加一张图片。 12345/* 为什么要优化： Runloop会在一次循环中绘制屏幕上所有的点，如果加载的图片过大，过多，就会造成需要绘制很多的的点，导致一次循环的时间过长，从而导致UI卡顿。 */ 监听Runloop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//添加runloop监听者- (void)addRunloopObserver{ // 获取 当前的Runloop ref - 指针 CFRunLoopRef current = CFRunLoopGetCurrent(); //定义一个RunloopObserver CFRunLoopObserverRef defaultModeObserver; //上下文 /* typedef struct { CFIndex version; //版本号 long void * info; //这里我们要填写对象（self或者传进来的对象） const void *(*retain)(const void *info); //填写&amp;CFRetain void (*release)(const void *info); //填写&amp;CGFRelease CFStringRef (*copyDescription)(const void *info); //NULL } CFRunLoopObserverContext; */ CFRunLoopObserverContext context = { 0, (__bridge void *)(self), &amp;CFRetain, &amp;CFRelease, NULL }; /* 1 NULL空指针 nil空对象 这里填写NULL 2 模式 kCFRunLoopEntry = (1UL &lt;&lt; 0), kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU 3 是否重复 - YES 4 nil 或者 NSIntegerMax - 999 5 回调 6 上下文 */ // 创建观察者 defaultModeObserver = CFRunLoopObserverCreate(NULL, kCFRunLoopBeforeWaiting, YES, NSIntegerMax - 999, &amp;Callback, &amp;context); //添加当前runloop的观察着 CFRunLoopAddObserver(current, defaultModeObserver, kCFRunLoopDefaultMode); //释放 CFRelease(defaultModeObserver);}@end 回调方法1234567891011121314151617181920212223static void Callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ //通过info桥接为当前的对象 ZXYRunloop * runloop = (__bridge ZXYunloop *)info; //如果没有任务，就直接返回 if (runloop.tasks.count == 0) { return; } BOOL result = NO; while (result == NO &amp;&amp; runloop.tasks.count) { //取出任务 RunloopBlock unit = runloop.tasks.firstObject; //执行任务 result = unit(); //删除任务 [runloop.tasks removeObjectAtIndex:0]; }} 通过上面的两个方法我们可以做到监听Runloop循环，以及每次循环需要处理的事情，这个时候我们只需要对外提供一个添加任务的方法，用数组保存起来。 1234567891011//add task 添加任务- (void)addTask:(RunloopBlock)unit withId:(id)key{ //添加任务到数组 [self.tasks addObject:unit]; [self.taskKeys addObject:key]; //为了保证加载到图片最大数是20所以要删除 if (self.tasks.count &gt; self.maxQueue) { [self.tasks removeObjectAtIndex:0]; [self.taskKeys removeObjectAtIndex:0]; } 在ZXYRunloop初始化方法设置初始化对象和基本信息 12345678910111213- (instancetype)init{ self = [super init]; if (self) { //初始化对象／基本信息 self.maxQueue = 20; self.tasks = [NSMutableArray array]; self.taskKeys = [NSMutableArray array]; self.timer = [NSTimer scheduledTimerWithTimeInterval:0.001 repeats:YES block:^(NSTimer * _Nonnull timer) { }]; //添加Runloop观察者 [self addRunloopObserver]; } return self;} 在TableViewCell中使用： 1234[[ZXYRunloop shareInstance] addTask:^BOOL{ [ViewController addCenterImg:cell]; return YES; } withId:indexPath]; 总结一下思想 加载图片的代码保存起来，不要直接执行，用一个数组保存 block 监听我们的Runloop循环 CFRunloop CFRunloopObserver 每次Runloop循环就让它从数组里面去一个加载图片等任务出来执行","link":"/2019/03/16/Runloop/"},{"title":"block","text":"block本质是什么 Block 本质上是一个 Objective-C 的对象，它内部也有一个 isa 指针，它是一个封装了函数及函数调用环境的 Objective-C 对象 NSGlobalBlock、NSStackBlock、NSMallocBlock 当一个 __NSStackBlock__ 类型 Block 做 copy 操作后就会将这个 Block 从栈上复制到堆上，而堆上的这个 Block 类型就是 __NSMallocBlock__ 类型。在 ARC 环境下，编译器会根据情况，自动将 Block 从栈上 copy 到堆上。具体会进行 copy 的情况有如下 4 种： block 作为函数的返回值时； block 赋值给 __strong 指针，或者赋值给 block 类型的成员变量时； block 作为 Cocoa API 中方法名含有 usingBlock 的方法参数时； block 作为 GCD API 的方法参数时 __block 的作用 简单来说，__block 作用是允许 block 内部访问和修改外部变量，在 ARC 环境下还可以用来防止循环引用； 12345678910__block int age = 10;void (^exampleBlock)(void) = ^{ // block NSLog(@&quot;1.age is: %d&quot;, age); age = 16; NSLog(@&quot;2.age is: %d&quot;, age);};exampleBlock();NSLog(@&quot;3.age is: %d&quot;, age);复制代码 __block 主要用来解决 block 内部无法修改 auto 变量值的问题，为什么加上 __block 修饰之后，auto 变量值就能修改了呢？ 这是因为，加上 __block 修饰之后，编译器会将 __block 变量包装成一个结构体 __Block_byref_age_0 ，结构体内部 *__forwarding 是指向自身的指针，并且结构体内部还存储着外部 auto 变量。 12345678struct __Block_byref_val_0 { void *__isa; // isa指针 __Block_byref_val_0 *__forwarding; int __flags; int __size; // Block结构体大小 int age; // 捕获到的变量}复制代码 从上图可以看到，如果 block 是在栈上，那么这个 __forwarding 指针就是指向它自己，当这个 block 从栈上复制到堆上后，栈上的 __forwarding 指针指向的是复制到堆上的 __block 结构体。堆上的 __block 结构体中的 __forwarding 指向的还是它自己，即 age-&gt;__forwarding 获取到堆上的 __block 结构体，age-&gt;__forwarding-&gt;age 会把堆上的 age 赋值为 16 。因此不管是栈上还是堆上的 __block 结构体，最终使用到的都是堆上的 __block 结构体里面的数据。 __weak 的作用 简单来说是为了防止循环引用。使 block 对象对 self 弱引用 __strong 的作用 简单来说，是防止 Block 内部引用的外部 weak 变量被提前释放，进而在 Block 内部无法获取 weak 变量以继续使用的情况； 思考题 Block 内修改外部 NSMutableString 、NSMutableArray 、NSMutableDictionary 对象，是否需要添加 __block 修饰？ 123456789NSMutableArray *mutableArray = [[NSMutableArray alloc] init];[mutableArray addObject:@&quot;1&quot;];void (^exampleBlock)(void) = ^{ // block [mutableArray addObject:@&quot;2&quot;];};exampleBlock();NSLog(@&quot;mutableArray: %@&quot;, mutableArray);复制代码 打印日志： mutableArray: ( 1, 2 ) 答案是：不需要。因为在 block 内部，我们只是使用了对象 mutableArray 的内存地址，往其中添加内容。并没有修改其内存地址，因此不需要使用 __block 也可以正确执行。当我们只是使用局部变量的内存地址，而不是对其内存地址进行修改时，我们无需对其添加 __block ，如果添加了 __block 系统会自动创建相应的结构体，这种情况冗余且低效。 Block 数据结构 Block 内部数据结构图如下： 12345678910111213141516struct Block_descriptor { unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);};struct Block_layout { void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */};复制代码 Block_layout 结构体成员含义如下： isa: 指向所属类的指针，也就是 block 的类型 flags: 按 bit 位表示一些 block 的附加信息，比如判断 block 类型、判断 block 引用计数、判断 block 是否需要执行辅助函数等； reserved: 保留变量； invoke: block 函数指针，指向具体的 block 实现的函数调用地址，block 内部的执行代码都在这个函数中； descriptor: 结构体 Block_descriptor，block 的附加描述信息，包含 copy/dispose 函数，block 的大小，保留变量； variables: 因为 block 有闭包性，所以可以访问 block 外部的局部变量。这些 variables 就是复制到结构体中的外部局部变量或变量的地址； Block_descriptor 结构体成员含义如下： reserved: 保留变量； size: block 的大小； copy: 函数用于捕获变量并持有引用； dispose: 析构函数，用来释放捕获的资源； 调用copy,把NSStackBlock变成NSMallocBlock 原因：栈中的代码在作用域结束之后内存就会被销毁，可能block内存销毁之后才去调用它 什么情况下ARC会自动将block进行一次copy操作？ 1、block作为函数返回值时 2、 将block赋值给__strong指针时 3、block作为方法参数时 Block 1、解决block循环引用的思路就是中介者模式。2、Block的本质就是对象3、当Block捕获到外界变量时，他就会从全局block变成堆block _NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域data中 _NSConcreteStackBlock栈上(前面讲的都是栈上的 block) _NSConcreteMallocBlock 堆上 通过__block修饰int a,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用. | __TestClass__testMethods_block_copy_0 | 从栈复制到堆时 || __TestClass__testMethods_block_dispose_0 | 堆上的Block被废弃时 | 什么时候栈上的Block会被复制到堆呢？ 调用block的copy函数时。 Block作为函数返回值返回时。 将Block赋值给附有Block类型成员变量时。将栈block复制到堆以后，block结构体的isa成员变量变成了_NSConcreteMallocBlock。 什么时候Block被废弃呢？ 堆上的Block被释放后,谁都不再持有Block时调用dispose函数。 ARC下bl因为block0持有__block变量，所以也会把这个__block变量复制到堆上 __strong、__weak修饰解决循环引用首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,所以一般在block外部对操作对象会加上__weak,在Block内部使用__strong修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有, 被__block修饰的对象类型当__block变量在栈上时，不会对指向的对象产生强引用当__block变量被copy到堆时会调用__block变量内部的copy函数copy函数内部会调用_Block_object_assign函数_Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain） 如果__block变量从堆上移除会调用__block变量内部的dispose函数dispose函数内部会调用_Block_object_dispose函数_Block_object_dispose函数会自动释放指向的对象（release）","link":"/2019/04/17/block/"},{"title":"搭建博客","text":"环境配置Hexo官网上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。 1.Node.js用来生成静态页面。移步Node.js官网，下载v5.5.0 Stable 一路安装即可。 2.Git用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考Hexo官网上的安装方法。 安装Hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令： 1$ sudo npm install -g hexo 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装) 注意坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化终端cd到一个你选定的目录，执行hexo init命令： 1$ hexo init blog blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm： 1$ npm install 执行如下命令，开启hexo服务器： 1$ hexo s 此时，浏览器中打开网址http://localhost:4000，能看到页面 关联Github1.创建仓库登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如xushuanghui.github.io即下图中1所示： 本地的blog文件夹下内容为： 1234567_config.yml db.json node_modules package.jsonscaffoldssourcethemes 终端cd到blog文件夹下，vim打开_config.yml，命令如下： 1$ vim _config.yml 打开后往下滑到最后，修改成下边的样子： 1234deploy: type: git repository: https://github.com/xushuanghui/xushuanghui.github.io.git branch: master 你需要将repository后xushuanghui换成你自己的用户名，地址在上图2位置获取。hexo 3.1.1版本后type:值为git。 注意坑二：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记 在blog文件夹目录下执行生成静态页面命令： 1$ hexo generate 或者：hexo g 此时若出现如下报错： 1234567ERROR Local hexo not found in ~/blogERROR Try runing: 'npm install hexo --save'则执行命令：npm install hexo --save若无报错，自行忽略此步骤。 再执行配置命令： 1$ hexo deploy 或者：hexo d 注意坑三：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git： 1$ npm install hexo-deployer-git --save 再次执行hexo generate和hexo deploy命令。 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即 12Username for 'https://github.com':Password for 'https://github.com': hexo deploy命令执行成功后，浏览器中打开网址http://xushuanghui.github.io（将xushuanghui换成你的用户名）能看到和打开http://localhost:4000时一样的页面。 为避免每次输入Github用户名和密码的麻烦，可参照第二节方法 ###2.添加ssh key到Github####1.1.检查SSH keys是否存在Github执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。 1$ ls -al ~/.ssh ####1.2.生成新的ssh key执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。 1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件. ####1.3.将ssh key添加到Github中Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 ##3.发布文章终端cd到blog文件夹下，执行如下命令新建文章： 1$ hexo new &quot;postName&quot; 名为postName.md的文件会建在目录/blog/source/_posts下，postName是文件名，为方便链接不建议掺杂汉字.我使用的是macDown. 文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布： 123hexo generate //生成静态页面hexo deploy //将文章部署到Github 至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。 ##安装theme你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例 终端cd到 blog 目录下执行如下命令： 12$ git clone https://github.com/iissnan/hexo-theme-next themes/next将blog目录下_config.yml里theme的名称landscape修改为next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)： 12345$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 至于更改theme内容比如名称、描述、头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。 ##绑定个人域名现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到GoDaddy官网，网友亲切称呼为：狗爹，也可以到阿里万网购买。我是在万网买的，可直接在其网站做域名解析。 ##1.Github端在/blog/themes/next/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：gonghonglou.com写入。 终端cd到blog目录下执行如下命令重新部署： 12345$ hexo clean$ hexo g$ hexo d 注意坑四：网上许多都是说在Github上直接新建CNAME文件，如果这样的话，在你下一次执行hexo d部署命令后CNAME文件就消失了，因为本地没有此文件嘛。 ##2.域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析 记录类型：CNAME 主机记录：将域名解析为example.com（不带www），填写@或者不填写 记录值：gonghonglou.github.io. (不要忘记最后的.，gonghonglou改为你自己的用户名)，点击保存即可. ###1、解决 deploy 后博客空白问题昨晚更新了一下 blog 做了个部署，结果blog就挂了，打开 gonghonglou.com 页面显示一片空白。然而 hexo s 开启本地服务器 localhost:4000 访问是没问题的。上网查了一下，原来是 GitHub Pages 禁止了 source/vendors 目录的访问。Github 在 11 月 3 日更新了版本。其中包括升级了 Jekyll 到 3.3。Jekyll 为了加快构建速度，忽略 vendor 和 node_modules 文件夹。所以部署到 GitHub 后，识别不到本地下的的这个文件夹 blog/themes/next/source/vendor，你只需要给这个文件夹换个名字再重新部署一次就 OK 了。nexT 在 GitHub 上的 isusses 已经给出了解决方案：#1214 还有另一种解决方案就是升级 nexT 主题，cd 到 blog/themes/next/ 下执行命令 git pull 更新。","link":"/2016/12/16/build-blog/"},{"title":"buildProcess","text":"近些日子我们被宠坏了 – 我们只需要单击 Xcode 中的一个按钮（这个按钮看起来有点像是在播放一些音乐的动作），过几秒钟之后，我们的程序就会运行起来了，除非遇到一些错误，这非常的神奇。 在本文中，我们将从更高级别的角度来解读 Build 过程，并探索一下在 Xcode 界面中暴露出的 project setting 信息与 Build 过程有什么关系。为了更加深入的探索 Build 过程中，每一步实际执行的工作，我都会在本文中引入一些别的文章。 解密 Build 日志为了了解 Xcode build 过程的内部工作原理，我们首先把突破口瞄准完整的 log 文件上。打开 Log Navigator ，从列表中选择一个 Build ，Xcode 会将 log 文件很完美的展现出来。 默认情况下，上面的 Xcode 界面中隐藏了大量的信息，我们通过选择任务，然后点击右边的展开按钮，就能看到每个任务的详细信息。另外一种可选的方案就是选中列表中的一个或者多个任务，然后选择组合键 Cmd-C，这将会把所有的纯文本信息拷贝至粘贴板。最后，我们还可以选择 Editor 菜单中的 “Copy transcript for shown results”，以此将所有的 log 信息拷贝到粘贴板中。 本文给出的示例中，log 信息将近有 10,000 行（其实大多数的 log 信息是编译 OpenSSL 时生成的，并不是我们自己所写的代码生成的）。下面我们就开始吧！ 注意观察输出的 log 信息，首先会发现 log 信息被分为不同的几大块，它们与我们工程中的targets相互对应着： 12345678910111213Build target Pods-SSZipArchive...Build target Makefile-openssl...Build target Pods-AFNetworking...Build target crypto...Build target Pods...Build target ssl...Build target objcio 本文涉及到的工程有几个依赖项：其中 AFNetworking 和 SSZipArchive 包含在 Pods 中，而 OpenSSL 则以子工程的形式包含在工程中。 针对工程中的每个 target，Xcode 都会执行一系列的操作，将相关的源码，根据所选定的平台，转换为机器可读的二进制文件。下面我们详细的了解一下第一个 target：SSZipArchive。 在针对这个 target 输出的 log 信息中，我们可以看到每个任务被执行的详细情况。例如第一个任务是处理一个预编译头文件（为了增强 log 信息的可读性，我省略了许多细节）： 12345678910111213(1) ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.1_0.compiler (2) cd /.../Dev/objcio/Pods setenv LANG en_US.US-ASCII setenv PATH &quot;...&quot; (3) /.../Xcode.app/.../clang (4) -x objective-c-header (5) -arch armv7 ... configuration and warning flags ... (6) -DDEBUG=1 -DCOCOAPODS=1 ... include paths and more ... (7) -c (8) /.../Pods-SSZipArchive-prefix.pch (9) -o /.../Pods-SSZipArchive-prefix.pch.pch 在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。 类似上面的每个 log 信息块都会利用一行 log 信息来描述相关的任务作为起点。 接着输出带缩进的3行 log 信息，列出了该任务执行的语句。此处，工作目录发生了改变，并对 LANG 和 PATH 环境变量进行设置。 这里是发生奇迹的地方。为了处理一个.pch文件，调用了 clang，并附带了许多可选项。下面跟着输出的 log 信息显示了完整的调用过程，以及所有的参数。我们看看其中的几个参数… -x 标示符用来指定所使用的语言，此处是 objective-c-header。 目标架构指定为 armv7。 暗示 #defines 的内容已经被添加了。 -c 标示符用来告诉 clang 具体该如何做。-c 表示：运行预处理器、词法分析器、类型检查、LLVM 的生成和优化，以及 target 指定汇编代码的生成阶段，最后，运行汇编器以产出一个.o的目标文件。 输入文件。 输出文件。 虽然有大量的 log 信息，不过我不会对每个任务做详细的介绍。我们的重点是让你全面的了解在整个 build 过程中，哪些工具会被调用，以及背后会使用到了哪些参数。 针对这个 target ，虽然只有一个 .pch 文件，但实际上这里对 objective-c-header 文件的处理有两个任务。通过观察具体输出的 log 信息，我们可以知道详情： 12ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c ...ProcessPCH /.../Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7s objective-c ... 从上面的 log 信息中，可以明显的看出 target 针对两种架构做了 build – armv7 和 armv7s – 因此 clang 对文件做了两次处理，每次针对一种架构。 在处理预编译头文件之后，可以看到针对 SSZipArchive target 有另外的几个任务类型。 123CompileC ...Libtool ...CreateUniversalBinary ... 顾名思义：CompileC 用来编译 .m 和 .c 文件，Libtool 用来从目标文件中构建 library，而 CreateUniversalBinary 则将上一阶段产生的两个 .a 文件（每个文件对应一种架构）合并为一个通用的二进制文件，这样就能同时在 armv7 和 armv7s 上面运行。 接着，在工程中其它一些依赖项也会发生于此类似的步骤。AFNetworking 被编译之后，会与 SSZipArchive 进行链接，以当做 pod library。OpenSSL 编译之后，会接着处理 crypto 和 ssl target。 当所有的依赖项都 build 完成之后，就轮到我们程序的 target 了。Build 该 target 时，输出的 log 信息会包含一些非常有价值，并且之前没有出现过的内容： 123456789101112PhaseScriptExecution ...DataModelVersionCompile ...Ld ...GenerateDSYMFile ...CopyStringsFile ...CpResource ...CopyPNGFile ...CompileAssetCatalog ...ProcessInfoPlistFile ...ProcessProductPackaging /.../some-hash.mobileprovision ...ProcessProductPackaging objcio/objcio.entitlements ...CodeSign ... 在上面的任务列表中，根据名称不能区分的唯一任务可能就是 Ld，Ld 是一个 linker 工具的名称，与 libtool 非常相似。实际上，libtool也是简单的调用 ld 和 lipo。’ld’被用来构建可执行文件，而libtool则用来构建 library 文件。阅读Daniel 和 Chris两篇文章，可以了解到更多关于编译和链接的工作原理。 上面每一个步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看到的的 ProcessPCH 类似。至此，我将不会继续介绍这些 log 信息了，我将带领大家从另外一个不同的角度来继续探索这些任务：Xcode 是如何知道哪些任务需要被执行？ Build过程的控制当你选择 Xcode 5 中的一个工程时，会在 project editor 顶部显示出 6 个 tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。 对于我们理解 build 过程来说，其中最后 3 项与 build 过程紧密相连。 Build PhasesBuild Phases 代表着将代码转变为可执行文件的最高级别规则。里面描述了 build 过程中必须执行的不同类型规则。 https://objccn.io/images/issues/issue-6/build-phases.png 首先是 target 依赖项的构建。这里会告诉 build 系统，build 当前的 target 之前，必须先对这里的依赖性进行 build。实际上这并不属于真正的 build phase，在这里，Xcode 只不过将其与 build phase 显示到一块罢了。 接着在 build phase中是一个 CocoaPods 相关的脚本 script execution – 更多 CocoaPods 相关信息和 它的 build 过程可以查看Michele的文章 – 接着在 Compile Sources section 中规定了所有必须参与编译的文件。需要留意的是，这里并没有指明这些文件是如何被编译处理的。关于处理这些文件的更多内容，我们将在研究 build rules 和 build settings 时学习到。此处列出的所有文件将根据相关的 rules 和 settings 被处理。 当编译结束之后，接下来就是将编译所生成的目标文件链接到一块。注意观察，Xcode 中的 build phase 之后是：”Link Binary with Libraries.” 这里面列出了所有的静态库和动态库，这些库会参与上面编译阶段生成的目标文件进行链接。静态库和动态库的处理过程有非常大的区别，相关内容请参考 Daniel的文章 Mach-O 可执行文件。 当链接完成之后，build phase 中最后需要处理的就是将静态资源（例如图片和字体）拷贝到 app bundle 中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化（如果 build settings 中的 PNG 优化是打开的话）。 虽然静态资源的拷贝是 build phase 中的最后一步，但 build 还没有完成。例如，还没有进行 code signing （这并不是 build phase 考虑的范畴），code signing 属于 build 步骤中的最后一步 “Packaging”。 定制Build Phases至此，如果不考虑默认设置的话，你已经可以完全掌握了上面介绍的 build phases。例如，你可以在 build phases 中添加运行自定义脚本，就像CocoaPods使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到指定的 target 目录中，这非常有用。 另外定制 build phases 有一个非常好用的功能：添加带有水印（包括版本号和 commit hash）的 app icon – 只需要在 build phase 中添加一个 “Run Script”，并用下面的命令来获取版本号和 commit hash： 12version=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;${INFOPLIST_FILE}&quot;`commit=`git rev-parse --short HEAD` 然后使用 ImageMagick 来修改 app icon。这里有一个完整的示例，可以参考。 如果你希望自己或者别人编写的代码看起来比较简洁点，可以添加一个 “Run Script”：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200。 1find &quot;${SRCROOT}&quot; \\( -name &quot;*.h&quot; -or -name &quot;*.m&quot; \\) -print0 | xargs -0 wc -l | awk '$1 &gt; 200 &amp;&amp; $2 != &quot;total&quot; { print $2 &quot;:1: warning: file more than 200 lines&quot; }' Build RulesBuild rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。 一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。比方说，我们创建了一条预处理规则，该规则将 Objective-C 的实现文件当做输入，解析文件中的注释内容，最后再输出一个 .m 文件，文件中包含了生成的代码。由于我们不能将 .m 文件既当做输入又当做输出，所以我使用了 .mal 后缀，定制的 build rule 如下所示： 上面的规则应用于所有后缀为 *.mal 的文件，这些文件会被自定义的脚本处理（调用我们的预处理器，并附带上输入和输出参数）。最后，该规则告诉 build system 在哪里可以找到此规则的输出文件。 在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的 Build Setting Reference 文档中可以找到所有可用的变量。build 过程中，要想观察所有已存在的环境变量，你可以在 build phase 中添加一个 “Run Script”，并勾选上 “Show environment variables in build log”。 Build Settings至此，我们已经了解到在 build phases 中是如何定义 build 处理的过程，以及 build rules 是如何指定哪些文件类型在编译阶段需要被预处理。在 build settings 中，我们可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。 你会发现 build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。注意，settings 是如何被分割为不同的部分 – 其实这大部分会与 build phases 有关联，有时候也会指定编译的文件类型。 这些选项基本都有很好的文档介绍，你可以在右边面板中的 quick help inspector 或者 Build Setting Reference中查看到。 工程文件上面我们介绍的所有内容都被保存在工程文件（.pbxproj）中，除了其它一些工程相关信息（例如 file groups），我们很少会深入该文件内部，除非在代码 merge 时发生冲突，或许会进去看看。 建议你用文本编辑器打开一个工程文件，从头到尾看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。 首先，我们来看看文件中叫做 rootObject 的条目。在我的工程中，如下所示： 1rootObject = 1793817C17A9421F0078255E /* Project object */; 根据这个 ID（1793817C17A9421F0078255E），我们可以找到 main 工程的定义： 1234/* Begin PBXProject section */ 1793817C17A9421F0078255E /* Project object */ = { isa = PBXProject;... 在这部分中有一些 keys，顺从这些 key，我们可以了解到更多关于这个工程文件的组成。例如，mainGroup 指向了 root file group。如果你按照这个思路，你可以快速了解到在 .pbxproj 文件中工程的结构。下面我要来介绍一些与 build 过程相关的内容。其中 target key 指向了 build target 的定义： 1234targets = ( 1793818317A9421F0078255E /* objcio */, 170E83CE17ABF256006E716E /* objcio Tests */,); 根据第一个内容，我们找到一个 target 的定义： 1234567891011121314151617181920211793818317A9421F0078255E /* objcio */ = { isa = PBXNativeTarget; buildConfigurationList = 179381B617A9421F0078255E /* Build configuration list for PBXNativeTarget &quot;objcio&quot; */; buildPhases = ( F3EB8576A1C24900A8F9CBB6 /* Check Pods Manifest.lock */, 1793818017A9421F0078255E /* Sources */, 1793818117A9421F0078255E /* Frameworks */, 1793818217A9421F0078255E /* Resources */, FF25BB7F4B7D4F87AC7A4265 /* Copy Pods Resources */, ); buildRules = ( ); dependencies = ( 1769BED917CA8239008B6F5D /* PBXTargetDependency */, 1769BED717CA8236008B6F5D /* PBXTargetDependency */, ); name = objcio; productName = objcio; productReference = 1793818417A9421F0078255E /* objcio.app */; productType = &quot;com.apple.product-type.application&quot;;}; 其中 buildConfigurationList 指向了可用的配置项，一般是 Debug 和 Release。根据 debug 对应的 id，我们可以找到 build setting tab 中所有选项存储的位置： 12345678179381B717A9421F0078255E /* Debug */ = { isa = XCBuildConfiguration; baseConfigurationReference = 05D234D6F5E146E9937E8997 /* Pods.xcconfig */; buildSettings = { ALWAYS_SEARCH_USER_PATHS = YES; ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME = LaunchImage; CODE_SIGN_ENTITLEMENTS = objcio/objcio.entitlements;... buildPhases 属性则简单的列出了在 Xcode 中定义的所有 build phases。这非常容易识别出来（Xcode 中的参数使用了它们原本真正的名字，并以 C 风格进行注释）。buildRules 属性是空的：因为在该工程中，我没有自定义 build rules。dependencies 列出了在 Xcode build phase tab 中列出的 target 依赖项。 没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着对象的 ID 走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同 section ，那么对于 merge 工程文件的冲突时，将变得非常简单。甚至可以在 GitHub 中就能阅读工程文件，而不用将工程文件 clone 到本地，并用 Xcode 打开。 小结当今的软件是都用其它复杂的一些软件和资源开发出来的，例如 library 和 build 工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。 本文所探索 build system 的内部机制犹如剥掉洋葱的一层。其实当我们点击 Xcode 中的运行按钮时，我们并没必要理解这个动作涉及到的所有内容。我们只是深入理解某一层，然后找到一个有组织的、并且可控的调用其它工具的顺序，如果我们愿意的话，可以做进一步的探索。我建议你阅读本期中的其它文章，以进一步了解这个洋葱的下一层内容！","link":"/2018/04/01/buildProcess/"},{"title":"carsh定位总结","text":"Crash 日志的渠道 苹果收集的 Crash 日志 用户手机上 设置 -&gt; 隐私 -&gt; 分析 里面的，可以连接电脑 Xcode 导出。 在 Xcode -&gt; Window -&gt; Organizer -&gt; Crashes 里面可以查看 自己应用内收集的 接入一些 APM 产品， 如 EMAS、mPaaS、phabricator 等。 接入 PLCrashReporter 、 KSCrash 等 SDK 进行收集，上报到自建平台统计 ![image-20220909155818088](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220909155818088.png)","link":"/2019/09/09/carsh%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/"},{"title":"编译器做些什么？","text":"编译器做些什么？本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。 简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。 现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。 1 LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。 LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 The Architecture of Open Source Applications 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 LLVM 架构。 在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 hello.m 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察： 12345678% clang -ccc-print-phases hello.m0: input, &quot;hello.m&quot;, objective-c1: preprocessor, {0}, objective-c-cpp-output2: compiler, {1}, assembler3: assembler, {2}, object4: linker, {3}, image5: bind-arch, &quot;x86_64&quot;, {4}, image 本文我们将重点关注第一阶段和第二阶段。在文章 Mach-O Executables 中，Daniel 会对第三阶段和第四阶段进行阐述。 预处理每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。 例如，如果在源文件中出现下述代码： 1#import &lt;Foundation/Foundation.h&gt; 预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。 这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用： 1@class MyClass; 代替： 1#import &quot;MyClass.h&quot; 这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import MyClass.h 的方式来使用它。 假设我们写了一个简单的 C 程序 hello.c: 123456#include &lt;stdio.h&gt;int main() { printf(&quot;hello world\\n&quot;); return 0;} 然后给上面的代码执行以下预处理命令，看看是什么效果： 1clang -E hello.c | less 接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：： 1#import &lt;Foundation/Foundation.h&gt; 再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。 幸好，目前的情况已经改善许多了：引入了模块 - modules功能，这使预处理变得更加的高级。 自定义宏我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏： 1#define MY_CONSTANT 4 那么，凡是在此行宏定义作用域内，输入了 MY_CONSTANT，在预处理过程中 MY_CONSTANT 都会被替换成 4。我们定义的宏也是可以携带参数的， 比如： 1#define MY_MACRO(x) x 鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。 例如，下面这段代码，这样用没什么问题： 123456#define MAX(a,b) a &gt; b ? a : bint main() { printf(&quot;largest: %d\\n&quot;, MAX(10,100)); return 0;} 但是如果换成这么写： 12345678#define MAX(a,b) a &gt; b ? a : bint main() { int i = 200; printf(&quot;largest: %d\\n&quot;, MAX(i++,100)); printf(&quot;i: %d\\n&quot;, i); return 0;} 用 clang max.c 编译一下，结果是： 12largest: 201i: 202 用 clang -E max.c 进行宏展开的预处理结果是如下所示： 123456int main() { int i = 200; printf(&quot;largest: %d\\n&quot;, i++ &gt; 100 ? i++ : 100); printf(&quot;i: %d\\n&quot;, i); return 0;} 本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 static inline: 12345678910111213#include &lt;stdio.h&gt;static const int MyConstant = 200;static inline int max(int l, int r) { return l &gt; r ? l : r;}int main() { int i = MyConstant; printf(&quot;largest: %d\\n&quot;, max(i++,100)); printf(&quot;i: %d\\n&quot;, i); return 0;} 这样改过之后，就可以输出正常的结果 (i:201)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。 基本上，宏的最佳使用场景是日志输出，可以使用 __FILE__ 和 __LINE__ 和 assert 宏。 词法解析标记预处理完成以后，每一个 .m 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。 例如，下面是一段简单的 Objective-C hello word 程序： 1234int main() { NSLog(@&quot;hello, %@&quot;, @&quot;world&quot;); return 0;} 利用 clang 命令 clang -Xclang -dump-tokens hello.m 来将上面代码的标记流导出： 12345678910111213141516171819int 'int' [StartOfLine] Loc=&lt;hello.m:4:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;hello.m:4:5&gt;l_paren '(' Loc=&lt;hello.m:4:9&gt;r_paren ')' Loc=&lt;hello.m:4:10&gt;l_brace '{' [LeadingSpace] Loc=&lt;hello.m:4:12&gt;identifier 'NSLog' [StartOfLine] [LeadingSpace] Loc=&lt;hello.m:5:3&gt;l_paren '(' Loc=&lt;hello.m:5:8&gt;at '@' Loc=&lt;hello.m:5:9&gt;string_literal '&quot;hello, %@&quot;' Loc=&lt;hello.m:5:10&gt;comma ',' Loc=&lt;hello.m:5:21&gt;at '@' [LeadingSpace] Loc=&lt;hello.m:5:23&gt;string_literal '&quot;world&quot;' Loc=&lt;hello.m:5:24&gt;r_paren ')' Loc=&lt;hello.m:5:31&gt;semi ';' Loc=&lt;hello.m:5:32&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;hello.m:6:3&gt;numeric_constant '0' [LeadingSpace] Loc=&lt;hello.m:6:10&gt;semi ';' Loc=&lt;hello.m:6:11&gt;r_brace '}' [StartOfLine] Loc=&lt;hello.m:7:1&gt;eof '' Loc=&lt;hello.m:7:2&gt; 仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。 解析接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree – AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 hello.m： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@interface World- (void)hello;@end@implementation World- (void)hello { NSLog(@&quot;hello, world&quot;);}@endint main() { World* world = [World new]; [world hello];} 当我们执行 clang 命令 clang -Xclang -ast-dump -fsyntax-only hello.m 之后，命令行中输出的结果如下所示：： 1234567891011121314151617181920@interface World- (void) hello;@end@implementation World- (void) hello (CompoundStmt 0x10372ded0 &lt;hello.m:8:15, line:10:1&gt; (CallExpr 0x10372dea0 &lt;line:9:3, col:24&gt; 'void' (ImplicitCastExpr 0x10372de88 &lt;col:3&gt; 'void (*)(NSString *, ...)' &lt;FunctionToPointerDecay&gt; (DeclRefExpr 0x10372ddd8 &lt;col:3&gt; 'void (NSString *, ...)' Function 0x1023510d0 'NSLog' 'void (NSString *, ...)')) (ObjCStringLiteral 0x10372de38 &lt;col:9, col:10&gt; 'NSString *' (StringLiteral 0x10372de00 &lt;col:10&gt; 'char [13]' lvalue &quot;hello, world&quot;))))@endint main() (CompoundStmt 0x10372e118 &lt;hello.m:13:12, line:16:1&gt; (DeclStmt 0x10372e090 &lt;line:14:4, col:30&gt; 0x10372dfe0 &quot;World *world = (ImplicitCastExpr 0x10372e078 &lt;col:19, col:29&gt; 'World *' &lt;BitCast&gt; (ObjCMessageExpr 0x10372e048 &lt;col:19, col:29&gt; 'id':'id' selector=new class='World'))&quot;) (ObjCMessageExpr 0x10372e0e8 &lt;line:15:4, col:16&gt; 'void' selector=hello (ImplicitCastExpr 0x10372e0d0 &lt;col:5&gt; 'World *' &lt;LValueToRValue&gt; (DeclRefExpr 0x10372e0a8 &lt;col:5&gt; 'World *' lvalue Var 0x10372dfe0 'world' 'World *')))) 在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。 延伸阅读 clang AST 介绍 静态分析一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。 类型检查每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 NSObject* 对象发送了一个 hello 消息，那么 clang 就会报错。同样，如果你创建了 NSObject 的一个子类 Test, 如下所示： 12@interface Test : NSObject@end 然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。 一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。 至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了： 1[myObject hello] 其他分析clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 lib/StaticAnalyzer/Checkers，你会看到所有静态检查内容。比如 ObjCUnusedIVarsChecker.cpp 是用来检查是否有定义了，但是从未使用过的变量。而 ObjCSelfInitChecker.cpp 则是检查在 你的初始化方法中中调用 self 之前，是否已经调用 [self initWith...] 或 [super init] 了。编译器还进行了一些其它的检查，例如在 lib/Sema/SemaExprObjC.cpp 的 2,534 行，有这样一句： 1Diag(SelLoc, diag::warn_arc_perform_selector_leaks); 这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。 代码生成clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看hello.c： 123456#include &lt;stdio.h&gt;int main() { printf(&quot;hello world\\n&quot;); return 0;} 要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令： 1clang -O3 -emit-LLVM hello.c -c -o hello.bc 接着用另一个命令来查看刚刚生成的二进制文件： 1llvm-dis &lt; hello.bc | less 输出如下： 1234567891011121314151617; ModuleID = '&lt;stdin&gt;'target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-apple-macosx10.8.0&quot;@str = private unnamed_addr constant [12 x i8] c&quot;hello world\\00&quot;; Function Attrs: nounwind ssp uwtabledefine i32 @main() #0 { %puts = tail call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @str, i64 0, i64 0)) ret i32 0}; Function Attrs: nounwinddeclare i32 @puts(i8* nocapture) #1attributes #0 = { nounwind ssp uwtable }attributes #1 = { nounwind } 在上面的代码中，可以看到 main 函数只有两行代码：一行输出string，另一行返回 0。 再换一个程序，拿 five.m 为例，对其做相同的编译，然后执行 LLVM-dis &lt; five.bc | less: 1234567#include &lt;stdio.h&gt;#import &lt;Foundation/Foundation.h&gt;int main() { NSLog(@&quot;%@&quot;, [@5 description]); return 0;} 抛开其他的不说，单看 main 函数： 1234567891011define i32 @main() #0 { %1 = load %struct._class_t** @&quot;\\01L_OBJC_CLASSLIST_REFERENCES_$_&quot;, align 8 %2 = load i8** @&quot;\\01L_OBJC_SELECTOR_REFERENCES_&quot;, align 8, !invariant.load !4 %3 = bitcast %struct._class_t* %1 to i8* %4 = tail call %0* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %0* (i8*, i8*, i32)*)(i8* %3, i8* %2, i32 5) %5 = load i8** @&quot;\\01L_OBJC_SELECTOR_REFERENCES_2&quot;, align 8, !invariant.load !4 %6 = bitcast %0* %4 to i8* %7 = tail call %1* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to %1* (i8*, i8*)*)(i8* %6, i8* %5) tail call void (%1*, ...)* @NSLog(%1* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to %1*), %1* %7) ret i32 0} 上面代码中最重要的是第 4 行，它创建了一个 NSNumber 对象。第 7 行，给这个 number 对象发送了一个description 消息。第 8 行，将 description 消息返回的内容打印出来。 优化要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 阶乘： 12345678910#include &lt;stdio.h&gt;int factorial(int x) { if (x &gt; 1) return x * factorial(x-1); else return 1;}int main() { printf(&quot;factorial 10: %d\\n&quot;, factorial(10));} 先看看不做优化的编译情况，执行下面命令： 1clang -O0 -emit-llvm factorial.c -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc 重点看一下针对 阶乘 部分生成的代码： 12345678910111213141516171819202122232425define i32 @factorial(i32 %x) #0 { %1 = alloca i32, align 4 %2 = alloca i32, align 4 store i32 %x, i32* %2, align 4 %3 = load i32* %2, align 4 %4 = icmp sgt i32 %3, 1 br i1 %4, label %5, label %11; &lt;label&gt;:5 ; preds = %0 %6 = load i32* %2, align 4 %7 = load i32* %2, align 4 %8 = sub nsw i32 %7, 1 %9 = call i32 @factorial(i32 %8) %10 = mul nsw i32 %6, %9 store i32 %10, i32* %1 br label %12; &lt;label&gt;:11 ; preds = %0 store i32 1, i32* %1 br label %12; &lt;label&gt;:12 ; preds = %11, %5 %13 = load i32* %1 ret i32 %13} 看一下 %9 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 – 将 -03 标志传给 clang： 1clang -O3 -emit-llvm factorial.c -c -o factorial.bc &amp;&amp; llvm-dis &lt; factorial.bc 现在 阶乘 计算相关代码编译后生成的代码如下： 12345678910111213141516define i32 @factorial(i32 %x) #0 { %1 = icmp sgt i32 %x, 1 br i1 %1, label %tailrecurse, label %tailrecurse._crit_edgetailrecurse: ; preds = %tailrecurse, %0 %x.tr2 = phi i32 [ %2, %tailrecurse ], [ %x, %0 ] %accumulator.tr1 = phi i32 [ %3, %tailrecurse ], [ 1, %0 ] %2 = add nsw i32 %x.tr2, -1 %3 = mul nsw i32 %x.tr2, %accumulator.tr1 %4 = icmp sgt i32 %2, 1 br i1 %4, label %tailrecurse, label %tailrecurse._crit_edgetailrecurse._crit_edge: ; preds = %tailrecurse, %0 %accumulator.tr.lcssa = phi i32 [ 1, %0 ], [ %3, %tailrecurse ] ret i32 %accumulator.tr.lcssa} 即便我们的函数并没有按照尾递归的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子ridiculousfish.com。 延伸阅读 LLVM blog: posts tagged ‘optimization’ LLVM blog: vectorization improvements LLVM blog: greedy register allocation The Polly project 如何在实际中应用这些特性刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？ 使用 libclan g或 clang 插件之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 libclang 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 Clangkit，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。 最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。 自定义分析器开发者可以按照 Tutorial for building tools using LibTooling 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。 接下来，进入到 LLVM 目录，然后执行命令cd ~/llvm/tools/clang/tools/。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 样例工程 克隆到本地，然后输入 make。这样就会生成一个名为 example 的二进制文件。 我们的使用场景是：假如有一个 Observer 类, 代码如下所示： 123@interface Observer+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;@end 接下来，我们想要检查一下每当这个类被调用的时候，在 target 对象中是否都有对应的 action 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）： 1234567891011121314151617181920212223virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) { if (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) { QualType ReceiverType = E-&gt;getClassReceiver(); Selector Sel = E-&gt;getSelector(); string TypeName = ReceiverType.getAsString(); string SelName = Sel.getAsString(); if (TypeName == &quot;Observer&quot; &amp;&amp; SelName == &quot;observerWithTarget:action:&quot;) { Expr *Receiver = E-&gt;getArg(0)-&gt;IgnoreParenCasts(); ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(1)-&gt;IgnoreParenCasts()); Selector Sel = SelExpr-&gt;getSelector(); if (const ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) { ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl(); if (! decl-&gt;lookupInstanceMethod(Sel)) { errs() &lt;&lt; &quot;Warning: class &quot; &lt;&lt; TypeName &lt;&lt; &quot; does not implement selector &quot; &lt;&lt; Sel.getAsString() &lt;&lt; &quot;\\n&quot;; SourceLocation Loc = E-&gt;getExprLoc(); PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc); errs() &lt;&lt; &quot;in &quot; &lt;&lt; PLoc.getFilename() &lt;&lt; &quot; &lt;&quot; &lt;&lt; PLoc.getLine() &lt;&lt; &quot;:&quot; &lt;&lt; PLoc.getColumn() &lt;&lt; &quot;&gt;\\n&quot;; } } } } return true;} 上面的这个方法首先查找消息表达式， 以 Observer 作为接收者， observerWithTarget:action: 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。 clang的其他特性clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 编译过程）。 另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。 最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣","link":"/2017/04/23/clang/"},{"title":"cocoaPods","text":"CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 pods)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。 CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。 其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。 本文中，我们将通过分析 pod 安装 (pod install) 的过程，一步一步揭示 CocoaPods 背后的技术。 核心组件CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj (是的，CocoaPods 是一个依赖管理工具 – 利用依赖管理进行构建的！)。 编者注 CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的 CocoaPods/CocoaPod这是是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。 CocoaPods/CoreCore 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。 PodfilePodfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。 Podspec.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。 CocoaPods/Xcodeproj这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。 运行 pod install 命令当运行 pod install 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 --verbose。现在运行这个命令 pod install --verbose，可以看到类似如下的内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667$ pod install --verboseAnalyzing dependenciesUpdating spec repositoriesUpdating spec repo `master` $ /usr/bin/git pull Already up-to-date.Finding Podfile changes - AFNetworking - HockeySDKResolving dependencies of `Podfile`Resolving dependencies for target `Pods' (iOS 6.0) - AFNetworking (= 1.2.1) - SDWebImage (= 3.2) - SDWebImage/CoreComparing resolved specification to the sandbox manifest - AFNetworking - HockeySDKDownloading dependencies-&gt; Using AFNetworking (1.2.1)-&gt; Using HockeySDK (3.0.0) - Running pre install hooks - HockeySDKGenerating Pods project - Creating Pods project - Adding source files to Pods project - Adding frameworks to Pods project - Adding libraries to Pods project - Adding resources to Pods project - Linking headers - Installing libraries - Installing target `Pods-AFNetworking` iOS 6.0 - Adding Build files - Adding resource bundles to Pods project - Generating public xcconfig file at `Pods/Pods-AFNetworking.xcconfig` - Generating private xcconfig file at `Pods/Pods-AFNetworking-Private.xcconfig` - Generating prefix header at `Pods/Pods-AFNetworking-prefix.pch` - Generating dummy source file at `Pods/Pods-AFNetworking-dummy.m` - Installing target `Pods-HockeySDK` iOS 6.0 - Adding Build files - Adding resource bundles to Pods project - Generating public xcconfig file at `Pods/Pods-HockeySDK.xcconfig` - Generating private xcconfig file at `Pods/Pods-HockeySDK-Private.xcconfig` - Generating prefix header at `Pods/Pods-HockeySDK-prefix.pch` - Generating dummy source file at `Pods/Pods-HockeySDK-dummy.m` - Installing target `Pods` iOS 6.0 - Generating xcconfig file at `Pods/Pods.xcconfig` - Generating target environment header at `Pods/Pods-environment.h` - Generating copy resources script at `Pods/Pods-resources.sh` - Generating acknowledgements at `Pods/Pods-acknowledgements.plist` - Generating acknowledgements at `Pods/Pods-acknowledgements.markdown` - Generating dummy source file at `Pods/Pods-dummy.m` - Running post install hooks - Writing Xcode project file to `Pods/Pods.xcodeproj` - Writing Lockfile in `Podfile.lock` - Writing Manifest in `Pods/Manifest.lock`Integrating client project 可以上到，整个过程执行了很多操作，不过把它们分解之后，再看看，会发现它们都很简单。让我们逐步来分析一下。 读取 Podfile 文件你是否对 Podfile 的语法格式感到奇怪过，那是因为这是用 Ruby 语言写的。相较而言，这要比现有的其他格式更加简单好用一些。 在安装期间，第一步是要弄清楚显示或隐式的声明了哪些第三方库。在加载 podspecs 过程中，CocoaPods 就建立了包括版本信息在内的所有的第三方库的列表。Podspecs 被存储在本地路径 ~/.cocoapods 中。 版本控制和冲突CocoaPods 使用语义版本控制 - Semantic Versioning 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于 2.3.1，另一个依赖于 2.3.3，此时冲突解决系统可以使用最新的版本 2.3.3，因为这个可以向后与 2.3.1 兼容。 但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。 当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 1.2.5，另外一个库则依赖于 2.3.1，那么只有最终用户通过明确指定使用某个版本来解决冲突。 加载源文件CocoaPods 执行的下一步是加载源码。每个 .podspec 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 ~/Library/Caches/CocoaPods 中。这个路径中文件的创建是由 Core gem 负责的。 CocoaPods 将依照 Podfile、.podspec 和缓存文件的信息将源文件下载到 Pods 目录中。 生成 Pods.xcodeproj每次 pod install 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中。 安装第三方库当 CocoaPods 往工程中添加一个第三方库时，不仅仅是添加代码这么简单，还会添加很多内容。由于每个第三方库有不同的 target，因此对于每个库，都会有几个文件需要添加，每个 target 都需要： 一个包含编译选项的 .xcconfig 文件 一个同时包含编译设置和 CocoaPods 默认配置的私有 .xcconfig 文件 一个编译所必须的 prefix.pch 文件 另一个编译必须的文件 dummy.m 一旦每个 pod 的 target 完成了上面的内容，整个 Pods target 就会被创建。这增加了相同文件的同时，还增加了另外几个文件。如果源码中包含有资源 bundle，将这个 bundle 添加至程序 target 的指令将被添加到 Pods-Resources.sh 文件中。还有一个名为 Pods-environment.h 的文件，文件中包含了一些宏，这些宏可以用来检查某个组件是否来自 pod。最后，将生成两个认可文件，一个是 plist，另一个是 markdown，这两个文件用于给最终用户查阅相关许可信息。 写入至磁盘直到现在，许多工作都是在内存中进行的。为了让这些成果能被重复利用，我们需要将所有的结果保存到一个文件中。所以 Pods.xcodeproj 文件被写入磁盘，另外两个非常重要的文件：Podfile.lock 和 Manifest.lock 都将被写入磁盘。 Podfile.lock这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。 Manifest.lock这是每次运行 pod install 命令时创建的 Podfile.lock 文件的副本。如果你遇见过这样的错误 沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)，这是因为 Manifest.lock 文件和 Podfile.lock 文件不一致所引起。由于 Pods 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。 xcproj如果你已经依照我们的建议在系统上安装了 xcproj，它会对 Pods.xcodeproj 文件执行一下 touch 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 Pods.xcodeproj 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。 结果运行 pod install 命令的最终结果是许多文件被添加到你的工程和系统中。这个过程通常只需要几秒钟。当然没有 Cocoapods 这些事也都可以完成。只不过所花的时间就不仅仅是几秒而已了。 补充：持续集成CocoaPods 和持续集成在一起非常融洽。虽然持续集成很大程度上取决于你的项目配置，但 Cocoapods 依然能很容易地对项目进行编译。 Pods 文件夹的版本控制如果 Pods 文件夹和里面的所有内容都在版本控制之中，那么你不需要做什么特别的工作，就能够持续集成。我们只需要给 .xcworkspace 选择一个正确的 scheme 即可。 不受版本控制的 Pods 文件夹如果你的 Pods 文件夹不受版本控制，那么你需要做一些额外的步骤来保证持续集成的顺利进行。最起码，Podfile 文件要放入版本控制之中。另外强烈建议将生成的 .xcworkspace 和 Podfile.lock 文件纳入版本控制，这样不仅简单方便，也能保证所使用 Pod 的版本是正确的。 一旦配置完毕，在持续集成中运行 CocoaPods 的关键就是确保每次编译之前都执行了 pod install 命令。在大多数系统中，例如 Jenkins 或 Travis，只需要定义一个编译步骤即可 (实际上，Travis 会自动执行 pod install 命令)。对于 Xcode Bots，在书写这篇文章时我们还没能找到非常流畅的方式，不过我们正朝着解决方案努力，一旦成功，我们将会立即分享。 结束语CocoaPods 简化了 Objective-C 的开发流程，我们的目标是让第三方库更容易被发现和添加。了解 CocoaPods 的原理能让你做出更好的应用程序。我们沿着 CocoaPods 的整个执行过程，从载入 specs 文件和源代码、创建 .xcodeproj 文件和所有组件，到将所有文件写入磁盘。所以接下来，我们运行 pod install --verbose，静静观察 CocoaPods 的魔力如何显现。","link":"/2017/02/23/cocoaPods/"},{"title":"cocoapods加载插件","text":"CocoaPods 为开发者提供了插件注册功能，可以使用 pod plugins create NAME 命令创建插件，并在 Podfile 中通过 plugin 'NAME' 语句引入插件。虽然在一般情况下很少使用这个功能，但在某些场景下，利用插件能比较方便快捷地解决问题。 实现探索首先，由于 pod install 过程会涉及到插件的加载，所以直接查看 installer.rb 文件: 12345678910111213141516171819202122232425262728293031# Runs the registered callbacks for the plugins post install hooks.#def run_plugins_post_install_hooks context = PostInstallHooksContext.generate(sandbox, aggregate_targets) HooksManager.run(:post_install, context, plugins)end# Runs the registered callbacks for the plugins pre install hooks.## @return [void]#def run_plugins_pre_install_hooks context = PreInstallHooksContext.generate(sandbox, podfile, lockfile) HooksManager.run(:pre_install, context, plugins)end# Ensures that all plugins specified in the {#podfile} are loaded.## @return [void]#def ensure_plugins_are_installed! require 'claide/command/plugin_manager' loaded_plugins = Command::PluginManager.specifications.map(&amp;:name) podfile.plugins.keys.each do |plugin| unless loaded_plugins.include? plugin raise Informative, &quot;Your Podfile requires that the plugin `#{plugin}` be installed. Please install it and try installation again.&quot; end endend 其中 run_plugins_pre_install_hooks 和 run_plugins_post_install_hooks 分别执行了插件注册的 pre_install 和 pod_install 方法， ensure_plugins_are_installed 则确认插件是否已被安装。 接下来看下 Command::PluginManager ，这个类在 claide/command/plugin_manager 文件内，属于 claide gem : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# @return [Array&lt;Gem::Specification&gt;] Loads plugins via RubyGems looking# for files named after the `PLUGIN_PREFIX_plugin` and returns the# specifications of the gems loaded successfully.# Plugins are required safely.#def self.load_plugins(plugin_prefix) loaded_plugins[plugin_prefix] ||= plugin_gems_for_prefix(plugin_prefix).map do |spec, paths| spec if safe_activate_and_require(spec, paths) end.compactend# @group Helper Methods# @return [Array&lt;[Gem::Specification, Array&lt;String&gt;]&gt;]# Returns an array of tuples containing the specifications and# plugin files to require for a given plugin prefix.#def self.plugin_gems_for_prefix(prefix) glob = &quot;#{prefix}_plugin#{Gem.suffix_pattern}&quot; Gem::Specification.latest_specs(true).map do |spec| matches = spec.matches_for_glob(glob) [spec, matches] unless matches.empty? end.compactend# Activates the given spec and requires the given paths.# If any exception occurs it is caught and an# informative message is printed.## @param [Gem::Specification] spec# The spec to be activated.## @param [String] paths# The paths to require.## @return [Bool] Whether activation and requiring succeeded.#def self.safe_activate_and_require(spec, paths) spec.activate paths.each { |path| require(path) } truerescue Exception =&gt; exception # rubocop:disable RescueException message = &quot;\\n---------------------------------------------&quot; message &lt;&lt; &quot;\\nError loading the plugin `#{spec.full_name}`.\\n&quot; message &lt;&lt; &quot;\\n#{exception.class} - #{exception.message}&quot; message &lt;&lt; &quot;\\n#{exception.backtrace.join(&quot;\\n&quot;)}&quot; message &lt;&lt; &quot;\\n---------------------------------------------\\n&quot; warn message.ansi.yellow falseend 以上代码调用几个的 Gem::Specification 方法如下： 1234567891011# 获取最新 spec 集合# Return the latest specs, optionally including prerelease specs if prerelease is true.latest_specs(prerelease = false) # 获取 gem 中匹配的文件路径# Return all files in this gem that match for glob.matches_for_glob(glob) # 激活 spec，注册并将其 lib 路径添加到 $LOAD_PATH （$LOAD_PATH 环境变量存储 require 文件时查找的路径）# Activate this spec, registering it as a loaded spec and adding it's lib paths to $LOAD_PATH. Returns true if the spec was activated, false if it was previously activated. Freaks out if there are conflicts upon activation.activate() 可以看到在 loaded_plugins[plugin_prefix] 为空的情况下，程序会执行 plugin_gems_for_prefix 方法，plugin_gems_for_prefix 方法通过 latest_specs 获取了最新的 spec ，并通过 spec 的 matches_for_glob 方法对文件进行匹配，当 spec 中存在匹配 &quot;#{prefix}_plugin#{Gem.suffix_pattern}&quot; 格式的文件时，则视其为 CocoaPods 插件。在拿到插件及其匹配文件后，safe_activate_and_require 方法将文件加入 $LOAD_PATH 中并 require 之。 另外 CLAide::Command 类会在 run 类方法中加载所有插件，然后根据解析后的信息，执行对应的命令: 12345678910111213141516171819202122# @param [Array, ARGV] argv# A list of (remaining) parameters.## @return [Command] An instance of the command class that was matched by# going through the arguments in the parameters and drilling down# command classes.#def self.run(argv = []) plugin_prefixes.each do |plugin_prefix| PluginManager.load_plugins(plugin_prefix) end argv = ARGV.coerce(argv) command = parse(argv) ANSI.disabled = !command.ansi_output? unless command.handle_root_options(argv) command.validate! command.run endrescue Object =&gt; exception handle_exception(command, exception)end 对于通过 pod plugin create 命令创建的插件来说，lib 目录下都会自动生成一个 cocoapods_plugin.rb 文件，这个文件就是用来标识此 gem 为 CocoaPods 插件的。如果想手动创建 CocoaPods 插件，需要满足以下两个条件： 12345678910111213# Handles plugin related logic logic for the `Command` class.## Plugins are loaded the first time a command run and are identified by the# prefix specified in the command class. Plugins must adopt the following# conventions:## - Support being loaded by a file located under the# `lib/#{plugin_prefix}_plugin` relative path.# - Be stored in a folder named after the plugin.# - 支持通过 `lib/#{plugin_prefix}_plugin` 路径的文件加载# (也就是说，如果要对外暴露插件内部存的方法，需要在此文件中 require 之，比如自定义的 Podfile DSL 文件)# - 保存在以插件命名的文件夹中 在 CocoaPods 上下文中，以上的 plugin_prefix 如下： 1self.plugin_prefixes = %w(claide cocoapods) 小结如果需要外部 gem 以插件的形式提供某些功能，可以通过和 CocoaPods 一样的方式实现，即规定特定的命名规则，然后通过 Gem::Specification 提供的方法获取满足条件的 gem ，再 require 入口文件: 123456spec = Gem::Specification.find_by_name('naruto')spec.activatematches = spec.matches_for_glob('naruto')matches.each do |path| require(path)end","link":"/2019/09/23/cocoapod%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/"},{"title":"data段注册","text":"1. attributeattribute((used, section(“____DATA,____launch”))) Clang 提供了很多的编译函数，它们可以完成不同的功能，其中一项就是 section() 函数，section() 函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。在具体的实现中，主要分为编译期和运行时两部分。在编译期，编译器会将标记了 attribute((section())) 的数据写到指定的数据段中，例如写一个{key(key代表不同的启动阶段), *pointer} 对到数据段。到运行时，在合适的时间节点，在根据 key 读取出函数指针，完成函数的调用。 Clang Attributes 是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程，一般以 attribute(xxx) 的形式出现在代码中；为方便使用，一些常用属性也被 Cocoa 定义成宏，比如在系统头文件中经常出现的 NS_CLASS_AVAILABLE_IOS(9_0) 就是 attribute(availability(…)) 这个属性的简单写法。编译器提供了我们一种 attribute((section(“xxx段，xxx节”)的方式让我们将一个指定的数据储存到我们需要的节当中。 used used的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。 section 通常情况下，编译器会将对象放置于DATA段的data或者bss节中。但是，有时我们需要将数据放置于特殊的节中，此时section可以达到目的。 constructor constructor：顾名思义，加上这个属性的函数会在可执行文件（或 shared library）load时被调用，可以理解为在 main() 函数调用前执行。 constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一点，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机： 更多相关知识可以参考 http://liumh.com/2018/08/18/ios-attribute-section/https://www.jianshu.com/p/965f6f903114https://nshipster.com/attribute/ 2. 编译期写入数据首先我们定义函数存储的结构体，如下，function 是函数指针，指向我们要写入的函数，stage 为启动项执行的阶段，priority 为执行优先级，优先级高的启动项优先执行。结构体中还可以增加其他字段，比如类名方法名之类，调试的时候可以查看有哪些组件和方法有写入。 12345struct GHW_Function { char *stage; long priority; void (*function)(void);}; 定义函数 _GHWStage_A ，里面是需要在 Stage_A 阶段要执行的任务。 1234static void _GHWStage_A () { printf(&quot;ModuleA:Stage_A&quot;);} 将包含函数指针的结构体写入到我们指定的数据区指定的段 __DATA, 指定的节 __launch，方法如下 12__attribute__((used, section(&quot;__DATA,__launch&quot;))) \\static const struct GHW_Function __FStage_A = (struct GHW_Function){(char *)(&amp;(&quot;Stage_A&quot;)), _priority_ , (void *)(&amp;_GHWStage_A)}; \\ 上面步骤看起来很烦，而且代码晦涩难懂，所以要使用宏来定义一下，如下 12345#define GHW_FUNCTION_EXPORT(key) \\static void _GHW##key(void); \\__attribute__((used, section(&quot;__DATA,__launch&quot;))) \\static const struct GHW_Function __F##key = (struct GHW_Function){(char *)(&amp;#key), _priority_, (void *)(&amp;_GHW##key)}; \\static void _GHW##key \\ 然后我们将函数写入数据区方式变得很简单了，还是上面的代码，写入指定的段和节，方法如下 123GHW_FUNCTION_EXPORT(Stage_A, kGHWLauncherPriorityHigh)() { printf(&quot;ModuleA:Stage_A\\n&quot;);} 现在可以非常方便简单了。 将工程打包，然后用 MachOView 打开 Mach-O 文件，可以看出数据写入到相关数据区了，如下 3. 运行时读出数据启动项也需要根据所完成的任务被分类，有些启动项是需要刚启动就执行的操作，如 Crash 监控、统计上报等，否则会导致信息收集的缺失；有些启动项需要在较早的时间节点完成，例如一些提供用户信息的 SDK、定位功能的初始化、网络初始化等；有些启动项则可以被延迟执行，如一些自定义配置，一些业务服务的调用、支付 SDK、地图 SDK 等。我们所做的分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段。 如果要覆盖到 main 之前的阶段，之前我们是使用 load 方法，现在使用 attribute 的 constructor 属性也可以实现这个效果，而且更方便，优势如下 所有 Class 都已经加载完成 不用像 load 还得挂在在一个 Class 中 相关代码如下 1234__attribute__((constructor))void premain() { [[GHWLaunchManager sharedInstance] executeArrayForKey:kGHWLauncherStagePreMain];} 表示在 main 之前去获取数据区 pre_main 节的函数指针执行。app willFinish 和 didFinish 阶段也可以执行相关代码，如下 123456789- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [[GHWLaunchManager sharedInstance] executeArrayForKey:kGHWLauncherStageA]; return YES;}- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [[GHWLaunchManager sharedInstance] executeArrayForKey:kGHWLauncherStageB]; return YES;} 读出数据有两种方式： 可以使用 _dyld_register_func_for_add_image 函数，这个函数是用来注册回调，在 dyld 加载镜像时，会执行注册过的回调函数，获取到每个镜像的 mach_header 然后读出数据； 镜像加载完后遍历每个镜像； 本方案里面采用的第二种方式。 4. 读出数据要注意的地方（use_frameworks!）实际在读的时候要根据我们 podfile 里面集成方式而有所区别，如果 Podfile 里面有 use_frameworks! 则是动态库集成方式，如果注释掉的话就是静态库的集成方式，静态库集成方式比较好办，因为只有一个主二进制文件，写入的数据区也是写到这个里面，只需要从这一个二进制文件里面读取就可以了。但是如果是动态库集成的各个组件，那么打成包以后各个组件最后跟主二进制文件是分开的，各个组件写入的数据区跟主二进制不是在一起的，而是写入到自己二进制文件里面相应的数据区，因此我们在读的时候需要遍历所有动态库。我们 App 启动时会加载所有动态库，一共有 569个，其中 83 个是 Podfile 里面集成的，其他都是系统库。这些库的路径也有区别，Podfile 集成进去的库路径类似下面这样 123/private/var/containers/Bundle/Application/70C36D61-CD7A-49F7-A690-0C8B3D36C36A/HelloTrip.app/Frameworks/AFNetworking.framework/AFNetworking/private/var/containers/Bundle/Application/70C36D61-CD7A-49F7-A690-0C8B3D36C36A/HelloTrip.app/Frameworks/APAddressBook.framework/APAddressBook/private/var/containers/Bundle/Application/70C36D61-CD7A-49F7-A690-0C8B3D36C36A/HelloTrip.app/Frameworks/AliyunOSSiOS.framework/AliyunOSSiOS 系统库类似下面这样 1234/System/Library/Frameworks/AddressBookUI.framework/AddressBookUI/System/Library/Frameworks/AVFoundation.framework/AVFoundation/System/Library/Frameworks/AssetsLibrary.framework/AssetsLibrary/usr/lib/libresolv.9.dylib 因此根据路径里面是否包含 /HelloTrip.app/ 来判断是否 Podfile 集成的库，是的话就去找对应的数据区。 经过多次测试，我们 App 在没有过滤路径情况下遍历动态库上的耗时如下 0.0021989345550537110.0022500753402709960.0030020475387573240.0067830085754394530.0022670030593872070.0033680200576782230.003902077674865723 有过滤路径情况下遍历时间如下： 0.00041198730468750.00071597099304199220.00044298171997070310.00042700767517089840.00049400329589843750.00047898292541503910.00043404102325439450.0004389286041259766 可见过滤情况下遍历一次所有动态库不到一毫秒，完全可以接受。因此如果 Podfile 中开启了 use_frameworks! ，使用动态库集成方式，那么读取 section 数据具体代码如下 12345678910111213141516171819202122232425262728293031323334static NSMutableArray&lt;GHWModuleMetaDataModel *&gt; * modulesInDyld() { NSString *appName = [[[NSBundle mainBundle] infoDictionary] objectForKey:(NSString *)kCFBundleExecutableKey]; NSString *fullAppName = [NSString stringWithFormat:@&quot;/%@.app/&quot;, appName]; char *fullAppNameC = (char *)[fullAppName UTF8String]; NSMutableArray&lt;GHWModuleMetaDataModel *&gt; * result = [[NSMutableArray alloc] init]; int num = _dyld_image_count(); for (int i = 0; i &lt; num; i++) { const char *name = _dyld_get_image_name(i); if (strstr(name, fullAppNameC) == NULL) { continue; } const struct mach_header *header = _dyld_get_image_header(i); // printf(&quot;%d name: %s\\n&quot;, i, name); Dl_info info; dladdr(header, &amp;info); const GHWExportValue dliFbase = (GHWExportValue)info.dli_fbase; const GHWExportSection *section = GHWGetSectByNameFromHeader(header, &quot;__DATA&quot;, &quot;__launch&quot;); if (section == NULL) continue; int addrOffset = sizeof(struct GHW_Function); for (GHWExportValue addr = section-&gt;offset; addr &lt; section-&gt;offset + section-&gt;size; addr += addrOffset) { struct GHW_Function entry = *(struct GHW_Function *)(dliFbase + addr); GHWModuleMetaDataModel * metaData = [[GHWModuleMetaDataModel alloc] init]; metaData.priority = entry.priority; metaData.imp = entry.function; metaData.stage = [NSString stringWithCString:entry.stage encoding:NSUTF8StringEncoding]; [result addObject:metaData]; } } return result;} 第一次读取我们自定义的 __launch 节的数据，将启动项相关 C 结构体数据转为对应 OC 的数据模型，放到一个数组里面。然后将数组转化为一个字典，key 为启动相关阶段，obj 为该阶段所有启动项数组。后面再执行的时候直接去字典里面根据对应阶段获取所有启动项数组。代码如下 12345678910111213141516171819202122232425262728293031- (void)executeArrayForKey:(NSString *)key { NSMutableArray *arrayModule; if (![self.moduleDic count]) { arrayModule = modulesInDyld(); if (!arrayModule.count) { return; } [arrayModule sortUsingComparator:^NSComparisonResult(GHWModuleMetaDataModel * _Nonnull obj1, GHWModuleMetaDataModel * _Nonnull obj2) { return obj1.priority &lt; obj2.priority; }]; for (NSInteger i = 0; i &lt; [arrayModule count]; i++) { GHWModuleMetaDataModel *model = arrayModule[i]; if (self.moduleDic[model.stage]) { NSMutableArray *stageArray = self.moduleDic[model.stage]; [stageArray addObject:model]; } else { NSMutableArray *stageArray = [NSMutableArray array]; [stageArray addObject:model]; self.moduleDic[model.stage] = stageArray; } } } arrayModule = self.moduleDic[key]; for (NSInteger i = 0; i &lt; [arrayModule count]; i++) { GHWModuleMetaDataModel *model = arrayModule[i]; IMP imp = model.imp; void (*func)(void) = (void *)imp; func(); }} 五. 总结在启动流程中，在启动阶段 Stage_A 触发所有注册到 Stage_A 时间节点的启动项，通过对这种方式，几乎没有任何额外的辅助代码，我们用一种很简洁的方式完成了启动项的自注册。 后续需要确定启动项的添加 &amp; 维护规范，启动项分类原则，优先级和启动阶段，目的是管控性能问题增量，保证优化成果。 本方案核心思想有两点： 使用 attribute 实现编译期自动注册； 组件自注册，去中心化。 后者依赖前者的基础基础才能得以实现，可以简单理解为一种快速写入和读取配置表的类似技术。","link":"/2020/04/13/data%E6%AE%B5%E6%B3%A8%E5%86%8C/"},{"title":"Hello Worlds","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2017/09/23/hello-world/"},{"title":"oc接入flutter","text":"前言：1、Swift 优秀的文档 免费和开源 代码可读性好 构建速度速度快 2、Flutter 完美的文档 跨平台：单一代码库为多个平台开发应用程序的优势，减少开发、测试工作量 速度快 图形引擎 加速开发的各种工具 热重载 插件和代码重用性：Flutter 还提供了各种各样的插件，以实现更快、更容易的开发 Flutter 动画 上市速度 1. flutter module 创建与配置1.1 下载 flutter 基础包从 github 下载代码 git clone -b beta https//github.com/flutter/flutter.git 但是 github 可能会很慢，可以从码云上下 git clone https://gitee.com/mirrors/Flutter.git 1.2 配置 flutter 环境变量如果使用的 bash 1234567891011121314151617第一步：cd ~ // 在终端进入用户目录，一般打开终端默认就是第二步：open .bash_profile // 打开 bash 配置文件// 另 如果 .bash_profile文件不存在需先创建再打开，具体如下：// touch .bash_profile// open .bash_profile第三步：# for flutterexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH=/Users/hubery/dev_supports/flutter/bin:$PATH第四步：source .bash_profile // 执行文件 使命令生效 如果使用的 zsh 1234567891011121314第一步：cd ~ // 在终端进入用户目录，一般打开终端默认就是第二步：open .zshrc // 打开 zsh 配置文件第三步：# for flutterexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH=/Users/hubery/dev_supports/flutter/bin:$PATH第四步：source .zshrc // 执行文件 使命令生效 其中 /Users/hubery/dev_supports/flutter 为 1.1 中下载下来的 flutter 路径 然后在终端中输入 flutter 验证环境变量是否配置成功，出现如下类似信息时表示配置是OK的 1.3 flutter module 创建可以使用 Android Studio 创建 flutter module 或者在目标目录下使用命令创建 flutter create -t module flutter_demo_module_ios 创建的过程需要梯子从外网获取 flutter 相关资源。 这里推荐使用 Android Studio，操作方便，flutter 相关的插件支持的也挺好 1.4 Android Studio 上 flutter 项目配置 使用 Android Studio 打开刚才创建的 module, 在 Project 栏可以看到项目目录结构 Android Studio –&gt; Preferences –&gt; Plugins –&gt; Marketplace 搜索 Dart 和 Flutter 插件并下载 配置 Dart SDK path, 设置入口为： Android Studio –&gt; Preferences –&gt; Languages &amp; Frameworks –&gt; Dart 配置完成后，Android Studio 工具栏就可以看到选择 devices 的选项啦，如果没出现可以重启 Android Studio 1.5 检查 flutter 运行环境是否可用执行命令 flutter doctor 1.6 如果flutter中插件安装，可在 pubspec.yaml 文件中添加需要的插件 安装: flutter pub get 更新: flutter pub upgrade 1.7 执行编译 debug: flutter build ios --debug --no-codesign release: flutter build ios --release --no-codesign 2. iOS 引入 flutter module2.1 创建 iOS 项目 &amp; Pod Init如何创建 iOS项目以及 CocoaPods 的使用，此处就省略不表了 。。。 如需了解 CocoaPods，请戳传送门：CocoaPods 攻略 2.2 使用 Cocoapods 引入 flutter module 先执行编译该 flutter_demo_module_ios 项目, 终端执行 flutter build ios --debug --no-codesign iOS 项目中 Podfile 文件中添加如下命令: 1234567891011121314# Flutterflutter_application_path = '../flutter_demo_module_ios/'load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb') target 'FlutterDemoIOSApp' do # Comment the next line if you don't want to use dynamic frameworks use_frameworks! # Flutter install_all_flutter_pods(flutter_application_path) end 然后执行 pod install 即可引入，在 pod 可以看到新增3个flutter相关的 framework 3. iOS 调用 flutter 页面3.1 多引擎调用多引擎调用就是每打开一个页面就实例化一个 FlutterViewController iOS 中的实现: 12345678910111213@objc private func onOpenPageA() { let flutterVC = FlutterViewController() flutterVC.setInitialRoute(&quot;one&quot;) self.navigationController?.pushViewController(flutterVC, animated: true) } @objc private func onOpenPageB() { let flutterVC = FlutterViewController() flutterVC.setInitialRoute(&quot;two&quot;) self.navigationController?.pushViewController(flutterVC, animated: true) } flutter 中的实现: 12345678910111213141516171819202122232425262728293031323334import 'dart:ui';import 'package:flutter/material.dart';import 'package:flutter/services.dart';import 'package:flutter_demo_module_ios/pages/first_page.dart';import 'package:flutter_demo_module_ios/pages/second_page.dart';void main() =&gt; runApp(MyApp(pageIndex: window.defaultRouteName));class MyApp extends StatelessWidget { final String pageIndex; const MyApp({Key key, this.pageIndex}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: rootPage(pageIndex), ); } rootPage(String pageIndex) { switch (pageIndex) { case 'one': return FirstPage(); case 'two': return SecondPage(); } }} 在实例化 FlutterViewController 时为 flutter 指定对应的页面，flutter 根据传入的 key 创建对应的页面 起初 flutter 官方提供的是多引擎调用方式，简单来说是每打开一个页面创建一个 FlutterViewController, 每个 FlutterViewController 会对应一个 FlutterEngine, 而在页面退出时内存却没有完全释放，这就导致每打开一次页面内存会逐步增长 3.2 单引擎调用所谓的单引擎就是全局只使用一个 FlutterEngine，再绑定唯一的 FlutterViewController，这样多引擎的内存问题也就基本得到了解决，这也是目前官方比较推荐方式。 由于全局只有 FlutterViewController ，那么在打开 flutter 页面前，需要通过消息通知 flutter 替换当前的 main page iOS 中的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 在 AppDelegate 中创建全局 FlutterEngine，并启动// 之所以在APP启动时就启动，是因为 FlutterEngine 启动时会有短暂的延迟，放在打开页面之前启动会明显感觉到卡顿var window: UIWindow?var flutterEngine: FlutterEngine? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 13.0, *) { // SceneDelegate 中处理 } else { window = UIWindow(frame: UIScreen.main.bounds) window?.backgroundColor = .white let nav = UINavigationController(rootViewController: ViewController()) window?.rootViewController = nav window?.makeKeyAndVisible() } self.flutterEngine = FlutterEngine(name: &quot;flutter-demo&quot;, project: nil) self.flutterEngine?.run() return true }class ViewController: UIViewController { private var flutterVC: FlutterViewController! private var msgChannel: FlutterBasicMessageChannel! override func viewDidLoad() { super.viewDidLoad() self.view.addSubview(button(frame: CGRect(x: 60, y: 150, width: 260, height: 40), title: &quot;Page A&quot;, selector: #selector(onOpenPageA))) self.view.addSubview(button(frame: CGRect(x: 60, y: 250, width: 260, height: 40), title: &quot;Page B&quot;, selector: #selector(onOpenPageB))) let flutterEngine = (UIApplication.shared.delegate as? AppDelegate)?.flutterEngine self.flutterVC = FlutterViewController(engine: flutterEngine!, nibName: nil, bundle: nil) self.msgChannel = FlutterBasicMessageChannel(name: &quot;message-channel&quot;, binaryMessenger: flutterVC as! FlutterBinaryMessenger) self.msgChannel.setMessageHandler({ (message, reply) in print(&quot;message: \\(String(describing: message))&quot;) print(&quot;reply: \\(String(describing: reply))&quot;) }) } private func button(frame: CGRect, title: String, selector: Selector) -&gt; UIButton { let btn = UIButton() btn.frame = frame btn.backgroundColor = .red btn.setTitle(title, for: .normal) btn.setTitleColor(.white, for: .normal) btn.addTarget(self, action: selector, for: .touchUpInside) return btn } @objc private func onOpenPageA() { self.pushFlutterPage(pageName: &quot;one&quot;) } @objc private func onOpenPageB() { self.pushFlutterPage(pageName: &quot;two&quot;) } private func pushFlutterPage(pageName: String) { // 创建信息通道，name 需与 flutter 中保持一致 let methodChannel = FlutterMethodChannel(name: &quot;method-channel&quot;, binaryMessenger: flutterVC as! FlutterBinaryMessenger) // 通知 flutter 将要展示的页面 methodChannel.invokeMethod(pageName, arguments: nil) self.navigationController?.pushViewController(flutterVC, animated: true) // 监听 flutter 页面内的消息 methodChannel.setMethodCallHandler { (call, result) in let action = call.method switch action { case &quot;back&quot;: self.flutterVC.navigationController?.popViewController(animated: true) case &quot;changeBackgroundColor&quot;: let colors: [UIColor] = [.black, .gray, .yellow, .orange, .brown] let idx = arc4random()%4 self.view.backgroundColor = colors[Int(idx)] default: break } } } override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) { // 向 flutter 发送信息 self.msgChannel?.sendMessage(NSDate().description) } } flutter 中的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import 'dart:ui';import 'package:flutter/material.dart';import 'package:flutter/services.dart';import 'package:flutter_demo_module_ios/pages/first_page.dart';import 'package:flutter_demo_module_ios/pages/second_page.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatefulWidget { _MyApp createState() =&gt; _MyApp();}class _MyApp extends State&lt;MyApp&gt; { String pageIndex = 'one'; // 注册消息通道 final MethodChannel _oneChannel = MethodChannel('method-channel'); final BasicMessageChannel _msgChannel = BasicMessageChannel('message-channel', StandardMessageCodec()); @override void initState() { super.initState(); // 监听消息 _oneChannel.setMethodCallHandler((call) { setState(() { pageIndex = call.method; }); return null; }); _msgChannel.setMessageHandler((message) { print('收到 native 信息: $message'); return null; }); } @override Widget build(BuildContext context) { return MaterialApp( title: 'Just a demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: rootPage(pageIndex), ); } rootPage(String pageIndex) { switch (pageIndex) { case 'one': return FirstPage(); case 'two': return SecondPage(); } }}class FirstPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text('First Page 01')), body: Center( child: RaisedButton( onPressed: (){ // 点击事件, 返回上个页面 MethodChannel('method-channel').invokeMapMethod('back'); }, child: Text('Back'), ), ), ); }}class SecondPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text('Second Page 02')), body: Center( child: RaisedButton( onPressed: (){ // 点击事件, 修改上个页面的背景色 MethodChannel('method-channel').invokeMapMethod('changeBackgroundColor'); }, child: Text('ChangeBackgroundColor'), ), ), ); }} 3.3 使用 FlutterBoost 官方描述 FlutterBoost 是一个Flutter插件，它可以轻松地为现有原生应用程序提供Flutter混合集成方案。FlutterBoost的理念是将Flutter像Webview那样来使用。在现有应用程序中同时管理Native页面和Flutter页面并非易事。 FlutterBoost 帮你处理页面的映射和跳转，你只需关心页面的名字和参数即可（通常可以是URL） FlutterBoost 的使用比较简单，但需要 native 与 flutter 都使用该插件，同时 flutter 内部页面的打开与关闭最好也使用该插件提供的方法 FlutterBoost 集成文档","link":"/2020/10/05/iOS%E6%8E%A5%E5%85%A5flutter/"},{"title":"swift protocol小结","text":"协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体和枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型遵循这个协议。 除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这些遵循协议的类型就能够使用这些功能。 协议可以继承多个协议实现菱形继承、struct使用协议来实现多肽 1.Swift中类、结构体、枚举都可以遵守协议 2.遵守多个协议使用逗号(,)分隔 3.有父类的，父类写在前面，协议在后面用逗号(,)分隔 4.协议中可以添加属性 属性可以是实例属性和类型属性 属性需要使用var修饰，不能属于let 类型属性只能使用static修饰，不能使用class 我们需要声明属性必须是可读的或者可读可写的 5.协议中可以添加方法 可以是实例方法或类方法 像普通方法一样放在协议定义中，但不需要大括号和方法体 协议中不支持为协议中的方法提供默认参数 协议中的类方法也只能使用static关键字作为前缀，不能使用class 可以使用mutating提供异变方法，以使用该方法时修改实体的属性等。 可以定义构造方法，但是使用的时候需要使用required关键字 使用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现 将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值。 6.如果定义由类专属协议，则需要继承自AnyObject 7.协议可以作为类型 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 8.协议的底层存储结构是：24字节的ValueBuffer+ metadata(8字节，也就是vwt) + pwt(8字节) 前24字节，官方说法是ValueBuffer，主要用于存储遵循了协议的实体的属性值 如果超过ValueBuffer最大容量就会开辟内存进行存储，此24字节拿出8字节存储指向该内存区域的指针 目前对于类，发现其存储的都是指针 存储metadata是为了查找遵守协议的实体中实现协议的方法 pwt就是protocol witness table协议目击表，存储协议中的方法 面向对象是以对象的视角观察整体结构，万物皆为对象。 面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。 面向协议能够解决面向对象的菱形继承，横切关注点和动态派发的安全性等问题。 参考喵神的面向协议编程与 Cocoa 的邂逅 (上)","link":"/2020/08/24/swift-protocol%E5%8D%8F%E8%AE%AE/"},{"title":"runtime小结","text":"下面代码执行 ⌘+R 后会 Compile Error 、Runtime Crash 或者 NSLog 输出？ 如果 [(__bridge id)obj speak]; 能调用成功，输出什么？ 12345678910111213141516171819@interface Speaker : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Speaker- (void)speak { NSLog(@&quot;Speaker's name: %@&quot;, self.name);}@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; id cls = [Speaker class]; // 1 void *obj = &amp;cls; // 2 [(__bridge id)obj speak]; // 3}@end 当然，本着 反正不是真面试 的态度，直接跑一下不就行了，嘿嘿。 12//输出Speaker's name: &lt;ViewController: 0x7fcc84e09e90&gt; 可以看到运行时成功的，但输出的结果让我有点懵逼？？？原因有2点： 为什么 [(__bridge id)obj speak] 不会崩溃，而且感觉看着像给 类对象发消息 ，这应该解析不了啊？ 为什么 self.name 是ViewController对象？ 下面我们仔细分析一下。 2. 分析2.1 为什么可以发消息？ 第一步 1id cls = [Speaker class]; // 1 这一步获取到了Speaker的类对象，id表示将其转换为一个对象指针，实际类型为struct objc_object *。 12345struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;};typedef struct objc_object *id; 而 [Speaker class] 的返回类型为Class，其实类型为struct objc_class *。 1typedef struct objc_class *Class; 虽然，我们写的类型为struct objc_object *，但其本质还是 struct objc_class *。 1234567891011id cls = [Speaker class];if (object_isClass(cls)) { NSLog(@&quot;object_isClass&quot;);}// 输出object_isClass复制代码也就是说这一步拿到的 本质还是类对象。id cls = [Speaker class];[cls speak];// 直接发送消息，是会崩溃的+[Speaker speak]: unrecognized selector sent to class 0x106824f08 第二步、第三步 1void *obj = &amp;cls; // 2 这一步才是关键。 123struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;}; 可以看到struct objc_object这个结构体的首字段是 isa 指向一个Class。 也就是说，我们如果有一个指向Class的地址的指针，相当于这个对象就已经可以使用了。 1234567891011121314151617181920212223242526272829303132![2020-12-30-8.58.27.png](https://i.loli.net/2020/12/30/vfXLpJNrD4Och7s.png)@interface Speaker : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Speaker- (void)speak { NSLog(@&quot;speak&quot;);}@endstruct my_object { Class isa;};struct my_object *getObject() { // id cls = [Speaker class]; id类型的实质是一个指针，所以cls是一个指针 // void *obj = &amp;cls; 这里取cls的地址，相当于[Speaker class]现在被一个 指针 的 指针 所指向 // 下面 struct my_object * 是一个指针，isa 是一个也是一个指针 // 所以也等效于[Speaker class]现在被一个 指针 的 指针 所指向 struct my_object *obj = (struct my_object *)malloc(sizeof(struct my_object)); obj-&gt;isa = [Speaker class]; return obj;}- (void)viewDidLoad { [super viewDidLoad]; struct my_object *obj = getObject(); id obj1 = (__bridge id)obj; [obj1 speak]; // 3 free(obj);} 我们可以看到，通过id类型转换obj1也被Xcode识别为了Speaker实例对象，而且我们调用 [obj1 speak] 也顺利输出了。 相当于消息 objc_msgSend 执行过程中通过 obj1 顺利访问到了 isa 对象，在Speaker类中找到了speak实例方法，并成功调用。 2.2 为什么输出的name是ViewController实例对象？2.2.1 等价代码1234567891011121314151617181920212223#import &lt;UIKit/UIKit.h&gt;#import &lt;objc/runtime.h&gt;@interface Speaker : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Speaker- (void)speak { NSLog(@&quot;my name's %@&quot;, self.name);}@end@interface ViewController : UIViewController@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; id cls = [Speaker class]; void *obj = &amp;cls; [(__bridge id)obj speak];}@end 我们将这个 ViewController.m 文件编译为 ViewController.cpp 来看一下。 在 终端 中切换到 ViewController.m 所在目录，并输入以下命令： 1xcrun -sdk iphoneos clang -arch arm64 -w -rewrite-objc -fobjc-arc -mios-version-min=8.0.0 -fobjc-runtime=ios-8.0.0 ViewController.m 执行完毕后我们可以在同一个目录下找到 ViewController.cpp 文件。 打开 ViewController.cpp ，并搜索 ViewController_viewDidLoad 即可找到下面的方法： 123456static void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) { ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;))}, sel_registerName(&quot;viewDidLoad&quot;)); id cls = ((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;Speaker&quot;), sel_registerName(&quot;class&quot;)); void *obj = &amp;cls; ((void (*)(id, SEL))(void *)objc_msgSend)((id)(__bridgeid)obj, sel_registerName(&quot;speak&quot;));} 看起来有点复杂，我们把非必要的格式转换去掉： 123456static void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) { objc_msgSendSuper((__rw_objc_super){self, class_getSuperclass(objc_getClass(&quot;ViewController&quot;))}, sel_registerName(&quot;viewDidLoad&quot;)); // 1 id cls = objc_msgSend(objc_getClass(&quot;Speaker&quot;), sel_registerName(&quot;class&quot;)); // 2 void *obj = &amp;cls; // 3 objc_msgSend(obj, sel_registerName(&quot;speak&quot;)); // 4} 可以看到： 对应 [super viewDidLoad] 对应 id cls = [Speaker class]; 对应 void *obj = &amp;cls; 对应 [(__bridge id)obj speak]; objc_msgSend 会传入两个隐式参数self和_cmd，想必大家已经很熟悉了。 12345objc_msgSend(void /* id self, SEL op, ... */ ) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ ) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 而 objc_msgSendSuper 需要传入另一个结构体 struct objc_super *。 1234567891011121314/// Specifies the superclass of an instance.struct objc_super { /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message.#if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif /* super_class is the first class to search */}; {self, class_getSuperclass(objc_getClass(&quot;ViewController&quot;))} 实际上就是在初始化一个struct objc_super结构体。 知道这些之后，再阅读上面的代码就没有什么难度了。 2.2.2 参数顺序123456789101112void sum(NSNumber *a, NSNumber *b) { NSLog(@&quot;a地址 = %p&quot;, &amp;a); NSLog(@&quot;b地址 = %p&quot;, &amp;b); printf(&quot;%d&quot;, a.intValue + b.intValue);}- (void)viewDidLoad { [super viewDidLoad]; sum(@(1), @(2)); NSNumber *c = @(4); NSLog(@&quot;c地址 = %p&quot;, &amp;c);} 我们在给函数传入参数时，参数会作为自动变量入栈 ： 而且我们可以看到入栈的顺序是a先入栈，b后入栈，因为 栈从高地址到低地址分配内存 。 但是在初始化一个结构体的时候，这个顺序是相反的： 我们看到 two_number tn = {@(1), @(2)}; 先传入的是1后传入的2，但实际情况是2先入栈，1后入栈。 按照上面2条规则，下面代码第5步之前的变量入栈的顺序应该是： 123456static void _I_ViewController_viewDidLoad(ViewController * self, SEL _cmd) { // 1 objc_msgSendSuper((__rw_objc_super){self, class_getSuperclass(objc_getClass(&quot;ViewController&quot;))}, sel_registerName(&quot;viewDidLoad&quot;)); // 2 id cls = objc_msgSend(objc_getClass(&quot;Speaker&quot;), sel_registerName(&quot;class&quot;)); // 3 void *obj = &amp;cls; // 4 objc_msgSend(obj, sel_registerName(&quot;speak&quot;)); // 5} self、_cmd为函数的隐式参数，依次先入栈。 objc_msgSendSuper 初始化了一个结构体，这个结构体的参数会入栈。 又因为参数入栈是从右到左的顺序入栈： class_getSuperclass(objc_getClass(“ViewController”)) self后入栈 cls本地变量赋值为Speaker类，最后入栈 那么入栈的顺序为self、_cmd、class_getSuperclass(objc_getClass(“ViewController”))、self、Speaker类。下面我们验证一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface Speaker : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Speaker- (void)speak { NSLog(@&quot;Speaker self: %p, _name: %p&quot;, self, &amp;_name); NSLog(@&quot;Speaker's name: %@&quot;, self.name);}@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; id cls = [Speaker class]; // 1 void *obj = &amp;cls; // 2 NSLog(@&quot;栈区变量&quot;); void *start = (void *)&amp;self; void *end = (void *)&amp;obj; long count = (start - end) / 0x8; for (long i = 0; i &lt; count; i++) { void *address = start - 0x8 * i; if (i == 1) { NSLog(@&quot;%p: %s&quot;, address, *(char **)(address)); } else { NSLog(@&quot;%p: %@&quot;, address, *(void **)address); } } NSLog(@&quot;obj speak&quot;); [(__bridge id)obj speak]; // 3}@end// 打印Demo[32768:1105890] 栈区变量Demo[32768:1105890] 0x7ffeec17c648: &lt;ViewController: 0x7fb445607ee0&gt;Demo[32768:1105890] 0x7ffeec17c640: viewDidLoadDemo[32768:1105890] 0x7ffeec17c638: ViewController //这里比较怪Demo[32768:1105890] 0x7ffeec17c630: &lt;ViewController: 0x7fb445607ee0&gt;Demo[32768:1105890] 0x7ffeec17c628: SpeakerDemo[32768:1105890] obj speakDemo[32768:1105890] Speaker self: 0x7ffeec17c628, _name: 0x7ffeec17c630Demo[32768:1105890] Speaker's name: &lt;ViewController: 0x7fb445607ee0&gt; 从输出可以看到，栈区的打印顺序和我们的分析基本吻合。下面我们看一下为什么Speaker实例对象的 self.name 访问到的是ViewController实例对象。 Speaker实例对象，如果我们通过 [[Speaker alloc] init] 初始化的话，会在堆区分配内存。但现在，我们是使用栈区指针指向了Speaker类对象地址，”伪装”成了一个Speaker实例对象，所以传入的self值为栈区的地址：0x7ffeec17c628 。 从上面的输出我们可以看到，name属性的实例变量_name在Speaker实例对象 self + 0x8 的地址，即 0x7ffeec17c630 。 根据输出_name实例变量访问的地址 0x7ffeec17c630 ，找到栈区对应的数据 0x7ffeec17c630: &lt;ViewController: 0x7fb445607ee0&gt; ，所以输出为 Speaker’s name: &lt;ViewController: 0x7fb445607ee0&gt; 。 3. 总结通过这个面试题我们得出了一下结论： Objective-C中的对象是一个指向class_object地址的变量，即 id obj = &amp;class_object 对象的实例变量 void *ivar = &amp;obj + offset(N) 但这里还有一个疑问： 我们看到直接调用 [super viewDidLoad]; ，栈区的第3个变量为ViewController类。 但根据我们用Clang重写的代码 [super viewDidLoad]; 实现做替换： 123456789101112131415161718192021222324252627282930- (void)viewDidLoad { ((void (*)(struct objc_super *, SEL))(void *)objc_msgSendSuper)(&amp;((struct objc_super){(id)self, (id)class_getSuperclass(objc_getClass(&quot;ViewController&quot;))}), sel_registerName(&quot;viewDidLoad&quot;)); id cls = [Speaker class]; // 1 void *obj = &amp;cls; // 2 NSLog(@&quot;栈区变量&quot;); void *start = (void *)&amp;self; void *end = (void *)&amp;obj; long count = (start - end) / 0x8; for (long i = 0; i &lt; count; i++) { void *address = start - 0x8 * i; if (i == 1) { NSLog(@&quot;%p: %s&quot;, address, *(char **)(address)); } else { NSLog(@&quot;%p: %@&quot;, address, *(void **)address); } } NSLog(@&quot;obj speak&quot;); [(__bridge id)obj speak]; // 3}// 输出Demo[33008:1114325] 栈区变量Demo[33008:1114325] 0x7ffee4983648: &lt;ViewController: 0x7f9e0bf07fd0&gt;Demo[33008:1114325] 0x7ffee4983640: viewDidLoadDemo[33008:1114325] 0x7ffee4983638: UIViewController // 这里符合预期Demo[33008:1114325] 0x7ffee4983630: &lt;ViewController: 0x7f9e0bf07fd0&gt;Demo[33008:1114325] 0x7ffee4983628: SpeakerDemo[33008:1114325] obj speakDemo[33008:1114325] Speaker self: 0x7ffee4983628, _name: 0x7ffee4983630Demo[33008:1114325] Speaker's name: &lt;ViewController: 0x7f9e0bf07fd0&gt; 我们看到栈区的第3个变量为UIViewController类，这个输出是符合预期的，因为class_getSuperclass(objc_getClass(&quot;ViewController&quot;))我们获取的就是父类。 但为什么直接调用 [super viewDidLoad]; ，栈区的第3个变量为ViewController类，这个问题难道是Xcode的Bug？？？","link":"/2019/01/22/runtime-1/"},{"title":"swift小总结","text":"1、混编方式1、SWIFT_OBJC_BRIDGING_HEADER方式适用简单项目 简单的项目可以直接使用projectName--Bridging-Header.h文件的方式，将需要暴露给swift的oc类包含进去。 Swift 访问 Objective-C 只需要在桥接文件中（Bridging-Header.h）中导入需要暴露给 Swift 模块的 Objective-C 类，即可在 Swift 中访问相应 Objective-C 的类和方法 Objective-C 访问 Swift 在 Objective-C 类中导入 ProductName-Swift.h，即可访问 Swift 中暴露给 Objective-C 的类和方法 2、含三方库，业务分库的较复杂的项目 Swift 访问 Objective-C 用 Swift Module 系统，需要用到的 Objective-C 类用 import xxx 进行引用，即可在 Swift 中访问相应的 Objective-C 的类和方法 Objective-C 访问 Swift 在 Objective-C 类中导入 ProductName-Swift.h，即可访问 Swift 中暴露给 Objective-C 的类和方法 补充 纯swift构成的pod，使用时直接@import module就行 oc和swift混合构成的pod pod中oc类中使用swift类，需要通过SWIFT_OBJC_INTERFACE_HEADER_NAME头文件中先导入需要暴露(public)给oc使用的swift类, 然后oc中引用#import &quot;YourPodModule-Swift.h&quot;, #import &quot;YourPodModule-Swift.h&quot;无法直接在主工程引入 podfile*中配置*use_modular_headers!, 主工程通过@import module导入含swift的pod即可访问暴露给外部的swift类。iOS头文件引入变迁#include-&gt;#import-&gt;pch-&gt;@import, @import接解决了编译时间和引用泛滥的问题，建议项目中大量使用。 3、继承 1、使是继承自NSObject的类，也需要显式添加@objc才能访问。在此之前是默认添加的。 2、swift的类如果想通过动态性动态生成，比如`Class cls = NSClassFromString(clsName);` @objc(HSAShortVideoDetailViewController) 1234567891011121314151617181920212223242526272829303132333435363738394041424、[@objc的一些规则](https://github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md)- ``` @objc protocol p { func name() } extension p { func bar() { print(&quot;bar&quot;) } } class C: NSObject, p { func name() { print(&quot;name\\n&quot;) } @objc func aaa() { print(&quot;aaa&quot;) } } let c = C() print(c.responds(to: Selector(&quot;name&quot;))) // true print(c.responds(to: Selector(&quot;bar&quot;))) // false print(c.responds(to: Selector(&quot;aaa&quot;))) // true ## @objc 并不改变访问级别，默认是Internal; 下面的例子中编译时不允许访问，运行时可访问 # pod中定义的swift class class HSACleanScreenView: UIView { @objc func queryBlessInfo() {} } # 主工程 if ([_cleanSreenView respondsToSelector:@selector(queryBlessInfo)]) { [_cleanSreenView performSelector:@selector(queryBlessInfo)]; } 5、避免@objc的滥用 swift中调用oc，c类型的函数需要传递block作为参数时。 作为参数时，的修饰生命周期： @escaping &amp; @nonescaping 1234567891011121314151617181920212223// HVSLiveCleanScreenViewlet block: @convention(block) ()-&gt;() = { self.toSendWishMainPageAction(sender: sender) } NotificationCenter.default.post(name: NSNotification.Name(rawValue: &quot;HSACallLoginNotification&quot;), object: [&quot;callback&quot; : block]) // 类型转换 private func getAuthorizationData() -&gt; [String: Any] { var data: [String: AnyObject] = [String: AnyObject]() data[&quot;callback&quot;] = { print(&quot;Its NOT crashing&quot;) } as (@convention(block) ()-&gt;Void) as AnyObject return data } // swift调用带c函数作为参数的 CGFloat myCFunction(CGFloat (callback)(CGFloat x, CGFloat y)) { return callback(1.1, 2.2); } let swiftCallback : @convention(c) (CGFloat, CGFloat) -&gt; CGFloat = { (x, y) -&gt; CGFloat in return x + y } myCFunction( swiftCallback ) 6、oc头文件中包含swift类时使用前行声明 // MyObjcClass.h @class MySwiftClass; @protocol MySwiftProtocol; @interface MyObjcClass : NSObject - (MySwiftClass *)returnSwiftClassInstance; - (id &lt;MySwiftProtocol&gt;)returnInstanceAdoptingSwiftProtocol; // ... @end 123456787、 oc调用swift闭包- ``` @objc public var tapBlock: (() -&gt; ())? typealias BlockType = (String, String) -&gt; () @objc public var tapBlock: BlockType? 8、NS_STRING_ENUM 尽量利用swift的优秀特性，比如一些有意义的key，直接用string，容易出错还无法进行类型检查 1234567891011121314#objectiv-c## .h文件typedef NSString * THJStringDicKey NS_STRING_ENUM;FOUNDATION_EXTERN THJStringDicKey const THJStringDicKeyTitle;FOUNDATION_EXTERN THJStringDicKey const THJStringDicKeyBody;FOUNDATION_EXTERN THJStringDicKey const THJStringDicKeyHeader;## .m文件THJStringDicKey const THJStringDicKeyTitle = @&quot;title&quot;;THJStringDicKey const THJStringDicKeyBody = @&quot;body&quot;;THJStringDicKey const THJStringDicKeyHeader = @&quot;header&quot;;#swiftlet dic: [THJStringDicKey:String] = [.title:&quot;title&quot;] 关于@convention swiftGG 枚举 oc中使用swift枚举 1234567891011121314151617@objc public enum WishShareType: Int { case video case live func name() -&gt; String { switch self { case .video: return &quot;video&quot; case .live: return &quot;live&quot; default: return &quot;video&quot; } }}// swift中WishShareTypeLive这样来使用 swift中使用oc枚举 1234567typedef NS_ENUM(NSInteger, HSAShortVideoLeftMenuTapActionType) { HSAShortVideoLeftMenuActionHotMenu, // 热门菜品 HSAShortVideoLeftMenuActionCoupon, // 优惠券}; let type: HSAShortVideoLeftMenuTapActionType = .actionCouponlet type = HSAShortVideoLeftMenuTapActionType.actionCoupon 注意：swfit使用Enum.init(rawValue:)生成oc类型的枚举，如果传入的值不在定义范围不会返回悔nil，执行时可能会出现无法预测的异常 协议 oc使用swift协议 1234@objc protocol AlertViewProtocol { func submit(_ row: Int) //必须实现的协议 @objc optional func cancel() //不必实现的协议} swift使用oc的协议 1234@objc public var delegate: HVSLiveChatRoomViewDelegate?if delegate?.responds(to: #selector(HVSLiveChatRoomViewDelegate.showWishMainPage(_:))) ?? false { delegate!.showWishMainPage!(sendWishVc)} target-action swift2.2版本之前可以通过Selector(&quot;functionToExecute:&quot;)的方式来生成，但该方式无法在编译器发现方法是否被实现，会导致unrecognized selector sent to instance 错误。swift2.2后使用#selector(functionToExecute(_:))或Selector(Target.functionToExecute), 之前的Selector(&quot;&quot;)方式被废弃 __FUNCTION__ =&gt;#function 1print(&quot;%@&quot;, #function) // swift2.2之后替换为`#function` 关于responds ## oc中使用 ## swift中判断 func responds(to aSelector: Selector!) -&gt; Bool ## 动态判断，不确定类型的前提下，如遵循协议的swift对象是否实现了协议内的方法 if delegate?.responds(to: #selector(HVSLiveChatRoomViewDelegate.showWishMainPage(_:))) ?? false { delegate!.showWishMainPage!(sendWishVc) } 12345### 循环引用- block循环引用处理 wishVc.animationBlock = { [weak self], [weak obj] animView in animView.show(superView: self!, belowView: self!.wishButton, replace: self?.runingWishAimationView) } 123- weakproxy // NSTimer 还可以通过weakProxy来解循环引用 timer = Timer.init(timeInterval: 1.0, target: FRWWeakProxy.init(target: self), selector: #selector(downTime), userInfo: nil, repeats: true) RunLoop.main.add(timer, forMode: .common) // wkWebView引起的循环引用因为协议的原因无法通过weakProxy来作转换 open func add(_ scriptMessageHandler: WKScriptMessageHandler, name: String) let userContentController = WKUserContentController.init() userContentController.addUserScript(userScript) userContentController.add(self, name: _CardAppNative) // 解决办法 1、 目前通过主动调用clean来主动解开循环 func clean() { webView.configuration.userContentController.removeScriptMessageHandler(forName: _CardAppNative) } 2、 如果是控制器可以通过*`viewWillDisappear:`*来控制解开循环的时机，或则通过自定义`WKScriptMessageHandler`来解决 12345### 第三方库- masonry giftContentView.mas_makeConstraints { (make) in // Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value // make?.left.mas_offset()(contentBeginX) make?.left.offset()(contentBeginX) make?.right.equalTo()(self.contentView)?.offset()(-contentEndX) make?.top.mas_equalTo()(12) make?.height.mas_equalTo()(contentHeight) } oc中可以直接使用`mas_offset()`方式设置，但是swift中这里会导致crash，主要原因是因为swift不支持宏 导致`#define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__)))`失效，实际返回nil; 使用时尽量不适用带`mas_`的方法进行设置 123- Reactive-C // 同样因为宏在swfit中无法使用，`RAC(TARGET, ...)`等宏无法使用，需要直接调用对应代码 model.rac_values(forKeyPath: &quot;buttonStatus&quot;, observer: self).take(untilReplacement: self.rac_signal(for: #selector(self.prepareForReuse))).subscribeNext { [weak self] (obj) in self?.changeActionButtonStyle() } 1234567### 通知- 对于oc中通知的key的使用：宏定义和全部变量定义- 通知使用oc中早先定义的key时`` ## 宏定义 #define kHSANotificateToPlayInlineWishAnimationKey @&quot;notificateToPlayInlineWishAnimation&quot; NSNotification.Name(rawValue: kHSANotificateToPlayInlineWishAnimationKey) ## 全局变量 2、其他问题2.1 Framework targets 不支持 Bridging-Header 通常来讲混编的时候需要在工程中创建 Swift 文件时候，Xcode 会问询是否创建 Bridging-Header 文件，点击是，系统会帮你创建一个 Bridging-Header，你可以将需要引用的 Objective-C 模块的头文件放在里面，然后你可以在 Swift 模块用 Objective-C 的类。但是编译器是不允许在 Framework 中创建 Bridging-header，因此在二/三方库中，我们不能使用桥接文件的方式进行混编 Objective-C 代码的引用，需要用 Swift Module 进行模块间的引用。 2.2 模块引用 引用其他 Objective-C 二方库需要增加命名空间（Namespace），否则会报错找不到文件 Swift 的命名空间是以模块划分的，一个模块表示一个命名空间。开发时，默认添加到主 target 的内容是同处于同一个命名空间的；如果用 Cocoapods 导入的第三方库，是以一个单独的 target 存在，不会存在命名冲突。但如果以源码的方式导入工程，很可能发生命名冲突，所以为了安全起见，第三方库都会使用命名空间这种方式来防止冲突。 2.3 C++ 混编 Objective-C 是 C++ 的超集，就如同 Objective-C 是 C 的超集，在OS X 上同时被 GCC 和 Clang 支持编译，.mm 是 Objective-C++ 的默认后缀名，Xcode 的编译器可以识别。在.mm 文件中，Objective-C 代码和 C++ 代码都可以正常编译运行。在消息业务模块中中引用了 WCDB 这个 Objective-C++ 的库，因此在引用的时候要将引用到的 WCDB.h 头文件中的类文件的 .h 改成 .mm。 2.4 链接错误 我们将上述工作做完后引入到宿主工程中，进行编译的时候会出现链接错误，不要担心，那是因为宿主工程中缺少 Swift 的某些系统库，在宿主工程中建立一个 Swift 文件方可解决。 2.5 Swift 调用 Objective-C 将 Swift 模块文件中，用import xxx 的形式进行模块的引用，包括 Objective-C 的二/三方库 2.6 Objective-C 调用 Swift Swift 类中将需要暴露给 Objective-C 模块引用的类，用 public 申明 Swift 类中需要暴露给 Objective-C 的方法要用关键字 @objc 在 Objective-C 类中引用 ProductName-Swift.h 头文件即可引用暴露给 Objective-C 的 Swift 的类和方法","link":"/2019/08/10/swift%E5%B0%8F%E6%80%BB%E7%BB%93/"},{"title":"swif与oc区别总结","text":"一、Swift中struct和class有什么区别？1.struct是值引用、更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可以继承。对于值类型都有他们自己的数据副本，因此对一个变量操作不可能影响另一个变量。值类型包括结构体（数组和字典），枚举，基本数据类型（boolean, integer, float等） 二者的本质区别：struct是深拷贝；class是浅拷贝。 2.property的初始化不同：class在初始化的时候不能直接把property放在默认的constructor的参数里，而是需要自己创建一个带参数的constructor；而struct可以把属性放在默认的constructor的参数里。 3.变量赋值方式不同。struct是值拷贝； class是引用拷贝 4.struct 和 class 的差別是 struct 的 function 要去改变 property 的值的时候要加上 mutating，而 class 不用 image.png 5.继承struct不可以继承，class可以继承。 6.struct比class更轻量：struct分配在栈中，class分配在堆中。 二、Swift中的方法调用有哪些形式?直接派发、函数表派发、消息机制派发。派发方式受声明位置，引用类型，特定行为的影响。为什么Swift有这么多派发形式？为了效率 直接派发 (Direct Dispatch)、函数表派发 (Table Dispatch )、消息机制派发 (Message Dispatch )都有 总结起来有这么几点: 值类型总是会使用直接派发, 简单易懂 而协议和类的 extension 都会使用直接派发 NSObject 的 extension 会使用消息机制进行派发 NSObject 声明作用域里的函数都会使用函数表进行派发. 协议里声明的, 并且带有默认实现的函数会使用函数表进行派发 指定派发方式finalfinal 允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符, 就算是 extension 里本来就是直接派发的函数. 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector. dynamicdynamic 可以让类里面的函数使用消息机制派发. 使用 dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject 和 Objective-C 的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类. 参考文章：深入理解 Swift 派发机制 三、Swift和OC的区别？Swift和OC的区别有很多，这里总结这几条： Swift Objective-C 语法特性 静态语言，更加安全 动态语言，不那么安全 语法 更精简 冗长 命名空间 有 无 方法调用 直接调用，函数表调用，消息转发 消息转发 泛型/元组/高阶函数 有 无 语言效率 性能更高，速度更快 略低 文件特性 .swift 单文件 .h/.m包含头文件 编程特性 可以更好的实现函数式编程/响应式编程 面向对象编程 四、从OC向Swift迁移的时候遇到的问题？可以参考这篇文章：OC项目转Swift指南 里的混编注意事项。 五、怎么理解面向协议编程？面向对象是以对象的视角观察整体结构，万物皆为对象。 面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。 面向协议能够解决面向对象的菱形继承，横切关注点和动态派发的安全性等问题。 参考喵神的面向协议编程与 Cocoa 的邂逅 (上) 六、 swift中 closure 与OC中block的区别？ closure是匿名函数、block是一个结构体对象 closure通过逃逸闭包来在内部修改变量，block 通过 __block 修饰符 七、@objc在Swift代码中，使用@objc修饰后的类型，可以直接供Objective-C调用。 八、Swift 中的 KVC 和 KVOKVC 要继承 NSObject 1234567class KVCClass :NSObject{ var someValue: String = &quot;123&quot;}let kvc = KVCClass()kvc.someValue // 123kvc.setValue(&quot;456&quot;, forKey: &quot;someValue&quot;)kvc.someValue // 456 KVO 由于 Swift 为了效率, 默认禁用了动态派发, 因此 Swift 要实现 KVO, 除了要继承自 NSObject 外还要将观测的对象标记为 dynamic(让 swift 代码也能有 Objective-C 中的动态机制). 1234567891011121314151617181920class KVOClass:NSObject { dynamic var someValue: String = &quot;123&quot; var someOtherValue: String = &quot;abc&quot;}class ObserverClass: NSObject { func observer() { let kvo = KVOClass() kvo.addObserver(self, forKeyPath: &quot;someValue&quot;, options: .new, context: nil) kvo.addObserver(self, forKeyPath: &quot;someOtherValue&quot;, options: .new, context: nil) kvo.someValue = &quot;456&quot; kvo.someOtherValue = &quot;def&quot; kvo.removeObserver(self, forKeyPath: &quot;someValue&quot;) kvo.removeObserver(self, forKeyPath: &quot;someOtherValue&quot;) } override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) { print(&quot;\\(keyPath!) change to \\(change![.newKey] as! String)&quot;) }}ObserverClass().observer() 九、associatedtype 的作用关联类型：为协议中的某个类型提供了一个别名，其代表的真实类型在实现者中定义 12345678910111213//协议，使用关联类型protocol TableViewCell { associatedtype T func updateCell(_ data: T)} //遵守TableViewCellclass MyTableViewCell: UITableViewCell, TableViewCell { typealias T = Model func updateCell(_ data: Model) { // do something ... }} 十、泛型1.类中泛型实现一个栈，栈里边的元素可以是任何类型，但是所有元素又必须是同一种类型，使用泛型实现的代码就是这样的 123456789101112131415//类作用域class YJKStack&lt;T&gt;: NSObject { //栈空间 private var list:[T] = [] //进栈 public func push(item:T){ list.append(item) } //出栈 public func pop() -&gt; T{ return list.removeLast() }} 2.泛型类型约束实际运用中，我们的参数虽然可以不是特定的类，但是通常需要这个参数要实现某个协议或者是某个类的子类。这时候就要给泛型添加约束了，代码就是下面这一堆喽 12345678910111213141516171819class YJKProtocolStack&lt;T: A&amp;B&gt; 须实现多个协议的话，用 &amp; 符号链接就好啦。class YJKProtocolStack&lt;T: A&gt;: NSObject { //栈空间 private var list:[T] = [] //进栈 public func push(item:T){ list.append(item) } //出栈 public func pop() -&gt; T{ return list.removeLast() } }protocol A {}protocol B {} 十一、权限修饰符open ：修饰的属性或者方法在其他作用域既可以被访问也可以被继承或重载 override。 public ：修饰的属性或者方法可以在其他作用域被访问，但不能在重载 override 中被访问，也不能在继承方法中的 Extension 中被访问。 internal：被修饰的属性和方法只能在模块内部可以访问，超出模块内部就不可被访问了。（默认） fileprivate ：其修饰的属性或者方法只能在当前的 Swift 源文件里可以访问。 private ：只允许在当前类中调用，不包括 Extension ，用 private 修饰的方法不可以被代码域之外的地方访问。 从高到低排序如下： open &gt; public &gt; interal &gt; fileprivate &gt; private 十二、map、filter、reduce 的作用map 用于映射, 可以将一个列表转换为另一个列表 12[1, 2, 3].map{&quot;\\($0)&quot;}// 数字数组转换为字符串数组[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] filter 用于过滤, 可以筛选出想要的元素 12[1, 2, 3].filter{$0 % 2 == 0} // 筛选偶数// [2] reduce 合并 12[1, 2, 3].reduce(&quot;&quot;){$0 + &quot;\\($1)&quot;}// 转换为字符串并拼接// &quot;123&quot; 十三、defer、guard的作用？guard :过滤器，拦截器 guard 和 if 类似, 不同的是, guard 总是有一个 else 语句, 如果表达式是假或者值绑定失败的时候, 会执行 else 语句, 且在 else 语句中一定要停止函数调用. defer 语句块中的代码, 会在当前作用域结束前调用,无论函数是否会抛出错误。每当一个作用域结束就进行该作用域defer执行。 如果有多个 defer, 那么后加入的先执行.(延迟执行的意思) 十四、throws 和 rethrows 的用法与作用throws 用在函数上, 表示这个函数会抛出错误. 有两种情况会抛出错误, 一种是直接使用 throw 抛出, 另一种是调用其他抛出异常的函数时, 直接使用 try XX 没有处理异常. 123456789101112enum DivideError: Error { case EqualZeroError;}func divide(_ a: Double, _ b: Double) throws -&gt; Double { guard b != Double(0) else { throw DivideError.EqualZeroError } return a / b}func split(pieces: Int) throws -&gt; Double { return try divide(1, Double(pieces))} rethrows 与 throws 类似, 不过只适用于参数中有函数, 且函数会抛出异常的情况, rethrows 可以用 throws 替换, 反过来不行 123func processNumber(a: Double, b: Double, function: (Double, Double) throws -&gt; Double) rethrows -&gt; Double { return try function(a, b)} 十五、为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃。 1 数组索引访问的是一段连续地址,越界访问也能访问到内存,但这段内存不一定可用,所以会引起Crash. 2 字典的key并没有对应确定的内存地址,所以是安全的. 十六、swift把struct作为数据模型的优缺点？优点： 1.安全性：struct是值类型传递的，它们没有引用计数 内存：由于它们没有引用数，它们不会因为循环引用导致内存泄漏 速度：值类型通常来说是以栈的形式分配的，而不是用堆。因此它们比Class要快很多。 拷贝：OC里拷贝一个对象，你必须选用正确的拷贝类型（深拷贝、浅拷贝），而值类型的拷贝则非常轻松！ 线程安全：值类型是自动线程安全的。无论你从哪个线程去访问你的struct，都非常简单。 缺点： OC与swift混合开发：OC调用的swift代码必须继承NSObject。 继承：struct不能相互继承 NSUserDefatults: struct不能被序列化成NSData对象","link":"/2020/04/20/swif%E4%B8%8Eoc%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93/"},{"title":"webview白屏问题记录","text":"5.webview白屏问题 一. URL网址无效或含有中文字符（入门级错误）二、HTTP请求问题，设置URL Scheme 白名单三. HTTPS 请求，未实现证书认证代理导致页面不加载的问题didReceiveAuthenticationChallenge创建凭证，申请访问四. iOS 8.0 - iOS 8.2 偶尔白屏问题 白屏：遍历快照缩放后图片的像素点，对纯白像素占比大于99%的页面，认定其为白屏问题页。重新刷新六. 硬件内存不足、进程崩溃 在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。在 WKWebView 中加载下面的测试链接可以稳定重现白屏现 这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。参考解决方案： 1、借助 WKNavigtionDelegate iOS 9以后 WKNavigtionDelegate 新增了一个回调函数： 1- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) ​ 当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。 2、检测 webView.title 是否为空 3、某种资源加载失败了，也许是wk的某种机制把加载过的资源释放了 于是尝试在本地html中加入资源加载的监听，只要发生错误，就调用location.reload();重载当前文档","link":"/2021/04/17/webview%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"事件传递与响应者链","text":"UIKit 主要是通过响应者（UIResponder）来响应用户事件，那么系统是如何来处理的呢？ 事件类型首先我们看下目前系统的定义的 UIEventType，我们主要通过 UIEventTypeTouches 来了解下事件响应： 123456typedef NS_ENUM(NSInteger, UIEventType) { UIEventTypeTouches, // 触摸事件 UIEventTypeMotion, // 晃动事件 UIEventTypeRemoteControl, // 远程控制事件，主要是外部辅助设备或者耳机的远程命令，例如控制音乐声音的大小，或者下一首歌。 UIEventTypePresses API_AVAILABLE(iOS(9.0)), // 物理按键事件}; 触摸事件我们为了搞清楚事件响应机制，我们用触摸事件来进行举例。当触摸事件发生的时候，一直到找到对应这个事件的响应，我把这个过程分为两步： 1、传递链：由系统向离用户最近的view传递。UIKit –&gt; active app's event queue –&gt; window –&gt; root view –&gt; …… –&gt; lowest view 2、响应链：由离用户最近的view向系统传递。initial view –&gt; super view –&gt; ….. –&gt; view controller –&gt; window –&gt; Application –&gt; AppDelegate 通过事件传递机制找到 First Responder First Responder 通过事件响应链找到 Touch Event 事件传递机制 UIKit uses view-based hit-testing to determine where touch events occur. Specifically, UIKit compares the touch location to the bounds of view objects in the view hierarchy. The hitTest:withEvent: method of UIView traverses the view hierarchy, looking for the deepest subview that contains the specified touch, which becomes the first responder for the touch event. 当点击屏幕时，系统会产生一个触摸事件 UIEvent，系统会把这个 UIEvent 放到 Application 的事件队列中，Application 会把事件分发下去。首先响应的是 UIWindow，他会调用 hitTest:withEvent: ，找到能够响应事件的 UIView。UIView 会通过 hitTest:withEvent: 根据触摸事件的 location 在视图的层级结构中进行遍历，找到包含该触摸的层级最深的子视图，定义这个视图作为响应事件（touch event）的 first responder。 我们通过下面的例子，来详细说明两个原理： 如何进行遍历？ hitTest 怎么工作的？ 遍历查找最佳视图流程图 如上图例子所示，当我们点击 View B.1 的时候，如何进行遍历来确认该 View 是 first responder？ 系统会根据 view 添加的顺序，确定其在 subview 数组中的顺序。我们将视图的树形结构画出来，针对这个树，是按照逆先序深度优先遍历。根据图上绿色箭头所示的顺序，查找到 B.1 为响应最合适的 view。顺序如下： 注意：先添加的View A, 在添加的View B，View C，mianView查找子视图先遍历后添加ViewC 1UIWindow -&gt; MainView -&gt; View C -&gt; View B -&gt; View B.2 -&gt; View B.1 hitTest:withEvent: 遍历查找最佳视图 根据如下三个属性判断 view &amp; subview 是否接受事件，若下面三个属性设置如下，则方法会自动忽略该 view &amp; subview isUserInteractionEnabled = false isHidden = true alpha &lt;= 0.01 根据 pointInside:withEvent: 判断点是否在当前 view 内 如果在判断是否有 subview，没有 subview 返回自身；有子视图继续遍历 根据上面的原则，我们可以大概推断出 hitTest:withEvent: 的实现原理代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // 如果控件不允许与用用户交互,那么返回nil if (!self.userInteractionEnabled || [self isHidden] || self.alpha &lt;= 0.01) { return nil; } //判断当前视图是否在点击范围内 if ([self pointInside:point withEvent:event]) { //遍历当前对象的子视图(倒序) __block UIView *hit = nil; [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { //坐标转换，把当前坐标系上的点转换成子控件坐标系上的点 CGPoint convertPoint = [self convertPoint:point toView:obj]; //调用子视图的hitTest方法，判断自己的子控件是不是最适合的View hit = [obj hitTest:convertPoint withEvent:event]; //如果找到了就停止遍历 if (hit) *stop = YES; }]; //返回当前的视图对象 return hit?hit:self; }else { return nil; }}// 该方法判断触摸点是否在控件身上，是则返回YES，否则返回NO，point参数必须是方法调用者的坐标系- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { CGFloat x1 = point.x; CGFloat y1 = point.y; CGFloat x2 = self.frame.size.width / 2; CGFloat y2 = self.frame.size.height / 2; //判断是否在圆形区域内 double dis = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); if (dis &lt;= self.frame.size.width / 2) { return YES; } else{ return NO; }} 事件响应链 我们发现事件响应链和事件传递完全是相反的过程。最有机会处理事件的就是通过事件传递找到的 first responder，如果没有进行处理，就会沿着事件响应链传递给下一个响应者 nextResponder，一直追溯到最上层 UIApplication。若都没有进行处理，就丢弃事件。 处理事件1234- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; 对于触摸事件，系统提供了上面四种方法来处理。如果重写了上述方法，那么事件就会在此中断，并且不再沿着事件响应链进行传递；如果需要继续进行传递，则需要调用 super 方法。 决定第一响应者我们上面通过事件传递机制寻找 first responder 主要是针对 UIEventTypeTouches 事件，但是 UIKit 决定 first responder 是根据事件类型来的。 Event type First responder Touch events 触摸发生的 view Press events 聚焦的对象 Shake-motion events 用户（UIKit）制定的对象 Remote-control events 用户（UIKit）制定的对象 Editing menu messages 用户（UIKit）制定的对象 与加速计、陀螺仪、磁力仪相关的运动事件，不遵循事件响应链。Core Motion 直接将这些事件传递给指定的对象。 改变事件传递链例：两层重叠视图，让事件由下层视图处理，重写上层视图hitTest方法， 12345678910-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { if (判断上层视图是否需要处理该事件) { return nil;//将调用下层试图的hitTest:查找最佳试图 } [super hitTest:point withEvent:event];}判断上层视图是否处理该事件：循环遍历上层可以处理事件的子视图，是否在该point上，-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 改变响应者链在 UIResponse 类中有一个 nextResponder 属性，可以通过重写该属性来改变事件响应链。很多的系统类就通过这个属性改变了 next responder： UIView，如果 view 的 root view 是 UIViewController，则 next responder 是 UIViewController；否则，next responder 是 super view； UIViewController 如果 view controller 是 UIWindow 的 root view ，那么 next responder 是 UIWindow； 如果 view controller 是被另一个 view controller presented 出来，那么 next responder 是 presenting view controller； UIWindow，next responder 是 UIApplication； UIApplication, next responder 是 app delegate； 事件是怎么被接收的？简单描述 Runloop 机制： 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。","link":"/2019/01/30/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"},{"title":"二进制重排","text":"效果对比优化前 优化后 启动优化 1、二进制重排实践二进制重排的关键是获取启动过程中的符号，目前业界常用方案有： 基于静态扫描+运行时 trace 的方案来获取启动时的符号，从而生成 order file 文件实现二进制重排； 基于 Clang 静态插桩的方式来获取启动过程中的所有函数符号； 第一种方案存在对于initialize、block、以及 C++ 函数hook 不到的问题，第二种基于 Clang 静态插桩的方案则可以解决前种方案的不足获取到所有符号。因此，我们选择了基于 Clang 静态插桩的方案来获取启动符号. 1.1、虚拟内存与 Page Fault早期计算机中，并没有设计虚拟内存，程序都是直接从磁盘按序完整地加载进物理内存中，这种方式由于使用的是真实物理内存地址且程序是有序加载进去的，那么通过计算地址偏移就可以访问到其他程序的内存，存在安全隐患，另外由于是完整加载，而用户实际使用时只会用到少部分功能，这样也会造成内存的极大浪费。为了解决这些问题，现在的操作系统在物理内存的基础上引入了虚拟内存的概念。虚拟内存引入后，每个进程可以认为自己拥有从0x000000~0xffffff这一大片连续的内存空间，只不过这个内存地址是虚拟的，要访问实际物理内存地址，需要通过操作系统维护的一张映射表映射之后才可以真正访问到，而映射表是以页（Page）为单位进行管理的。当进程要访问的一个虚拟内存页在经过映射表映射之后发现对应的物理内存页不存在时，会触发一次缺页中断Page Fault，此时会发生 I/O 操作，将磁盘中的数据读入到物理内存页中，读取的过程中苹果还会对读入的内存页进行验签处理，因此如果频繁发生Page Fault的话，Page Fault产生的耗时也不可小觑。Page Fault的数量可以通过 Instruments 自带的 System Trace 工具来查看，其中File Backed Page In就是Page Fault的次数。 .2、二进制重排优化原理APP 启动过程中，会加载大量的类、执行大量的方法，当频繁触发Page Fault的话，对启动耗时会产生不小的影响，因此尽可能减少Page Fault的数量可以优化启动耗时。当启动过程中需要调用的两个方法method1和method2分布在不同的内存页时，此时操作系统需要触发两次缺页中断Page Fault，来加载这两页到内存，如果通过一定的技术手段将这两个方法排列在同一个内存页中，那此时系统只需要触发一次缺页中断即可，如果能够减少一定数量的缺页中断次数，那也就能够减少整体启动耗时。 因此，二进制重排的一个核心问题就是如何将不同的方法尽可能地排列在同一个内存页中。 生成一个二进制的 Mach-O 文件，需要经过编译、链接的过程，Xcode 使用 ld 作为链接器，ld 链接器的配置中有一个名为Order File的参数，它可以配置一个 order 文件路径。一个 order 文件内存储的是符号列表，当我们配置了 order 文件之后，ld 在工作的时候就会根据 order 文件中的符号按照顺序进行排列生成二进制文件。因此，如果我们将启动过程中调用的函数符号都找到，并配置到 order 文件中，那生成的二进制文件在启动时所调用的方法都会尽量排在相同且相邻的内存页上，从而减少启动过程中发生Page Fault的次数，减少因Page Fault而产生的耗时。因此，现在的关键是找到启动过程中调用的函数符号。通过 hook objc_msgSend 能够拿到 OC 方法的调用，但是对于load方法、C++ 构造函数还需要通过扫描 Mach-O 文件来获取，还有一种方案是基于 Clang 编译期插桩来获取符号，Clang 插桩可以一次获取 OC、Swift、C、block 函数符号，因此，我们采用的就是基于 Clang 插桩来实现符号收集。 1.3、Clang 插桩收集启动过程中的函数符号基于 Clang 插桩获取符号有两种实现方式： 一种是自己编写一个 Clang 插件，在 Clang 插件中我们去分析抽象语法树不同的节点，在相应的节点中插入自定义的代码用于符号收集，这种自定义 Clang 插件的方式优点是可根据自己需求进行灵活处理，缺点是通用性较差， 一种是利用 SanitizerCoverage 工具进行符号收集。 SanitizerCoverage 是 LLVM 内置的一个代码覆盖率检测工具，在编译时，它能够根据我们的编译配置，将一系列以__sanitizer_cov_trace_pc_为前缀的函数插入到我们自定义的函数内，比如，我们在Clang的自定义配置 Other C Flags中新增-fsanitize-coverage=trace-pc-guard标志时，编译器将会为每个自定义的函数中插入__sanitizer_cov_trace_pc_guard回调函数。 Clang 静态插桩收集符号的原理就是，利用编译期在每一个函数内部插入回调函数__sanitizer_cov_trace_pc_guard，我们通过实现该函数，在运行期间就能够拿到被插入该函数的原函数地址，通过函数地址解析出函数符号，从而达到收集启动过程中函数符号的目的。 因此，为了 Clang 前端能够利用 SanitizerCoverage 插入插桩函数，我们首先需要在Other C Flags 中添加-fsanitize-coverage=trace-pc-guard配置，这样在编译后，我们的自定义函数中都会被插入__sanitizer_cov_trace_pc_guard函数，然后我们需要实现该回调函数，并在回调函数内部收集原函数符号： 1234567891011//插桩的初始化方法，首次会进入到这里面void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) { static uint64_t N; if (start == stop || *start) return; for (uint32_t *x = start; x &lt; stop; x++) *x = ++N; }//每个原函数内部被插入的回调方法void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { if (!*guard) return; } 函数__sanitizer_cov_trace_pc_guard是在编译期由 Clang 插入到原函数内部的，因此__sanitizer_cov_trace_pc_guard函数算是原函数内部的一个嵌套子函数，而操作系统在执行 bl 跳转指令的时候，会先保存下一条指令地址到lr寄存器中，当__sanitizer_cov_trace_pc_guard函数执行完即执行ret指令后，需要继续回到原函数中继续执行，操作系统会去读取 LR 寄存器中的值拿到原函数的下一条待执行指令地址，这个地址可以通过下面代码来获取： 1void *PC = __builtin_return_address(0); 也就是说，在__sanitizer_cov_trace_pc_guard函数中我们可以通过 __builtin_return_address(0) 拿到原函数某条指令的地址，那我们只要再通过 dladdr() 函数就可以获取到原函数的信息，从而拿到该函数符号。 123456789101112void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { if (!*guard) return; void *PC = __builtin_return_address(0); Dl_info info; dladdr(PC, &amp;info); printf(&quot;fname=%s \\nfbase=%p \\nsname=%s\\nsaddr=%p \\n&quot;,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr); char PcDescr[1024]; printf(&quot;guard: %p %x PC %s\\n&quot;, guard, *guard, PcDescr);} 在实际的使用过程中，需要解决以下几个主要问题： 多线程问题，由于__sanitizer_cov_trace_pc_guard函数是各个方法内插入的回调函数，而原函数可能处于不同的线程中，从而造成__sanitizer_cov_trace_pc_guard函数调用的多线程问题，解决这个问题可以使用原子队列 OSAtomicEnqueue 来处理，使用原子队列之后需要在 Other C Flags 配置中修改原来的配置为如下形式： -fsanitize-coverage=func,trace-pc-guard 如果要支持 Swift 符号收集，由于 Swift 的编译前端与 OC 不同，需要在编译配置的Other Swift Flags下，新增下面配置： -sanitize-coverage=func-sanitize=undefined 使用 Cocoapods 管理的项目，存在多 target 的情况下，需要在每个 target 下都要进行上面的Other C Flags配置。 收集到启动过程中的函数符号之后，将这些符号写入到 order 文件中，并将该 order 文件的地址在 Xcode 的Order File参数下进行配置即可。 具体实施总结步骤一：添加 Build Setting 设置1Target -&gt; Build Setting -&gt; Custom Complier Flags -&gt; Other C Flags 添加 -fsanitize-coverage=func,trace-pc-guard Other Swift Flags 添加 -sanitize-coverage=func -sanitize=undefined 步骤二：添加代码添加到启动最早的那个 ViewController 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;dlfcn.h&quot;#import &lt;libkern/OSAtomic.h&gt;复制代码void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) { static uint64_t N; // Counter for the guards. if (start == stop || *start) return; // Initialize only once. printf(&quot;INIT: %p %p\\n&quot;, start, stop); for (uint32_t *x = start; x &lt; stop; x++) *x = ++N; // Guards should start from 1.}//初始化原子队列static OSQueueHead list = OS_ATOMIC_QUEUE_INIT;//定义节点结构体typedef struct { void *pc; //存下获取到的PC void *next; //指向下一个节点} Node;void __sanitizer_cov_trace_pc_guard(uint32_t *guard) { void *PC = __builtin_return_address(0); Node *node = malloc(sizeof(Node)); *node = (Node){PC, NULL}; // offsetof() 计算出列尾，OSAtomicEnqueue() 把 node 加入 list 尾巴 OSAtomicEnqueue(&amp;list, node, offsetof(Node, next));}- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { NSMutableArray *arr = [NSMutableArray array]; while(1){ //有进就有出，这个方法和 OSAtomicEnqueue() 类比使用 Node *node = OSAtomicDequeue(&amp;list, offsetof(Node, next)); //退出机制 if (node == NULL) { break; } //获取函数信息 Dl_info info; dladdr(node-&gt;pc, &amp;info); NSString *sname = [NSString stringWithCString:info.dli_sname encoding:NSUTF8StringEncoding]; printf(&quot;%s \\n&quot;, info.dli_sname); //处理c函数及block前缀 BOOL isObjc = [sname hasPrefix:@&quot;+[&quot;] || [sname hasPrefix:@&quot;-[&quot;]; //c函数及block需要在开头添加下划线 sname = isObjc ? sname: [@&quot;_&quot; stringByAppendingString:sname]; //去重 if (![arr containsObject:sname]) { //因为入栈的时候是从上至下，取出的时候方向是从下至上，那么就需要倒序，直接插在数组头部即可 [arr insertObject:sname atIndex:0]; } } //去掉 touchesBegan 方法 启动的时候不会用到这个 [arr removeObject:[NSString stringWithFormat:@&quot;%s&quot;,__FUNCTION__]]; //数组合成字符串 NSString * funcStr = [arr componentsJoinedByString:@&quot;\\n&quot;]; //写入文件 NSString * filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;link.order&quot;]; NSData * fileContents = [funcStr dataUsingEncoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;, filePath); [[NSFileManager defaultManager] createFileAtPath:filePath contents:fileContents attributes:nil];}复制代码 步骤三：取出 order file 在步骤二的代码NSLog(@&quot;%@&quot;, filePath); 断点 如果页面无法触发点击，viewDidLoad里面调用touchesBegan:withEvent:也可以 运行代码后记录 link.order 的路径 Finder 前往路径取出 order file 步骤四：设置 order file 把 link.order 的路径放到工程根目录 Target -&gt; Build Setting -&gt; Linking -&gt; Order File 设置路径 步骤五：编译代码 把步骤一 order file 的设置还原 把步骤二添加代码删除 clean 以后编译代码","link":"/2021/04/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/"},{"title":"内存泄漏","text":"我们在编写日常业务代码时，或多或少都会引入一些导致内存泄漏的代码，而这种行为又很难被监控，这就导致应用内存泄漏的口子越开越大，直接影响到线上应用的稳定性。虽然 Xcode 的 Instrucment 提供了 Leaks 和 Allocations 工具让我们能精准地定位内存泄漏问题，但是这种方式相对比较繁琐，需要开发人员频繁地去操作应用界面，以触发泄漏场景，所以 Leaks 和 Allocations 更加适合定期组织的大排查，作为监测手段，则显得笨重。 背景对于内存泄漏的监测，业内已经有了两款成熟的开源工具，分别是 PLeakSniffer 和 MLeaksFinder。PLeakSniffer 使用 Ping-Pong 方式监测对象是否存活，在进入页面时，创建控制器关联的一系列对象代理，根据这些代理在控制器销毁时能否响应 Ping 判断代理对应的对象是否泄漏。MLeaksFinder 则是在控制器销毁时，延迟 3s 后再向监测对象发送消息，根据监测对象能否响应消息判断其是否泄漏。这两个方案基本能覆盖大部分对象泄漏或者延迟释放了的场景，考虑到性能损耗以及内存占用因素，我偏向于第二种方案。 下面说下在实际试用这两款工具后，我遇到的部分问题。 首先是 MLeaksFinder ： 没有处理集合对象 没有处理对象持有的属性 每个对象都触发 3s 延迟机制，没有缓存后统一处理 检测结果输出分散 然后是 PLeakSniffer ： 没有处理集合对象 处理对象持有属性时，系统类过滤不全面 处理对象持有属性时，通过 KVC 访问属性导致一些懒加载的触发 无法处理未添加到视图栈中的泄漏视图 检测结果输出分散 对于检测到泄漏对象的交互处理，两者都提供了终端 log 输出和 alert 提示功能，MLeaksFinder 甚至可以直接通过断言中断应用。这种提示在开发阶段尚可接受，但是在提测阶段，强交互会给测试人员造成困扰。至于为什么在提测阶段还要集成泄漏监测工具，主要有两个原因： 应用功能过多的情况下，开发人员无法兼顾到老页面，一些老页面的泄漏场景可以通过测试人员在测试时触发，收集之后再统一处理 在组件化开发环境下，开发人员可能并没有集成泄漏监测工具，这种情况下，需要在提测阶段统一收集没有解决的泄漏问题 所以我目前对于监测输出的诉求有两点： 开发时，通过终端日志提示开发者出现了内存泄漏 提测时，收集内存泄漏的信息并上传至效能后台，周会时统一分配处理 下面就针对这些调研和需求，打造一个符合自身业务场景的泄漏监测轮子。 监测入口和 MLeaksFinder 一样，我选择延迟 3s 的机制来判断对象是否泄漏，但是实现的细节略有差别。 首先，监测入口变更为 viewDidDisappear: 方法，我们只需在控制器被父控制器中移除或者被 Dismissed 时，触发监测动作即可： 123456789- (void)LeaksMonitor_viewDidDisappear:(BOOL)animated { [self LeaksMonitor_viewDidDisappear:animated]; if (![self isMovingFromParentViewController] &amp;&amp; ![self isBeingDismissed]) { return; } [[TDFLeaksMonitor shared] detectLeaksForObject:self];} 在我们的应用中，还有一种监测入口出现在变更根控制器时，由于直接设置根控制器不会触发 viewDidDisappear 方法，所以需要另外设置 ： 1234567- (void)LeaksMonitor_setRootViewController:(UIViewController *)rootViewController { if (self.rootViewController &amp;&amp; ![self.rootViewController isEqual:rootViewController]) { [[TDFLeaksMonitor shared] detectLeaksForObject:self.rootViewController]; } [self LeaksMonitor_setRootViewController:rootViewController];} 接着，为了能够统一处理控制器及其持有对象，我们可以像 PLeakSniffer 一样，给每个对象包装一层代理 ： 123456@interface TDFLeakObjectProxy : NSObject// 持有 target 的对象弱引用@property (weak, nonatomic) id host;// 被 host 持有的对象弱引用@property (weak, nonatomic, readonly) id target;@end 只要 host 释放了而 target 没释放，则视 target 已泄漏，如果 host 未释放，则不检测 target。然后使用一个 collector 去收集这些对象对应的 proxy ，在收集完之后统一监测 collector 中的所有 proxy ，这样就可以在一个控制器监测完成后，统一上传监测出的泄漏点了 ： 123456789101112- (void)detectLeaksForObject:(id &lt;TDFLeakObjectProxyCollectable&gt;)object { // 收集控制器关联的所有 proxy // 收集之后再统一处理，避免对每一个对象都进行 3s 检测 TDFLeakObjectProxyCollector *collector = [[TDFLeakObjectProxyCollector alloc] init]; TDFLeakContext *context = [[TDFLeakContext alloc] init]; context.host = object; (void)[object LeaksMonitor_collectProxiesForCollector:collector withContext:context]; // 检测 3s 之后，collector 中的所有 proxy 是否正常 [self detectProxyCollector:collector];} 收集对象信息因为要对不同的类做特异化处理，所以这里我们先定义一个协议，通过这个协议中的 collect 方法去收集不同类实例化对象的 proxy ： 123456789@protocol TDFLeakObjectProxyCollectable &lt;NSObject&gt;/** 收集对象及其名下的所有成员变量对应的 proxy @param collector 收集器，存储 proxy @param ctx 上下文 */- (void)LeaksMonitor_collectProxiesForCollector:( TDFLeakObjectProxyCollector * _Nonnull )collector withContext:( TDFLeakContext * _Nullable )ctx;@end 这里的关键点在于如何让 NSObject 实现此协议，主要有四个步骤 ： 过滤系统类调用 向 collector 添加封装的 proxy 循环遍历对象对应的非系统类 / 父类属性，找出 copy / strong 类型属性，并获取其对应的成员变量值 向收集的所有成员变量对象发送 collect 方法 NSObject 实现 collect 协议方法后，其子类就可以通过这个方法递归地收集名下需要监测的属性信息。比如对于集合类型 NSArray ，实现协议方法如下，表示收集自身和每个集合元素的信息，不过由于 NSArray 是系统类，所以其实例化对象并不会被收集进 collector ，如果要收集系统类的属性信息，只能通过让系统类实现协议并重载 collect 方法，手动向属性值发送 collect 消息实现，UIViewController 的 childViewControllers、presentedViewController、view 属性也同理 ： 123456789- (void)LeaksMonitor_collectProxiesForCollector:(TDFLeakObjectProxyCollector *)collector withContext:(TDFLeakContext *)ctx { [super LeaksMonitor_collectProxiesForCollector:collector withContext:ctx]; [self enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj conformsToProtocol:@protocol(TDFLeakObjectProxyCollectable)]) { [obj LeaksMonitor_collectProxiesForCollector:collector withContext:LM_CTX_D(ctx, @&quot;contains&quot;)]; } }];} 需要注意的是，直接调用属性的 getter 方法获取属性值，可能会触发属性懒加载，导致出现意料之外的问题 (比如调用 UIViewController 的 view 会触发 viewDidLoad)，所以要通过 object_getIvar 去获取属性对应的成员变量值。当然，这种处理方式会导致无法收集某些没有对应成员变量值的属性，比如关联对象、控制器的 view 等属性，权衡利弊之后，我还是选择忽略这种属性的监测。 除了收集必要的对象信息之外，我还记录了监测对象的引用路径信息，也就是上面 LM_CTX_D 宏做的事情。有些情况下，对象的引用路径能帮助我们发现，路径上的哪些操作导致了对象的泄漏，特别是在网页上浏览泄漏信息时，如果只有泄漏对象类和引用泄漏对象类两个信息，脱离了对象泄漏时的上下文环境，会增加修复的难度。有了引用路径信息后，输出的泄漏信息如下 ： 12345[ O : TDFViewController.view-&gt;UIView.subviews-&gt;__NSArrayM(contains)-&gt;A.subviews-&gt;__NSArrayM(contains)-&gt;O TDFViewController : TDFViewController.childViewControllers-&gt;TDFViewController __NSCFTimer : TDFViewController.timer-&gt;__NSCFTimer] 过滤系统类系统类信息并不是我们应该关心的，过滤掉并不会影响到最终的监测结果。目前我尝试了两种方式来确定一个类是否为系统类： 通过类所在 NSBundle 的路径 通过类所在地址 先说第一种，这种方式逻辑较为简单，代码如下： 12345678910111213BOOL LMIsSystemClass(Class cls) { NSBundle *bundle = [NSBundle bundleForClass:cls]; if ([bundle isEqual:[NSBundle mainBundle]]) { return NO; } static NSString *embededDirPath; if (!embededDirPath) { embededDirPath = [[NSBundle mainBundle].bundleURL URLByAppendingPathComponent:@&quot;Frameworks&quot;].absoluteString; } return ![bundle.bundlePath hasPrefix:embededDirPath];} 应用的主二进制文件，和开发者添加的 embeded frameworks 都会在固定的文件目录下，所以直接比对路径前缀即可。 接下来说说第二种，这种方式的实现步骤如下： 遍历所有的 image ，通过 image 的名称判断是否为系统 image 缓存所有系统 image 的起始位置，也就是 mach_header 的地址 判断类是否为系统类时，使用 dladdr 函数获取类所在 image 的信息，通过 dli_fbase 字段获取起始地址 比对 image 的起始地址得知是否为系统类 实际尝试下来后，发现第二种方式耗时会比第一种多，dladdr 函数占用了大部分时间（内部会遍历所有 image 的开始结束地址，和传入的地址进行比对），所以最终选择了第一种方式作为判断依据。 过滤系统类时，针对那种会自泄漏的对象，需要进行特殊处理，不予过滤。比如 NSTimer / CADisplayLink 对象的常见内存泄漏场景，除了 target 强引用控制器造成循环引用域外，还有一种是打破了循环引用但没有在控制器销毁时执行 invalidate 操作，因为 NSTimer 由 RunLoop 持有，不手动停止的情况下，就会造成泄漏。 局限性基于延时的内存泄漏监测机制虽然适用于大部分视图、控制器和一般属性的泄漏场景，但是还有少部分情况，这种机制无法处理，比如单例对象和共享对象。 首先说下单例对象，假设有 singleton 属性，其 getter 方法返回 Singleton 单例，这时延时监测机制无法自动过滤这种情况，依然会认为 singleton 泄漏了。有一种检测属性返回值是否为单例的方法，就是向返回值对应类发送 init 或者 share 相关方法，通过方法返回值和属性返回值的对比结果来判断，但是事实上我们无法确定业务方的单例是否重写了 init，也无法获知具体的单例类方法，所以这种方案适用面比较局限。单例对象的处理，目前还是通过白名单的方式处理较为稳妥。 共享对象的应用场景就比较普遍了，比如现有 A，B 页面，A 页面持有模型 M ，在跳转至 B 页面时，会将 M 传递给 B ，B 强引用了 M ，当 B 销毁时， M 不会销毁，而 M 又是 B 某个属性的值，所以监测机制会判断 M 泄漏了，实际上 M 只是 A 传递给 B 的共享对象。在一个控制器做完检测就需要上传至效能后台的情况下，共享对象还没有很好的处理方法，后期考虑结合 FBRetainCycleDetector 查找泄漏对象的循环引用信息，然后一并上传至效能后台，方便排查这种情况。因为每次 pop 都使用 FBRetainCycleDetector 检测控制器会比较耗时、甚至会造成延迟释放和卡顿，所以先用延时机制找出潜在的泄漏对象，再使用 FBRetainCycleDetector 检测这些泄漏对象，能极大得减少需要处理的对象数量。最终网页呈现的效果如下： 小结像内存泄露这种问题，最好在应用初期就开始着手监测和解决，否则当应用功能代码逐渐增多后，回过头来处理这种问题费时费力，还是比较麻烦的。 本文基于 PLeakSniffer 和 MLeaksFinder 监测工具的基础上，结合团队业务情况，进行了一些的改造，添加了集合对象的处理、引用路径的记录、对象的统一检测等功能，优化了部分有问题的代码，在一定程度上提升了延时机制的可用性。","link":"/2020/06/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"title":"内存泄漏检测工具","text":"我们在编写日常业务代码时，或多或少都会引入一些导致内存泄漏的代码，而这种行为又很难被监控，这就导致应用内存泄漏的口子越开越大，直接影响到线上应用的稳定性。虽然 Xcode 的 Instrucment 提供了 Leaks 和 Allocations 工具让我们能精准地定位内存泄漏问题，但是这种方式相对比较繁琐，需要开发人员频繁地去操作应用界面，以触发泄漏场景，所以 Leaks 和 Allocations 更加适合定期组织的大排查，作为监测手段，则显得笨重。 背景对于内存泄漏的监测，业内已经有了两款成熟的开源工具，分别是 PLeakSniffer 和 MLeaksFinder。PLeakSniffer 使用 Ping-Pong 方式监测对象是否存活，在进入页面时，创建控制器关联的一系列对象代理，根据这些代理在控制器销毁时能否响应 Ping 判断代理对应的对象是否泄漏。MLeaksFinder 则是在控制器销毁时，延迟 3s 后再向监测对象发送消息，根据监测对象能否响应消息判断其是否泄漏。这两个方案基本能覆盖大部分对象泄漏或者延迟释放了的场景，考虑到性能损耗以及内存占用因素，我偏向于第二种方案。 下面说下在实际试用这两款工具后，我遇到的部分问题。 首先是 MLeaksFinder ： 没有处理集合对象 没有处理对象持有的属性 每个对象都触发 3s 延迟机制，没有缓存后统一处理 检测结果输出分散 然后是 PLeakSniffer ： 没有处理集合对象 处理对象持有属性时，系统类过滤不全面 处理对象持有属性时，通过 KVC 访问属性导致一些懒加载的触发 无法处理未添加到视图栈中的泄漏视图 检测结果输出分散 对于检测到泄漏对象的交互处理，两者都提供了终端 log 输出和 alert 提示功能，MLeaksFinder 甚至可以直接通过断言中断应用。这种提示在开发阶段尚可接受，但是在提测阶段，强交互会给测试人员造成困扰。至于为什么在提测阶段还要集成泄漏监测工具，主要有两个原因： 应用功能过多的情况下，开发人员无法兼顾到老页面，一些老页面的泄漏场景可以通过测试人员在测试时触发，收集之后再统一处理 在组件化开发环境下，开发人员可能并没有集成泄漏监测工具，这种情况下，需要在提测阶段统一收集没有解决的泄漏问题 所以我目前对于监测输出的诉求有两点： 开发时，通过终端日志提示开发者出现了内存泄漏 提测时，收集内存泄漏的信息并上传至效能后台，周会时统一分配处理 下面就针对这些调研和需求，打造一个符合自身业务场景的泄漏监测轮子。 监测入口和 MLeaksFinder 一样，我选择延迟 3s 的机制来判断对象是否泄漏，但是实现的细节略有差别。 首先，监测入口变更为 viewDidDisappear: 方法，我们只需在控制器被父控制器中移除或者被 Dismissed 时，触发监测动作即可： 123456789- (void)LeaksMonitor_viewDidDisappear:(BOOL)animated { [self LeaksMonitor_viewDidDisappear:animated]; if (![self isMovingFromParentViewController] &amp;&amp; ![self isBeingDismissed]) { return; } [[TDFLeaksMonitor shared] detectLeaksForObject:self];} 在我们的应用中，还有一种监测入口出现在变更根控制器时，由于直接设置根控制器不会触发 viewDidDisappear 方法，所以需要另外设置 ： 1234567- (void)LeaksMonitor_setRootViewController:(UIViewController *)rootViewController { if (self.rootViewController &amp;&amp; ![self.rootViewController isEqual:rootViewController]) { [[TDFLeaksMonitor shared] detectLeaksForObject:self.rootViewController]; } [self LeaksMonitor_setRootViewController:rootViewController];} 接着，为了能够统一处理控制器及其持有对象，我们可以像 PLeakSniffer 一样，给每个对象包装一层代理 ： 123456@interface TDFLeakObjectProxy : NSObject// 持有 target 的对象弱引用@property (weak, nonatomic) id host;// 被 host 持有的对象弱引用@property (weak, nonatomic, readonly) id target;@end 只要 host 释放了而 target 没释放，则视 target 已泄漏，如果 host 未释放，则不检测 target。然后使用一个 collector 去收集这些对象对应的 proxy ，在收集完之后统一监测 collector 中的所有 proxy ，这样就可以在一个控制器监测完成后，统一上传监测出的泄漏点了 ： 123456789101112- (void)detectLeaksForObject:(id &lt;TDFLeakObjectProxyCollectable&gt;)object { // 收集控制器关联的所有 proxy // 收集之后再统一处理，避免对每一个对象都进行 3s 检测 TDFLeakObjectProxyCollector *collector = [[TDFLeakObjectProxyCollector alloc] init]; TDFLeakContext *context = [[TDFLeakContext alloc] init]; context.host = object; (void)[object LeaksMonitor_collectProxiesForCollector:collector withContext:context]; // 检测 3s 之后，collector 中的所有 proxy 是否正常 [self detectProxyCollector:collector];} 收集对象信息因为要对不同的类做特异化处理，所以这里我们先定义一个协议，通过这个协议中的 collect 方法去收集不同类实例化对象的 proxy ： 123456789@protocol TDFLeakObjectProxyCollectable &lt;NSObject&gt;/** 收集对象及其名下的所有成员变量对应的 proxy @param collector 收集器，存储 proxy @param ctx 上下文 */- (void)LeaksMonitor_collectProxiesForCollector:( TDFLeakObjectProxyCollector * _Nonnull )collector withContext:( TDFLeakContext * _Nullable )ctx;@end 这里的关键点在于如何让 NSObject 实现此协议，主要有四个步骤 ： 过滤系统类调用 向 collector 添加封装的 proxy 循环遍历对象对应的非系统类 / 父类属性，找出 copy / strong 类型属性，并获取其对应的成员变量值 向收集的所有成员变量对象发送 collect 方法 NSObject 实现 collect 协议方法后，其子类就可以通过这个方法递归地收集名下需要监测的属性信息。比如对于集合类型 NSArray ，实现协议方法如下，表示收集自身和每个集合元素的信息，不过由于 NSArray 是系统类，所以其实例化对象并不会被收集进 collector ，如果要收集系统类的属性信息，只能通过让系统类实现协议并重载 collect 方法，手动向属性值发送 collect 消息实现，UIViewController 的 childViewControllers、presentedViewController、view 属性也同理 ： 123456789- (void)LeaksMonitor_collectProxiesForCollector:(TDFLeakObjectProxyCollector *)collector withContext:(TDFLeakContext *)ctx { [super LeaksMonitor_collectProxiesForCollector:collector withContext:ctx]; [self enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if ([obj conformsToProtocol:@protocol(TDFLeakObjectProxyCollectable)]) { [obj LeaksMonitor_collectProxiesForCollector:collector withContext:LM_CTX_D(ctx, @&quot;contains&quot;)]; } }];} 需要注意的是，直接调用属性的 getter 方法获取属性值，可能会触发属性懒加载，导致出现意料之外的问题 (比如调用 UIViewController 的 view 会触发 viewDidLoad)，所以要通过 object_getIvar 去获取属性对应的成员变量值。当然，这种处理方式会导致无法收集某些没有对应成员变量值的属性，比如关联对象、控制器的 view 等属性，权衡利弊之后，我还是选择忽略这种属性的监测。 除了收集必要的对象信息之外，我还记录了监测对象的引用路径信息，也就是上面 LM_CTX_D 宏做的事情。有些情况下，对象的引用路径能帮助我们发现，路径上的哪些操作导致了对象的泄漏，特别是在网页上浏览泄漏信息时，如果只有泄漏对象类和引用泄漏对象类两个信息，脱离了对象泄漏时的上下文环境，会增加修复的难度。有了引用路径信息后，输出的泄漏信息如下 ： 12345[ O : TDFViewController.view-&gt;UIView.subviews-&gt;__NSArrayM(contains)-&gt;A.subviews-&gt;__NSArrayM(contains)-&gt;O TDFViewController : TDFViewController.childViewControllers-&gt;TDFViewController __NSCFTimer : TDFViewController.timer-&gt;__NSCFTimer] 过滤系统类系统类信息并不是我们应该关心的，过滤掉并不会影响到最终的监测结果。目前我尝试了两种方式来确定一个类是否为系统类： 通过类所在 NSBundle 的路径 通过类所在地址 先说第一种，这种方式逻辑较为简单，代码如下： 12345678910111213BOOL LMIsSystemClass(Class cls) { NSBundle *bundle = [NSBundle bundleForClass:cls]; if ([bundle isEqual:[NSBundle mainBundle]]) { return NO; } static NSString *embededDirPath; if (!embededDirPath) { embededDirPath = [[NSBundle mainBundle].bundleURL URLByAppendingPathComponent:@&quot;Frameworks&quot;].absoluteString; } return ![bundle.bundlePath hasPrefix:embededDirPath];} 应用的主二进制文件，和开发者添加的 embeded frameworks 都会在固定的文件目录下，所以直接比对路径前缀即可。 接下来说说第二种，这种方式的实现步骤如下： 遍历所有的 image ，通过 image 的名称判断是否为系统 image 缓存所有系统 image 的起始位置，也就是 mach_header 的地址 判断类是否为系统类时，使用 dladdr 函数获取类所在 image 的信息，通过 dli_fbase 字段获取起始地址 比对 image 的起始地址得知是否为系统类 实际尝试下来后，发现第二种方式耗时会比第一种多，dladdr 函数占用了大部分时间，所以最终选择了第一种方式作为判断依据。 过滤系统类时，针对那种会自泄漏的对象，需要进行特殊处理，不予过滤。比如 NSTimer / CADisplayLink 对象的常见内存泄漏场景，除了 target 强引用控制器造成循环引用域外，还有一种是打破了循环引用但没有在控制器销毁时执行 invalidate 操作，因为 NSTimer 由 RunLoop 持有，不手动停止的情况下，就会造成泄漏。 局限性基于延时的内存泄漏监测机制虽然适用于大部分视图、控制器和一般属性的泄漏场景，但是还有少部分情况，这种机制无法处理，比如单例对象和共享对象。 首先说下单例对象，假设有 singleton 属性，其 getter 方法返回 Singleton 单例，这时延时监测机制无法自动过滤这种情况，依然会认为 singleton 泄漏了。有一种检测属性返回值是否为单例的方法，就是向返回值对应类发送 init 或者 share 相关方法，通过方法返回值和属性返回值的对比结果来判断，但是事实上我们无法确定业务方的单例是否重写了 init，也无法获知具体的单例类方法，所以这种方案适用面比较局限。单例对象的处理，目前还是通过白名单的方式处理较为稳妥。 共享对象的应用场景就比较普遍了，比如现有 A，B 页面，A 页面持有模型 M ，在跳转至 B 页面时，会将 M 传递给 B ，B 强引用了 M ，当 B 销毁时， M 不会销毁，而 M 又是 B 某个属性的值，所以监测机制会判断 M 泄漏了，实际上 M 只是 A 传递给 B 的共享对象。在一个控制器做完检测就需要上传至效能后台的情况下，共享对象还没有很好的处理方法，后期考虑结合 FBRetainCycleDetector 查找泄漏对象的循环引用信息，然后一并上传至效能后台，方便排查这种情况。因为每次 pop 都使用 FBRetainCycleDetector 检测控制器会比较耗时、甚至会造成延迟释放和卡顿，所以先用延时机制找出潜在的泄漏对象，再使用 FBRetainCycleDetector 检测这些泄漏对象，能极大得减少需要处理的对象数量。最终网页呈现的效果如下： 小结像内存泄露这种问题，最好在应用初期就开始着手监测和解决，否则当应用功能代码逐渐增多后，回过头来处理这种问题费时费力，还是比较麻烦的。 本文基于 PLeakSniffer 和 MLeaksFinder 监测工具的基础上，结合团队业务情况，进行了一些的改造，添加了集合对象的处理、引用路径的记录、对象的统一检测等功能，优化了部分有问题的代码，在一定程度上提升了延时机制的可用性。","link":"/2020/01/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"},{"title":"动态库与静态库","text":"dymanic framework原因在iOS8以前,苹果只允许发布静态库,当然cocoapods只支持静态库,但是在iOS8苹果推出了APP extension的概念,可以对项目进行扩展,感兴趣的可以看APP extension. 因为APP extension和主项目是两个独立的进程,为了共享代码,苹果允许我们创建动态库,即dynamic framework. swift第三方库在swift语言日益优化的前提下,我们想要进行项目swift化,但是在Xcode 6.0 Beta 4的 Release Notes 中，可以找到这句话： Xcode does not support building ``static libraries that include Swift code. (17181019) 动态库导致的static library报错看了上面的原因,你会问pod直接使用动态库不就好了,但是对于pod来说,有这么几个问题 包含静态库报错 The 'xxx' target has transitive dependencies that include static binaries 动态库不能依赖静态库 ok,介绍完历史原因,我们继续看,在讲解适配前,先了解几个概念. 基础介绍项目都使用cocoapods进行第三方库的管理,pod可以实现依赖管理,版本控制等功能,对于主项目X依赖A,A内部A-&gt;B,A-&gt;C,B→D,这类的依赖情况,主项目只需要引入A,在安装时就会检测其他的依赖pod是否存在,不存在进行安装. pod的管理,使得项目中同一类的库只存在一份,cocoapods的项目可以静态库 动态库二选其一,关于这两种的区别下面会做详细解释 默认使用静态库管理,如果想改为动态,需要在podfile内部添加use_frameworks!字段,该字段告诉pod,使用框架的方式,安装和管理第三方库 静态库不能包含swift文件,pod将第三方编译为static library,不能支持swift语言,新版的改为了framework的形式,下面介绍library和framework的区别. library和frameworklibrary仅能包含编译后的代码,即.a文件,不能包含其他的资源文件. 但是我们封装的第三方库,有时需要包含.h文件,.nib文件,图片,文档扥g framework可以包含以上所有类型.且支持包含swift代码. framework支持iOS8以后,而static library可以追溯到iOS6. 由于 iOS 的沙盒机制,自己创建的 Framework 和系统Framework 不同,App 中使用的 Framework 运行在沙盒里,而不是系统中.每个 App 都只能用自己对应签名的动态库,做不到多个 App 使用一个动态库 区别总结动态库和静态库的区别如下 动态库 静态库 命名空间 有单独的命名空间,不同库同名文件不会冲突 使用import&lt;XXX/xxx.h&gt;的方式引入 没有单独命名空间,同名文件冲突 引入方式import”xxx.h” 加载时机 在启动时加载,加载时间较长 构建时加载 依赖关系 可以依赖动态库,不能依赖静态库 可以依赖动态库和静态库 是否能使用swift 可以包含swift文件 在cocoapods1.4.0之后,可以使用use_framework!的方式包含swift文件 framework支持static_framework 原理分析上面的总结我们知道静态库在程序启动时被加载,动态库在使用时被加载 那么这些区别原理何在呢,下面分析下几个概念: 编译,目标文件,符号表,链接编译: 编译器生成机器代码,生成目标文件. 目标文件包含两种符号表: 1.文件转换后的符号(名称和方法的地址及偏移量) 2.未确定的符号(需要在链接阶段才能解析完成的机器代码) 目标文件包含名为”main”的符号,可以将代码块加载进RAM运行.并将”main”作为符号表的运行入口的初始位置 链接: 将我们的各种目标文件加上一些第三方库，和系统库链接为可执行文件 链接主要决议符号,也就是变量函数等的地址 若符号来⾃静态库(本质就是.o 的集合包)或 .o，将其纳⼊链接产物，并确定符号地址 若符号来⾃动态库，打个标记，等启动的时候再说—交给 dyld 去加载和链接符号 于是链接加装载就有了不同的情况 Load 装载：将库⽂件载⼊内存 Static Loading：启动时 Dynamic Loading：启动后（使⽤时） Link 链接：决议符号地址 Static Linking：构建（链接）时 Dynamic Linking：运⾏时（启动时或使⽤时） 静态,共享和动态库静态库只是目标文件的集合.静态库只是为了方便处理大量文件.链接器只选取需要的文件并将它们写入最终代码块,这使得静态链接程序很大.( This makes statically linked programs pretty large.) 共享和动态库只需要被系统加载一次.然后使用该库的工程只需要对其进行引用即可.共享和动态库有两种创建方式 1.全量的链接对象文件,包含大量的可被调用的符号表(真实的库代码) 2.通过”stub”对象文件,包含可调用方法的映射表(jump table) 通过动态库链接时,stub对象文件是通过类似静态库的形式被加载到程序中的.但是方法只是加载了方法声明. 当程序使用动态库加载时,系统需要额外链接存储在RAM中的共享库.在加载系统共享库的stub文件时有个实现技巧.有两种方式可以实现加载系统共享库,1.系统拦截调用,进入系统,修改项目地址的上下文,转换到共享库,工作量很大.另一种方式,将静态库映射到运行程序通过虚拟内存管理的地址空间,这使得共享库对于多个项目来说,只是项目的一部分,虽然只在内存中短暂存在. 这样的话,代码被共享,但是每个程序的堆栈由自己管理,使得各个程序员直接完全独立. 结果静态库:稳定,但是占用内存空间. 动态库:从系统加载代码,共享代码节约空间,但是可以会导致运行时的错误,且不易定位和修复. 动态库详解苹果官方关于动态库的描述: 动态库相比静态库,减少了app可执行文件的大小.并且可以只在使用时,按需加载而不是在启动时加载.这个特性减低了启动时间,并且更优秀的利用了内存. 动态库不能依赖静态库 启动时间过长解决办法 第三方框架swift-staticlibs,集成的为动态库,在构建阶段,转为静态库加载的形式,这样做的原因: Xcode的static library不能包含swift 动态库启动时间过长 使用static framework的方式,下面会做介绍 静态库详解我们可以在Build Setting里面通过Mach-O Type查看target的动态或者静态状态 [图片上传失败…(image-28b016-1519821296948)] cocoapods1.4.0对于static framework的支持static frameworkpod在1.4.0之后提供了静态框架的特性.过去的ues_framework!只能发布动态库,现在可以发布静态的框架.这一特性解决了过去动态框架不能依赖静态库的弊端.现在的静态framework也可以依赖静态库,也可以依赖通过vendored_frameworks发布的第三方框架. 补充,vendored_frameworks和vendored_library是在podspec文件内使用的属性,用法是声明包含的第三方framework和library. 背景 static framework和library有什么区别呢? framework是对于library,头文件和资源等内容的封装.library可以是动态或者静态的,静态库在构建时期链接,但是动态库是在运行时才进行加载. 动态库不能依赖静态库是因为静态库不需要在运行时再次加载,如果多个动态库依赖同一个静态库,会出现多个静态库的拷贝,而这些拷贝本身只是对于内存空间的消耗. 另一个历史原因是,过去很多库是通过包含静态库的vendored_framework形式发布的. 在1.4.0之前,资源只能通过动态库的方式构建,所以不能依赖vendored_framework的库.而且对于vendored_framework的二进制库,无法在转换成资源pod时仍保持动态性 以上原因,使得pod在1.4.0提供了静态框架的支持.用法简单,只需要在podspec文件内,声明如下即可 1s.static_framework = true 限制所有swift库需要保持一致的版本,包含Swift文件的framework,必须指定swift的版本号,pod之后提供了新特性pod制定swift版本范围 1234567891011`Pod::Spec.``new` `do` `|s|``s.name = ``'BanannaLib'``s.version = ``'1.0.0'``s.swift_version = ``'&gt;= 3.2'``s.source_files = ``'**/*.swift'``end` 支持包含swift文件在创建私有pod时,如果项目中包含swift文件,需要在podfile内部添加use_framework!字段,如果不添加会报以下错误 1[!] Pods written in Swift can only be integrated as frameworks; add `use_frameworks!` to your Podfile or target to opt into using it. The Swift Pod being used is: erp-boss-common-ios 如果框架已经声明了static_framework = true,则可以包含swift文件,且可以依赖其他的静态库. 苹果官方的Xcode9发布文档有以下说明Xcode release文档 1Xcode supports static library targets which contain Swift code. Debugging applications that use Swift static libraries may require a complete set of build artifacts that are in their original location. (``33297067``)` Xcode支持包含swift代码的静态库项目. tips:包含.a的static library,可以用lipo查看.a库所支持的架构. 123lipo -info libTestLib.a Architectures in the fat file: libTestLib.a are: armv7 i386 x86_64 arm64 静态库报错错误在我们使用use_frameworks!的时候,会遇到类似于下面的错误提示,引起这种提示的原因,和各种情况,下面分析一下. 1[!] The 'Pods-testDynamic_Example'` `target has transitive dependencies that include static binaries: (/Users/zhaoyanan/Documents/projects/pod/testDynamic/Example/Pods/SAKC-Ares/lib/libcares_iOS.a) boss-&gt;A-&gt;B-&gt;SL(static library) boss为主项目 SL为包含.a的静态库 boss-&gt;SL,没有问题 在B内增加static_framework = true, 可以解决boss-&gt;B-&gt;C问题 对于boss-&gt;A-&gt;B-&gt;C的情况,如果A,A’,A’’都依赖了B,需要保证他们依赖的方式相同,即都不指定版本号,都在都指定特定的版本号,或者都指定相同的范围,声明不同,则会报错. s.static_framework = true, s.subspec不需要再设置 其他方法有一种做法,可以作为参考,没有测试,对于A-&gt;B-&gt;C-SL的情况十是否使用也不可知,感兴趣的可以研究下 123456789101112131415161718192021A库依赖B库为例,B库中有一个静态库libB.a :在A库中修改.podspec :s.pod_target_xcconfig = {'FRAMEWORK_SEARCH_PATHS'`=&gt;'$(inherited) $(PODS_ROOT)/Crashlytics','OTHER_LDFLAGS' =&gt; '$(inherited) -undefined dynamic_lookup'}， 然后在Podfile中添加hook：pre_install do |installer|# workaround ``for` `https:``//github.com/CocoaPods/CocoaPods/issues/3289def installer.verify_no_static_framework_transitive_dependencies; endend 新特性在pod1.5.0之后,安装包含swift第三方库的时候,不限制必须在podfile内声明use_frameworks!.但是,如果swift库依赖OC库,就需要在OC库内允许modular headers Modular HeadersCocoaPods在创建之初,就致力于封装尽可能多的第三方库.pod管理了第三方库的头文件搜索路径(header search paths).pod允许任意pod之间的相互引用,不需要考虑命名空间,不用制定import &lt;nameSpace/fileName&gt;. 例如B库使用#import”A.h”的,pod会配置对应的build setting来保证这种引入的可行.但是如果在其他库内增加了module maps,这种引用就会找不到文件.pod尝试自动去管理静态库的module maps,但是因为这样破坏了pod的使用方式,没有进行下去. 说一下 module maps 在XCode的build setting内,Packaging内有以下设置module map的选项 Defines Module (DEFINES_MODULE) : 如果设置为YES,会认为项目自定义自己的组件,允许项目通过组件的方式引入 Module Map File (MODULEMAP_FILE) 用来管理LLVM的module map,定义编译器组件结构.如果defines module为YES的时候,如果Module Map File没填,会自动生成. 在pod1.5.0版本中,通过直接import和组件导入都能找到文件.对于pod开发者,可以在pod_target_xcconfig内添加'DEFINES_MODULE' =&gt; 'YES'.对于使用者,可以在podfile内添加use_modular_headers!允许直接import和module map.也可以通过:modular_headers =&gt; true配置特定的pod.","link":"/2018/08/05/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/"},{"title":"动态库懒加载","text":"1、动态库懒加载我们知道，pre-main 过程中，有dylib的加载步骤，而动态库加载是需要耗时的，苹果建议我们自定义的动态库不要超过 6 个，因此，尽量减少启动过程中的动态库加载有助于启动耗时的优化。减少启动过程中的动态库加载主要有以下两个方案： 一个是动态库转静态库； 一个是多个动态库进行合并； 1.1、动态库懒加载方案所谓动态库懒加载是指，在启动的过程中并不加载该动态库，而是在业务真正使用到该动态库中的内容时才进行加载，从而减少启动耗时。在 Cocoapods 1.2 之前存在配置动态库懒加载的入口，升级到 1.8 之后没有了动态库懒加载的配置入口，我们需要在pod install之后生成的配置文件中进行配置。使用 Cocoapods 管理的项目，在pod install之后，会生成Pods-xxx-frameworks.sh和Pods-xxx.adhoc/debug/release.xcconfig这两个文件，其中Pods-xxx-frameworks.sh文件脚本负责架构剔除和重签名等功能，而Pods-xxx.adhoc/debug/release.xcconfig文件则负责静态库和动态库的链接配置，我们自定义的动态库想要进行懒加载，只需要修改xxx.xcconfig配置文件，将需要懒加载的动态库从配置文件中移除，这样保证懒加载的动态库参与签名和拷贝，但是不参与链接。 1.2、动态库懒加载后的调用方式由于采用动态库懒加载后动态库在编译时没有参与链接，原有的代码调用方式会报找不到对应动态库符号的错误，因此，原有动态库的调用方式需要修改成Runtime动态调用的形式 正常动态库都是会被主二进制直接或者间接链接的，那么这些动态库会在启动的时候加载。如果只打包进 App，不参与链接，那么启动的时候就不会自动加载，在运行时需要用到动态库里面的内容的时候，再手动懒加载。 懒加载动态库需要在编译期和运行时都进行改造，编译期的架构： 像 A.framework 等动态库是懒加载的，因为并没有参与主二进制的直接 or 间接链接。动态库之间一定会有一些共同的依赖，把这些依赖打包成 Shared.framework 解决公共依赖的问题。 运行时通过-[NSBundle load]来加载，本质上调用的是底层的 dlopen。那么什么时候触发动态库手动加载呢？ 动态库可以分成两种：业务和功能。业务就是 UI 的入口，可以把动态库加载的逻辑收敛到路由内部，这样外部其实并不知道动态库是懒加载的，也能更好地容错。功能库（比如上图的 QR.framework）会有些不一样，因为没有 UI 等入口，需要功能库自己维护 Wrapper： App 对 Wrapper 直接依赖，这样外部并不知道这个动态库是懒加载的 Wrapper 内部封装了动态调用逻辑，动态调用指的是通过 dlsym 等方式调用 动态库懒加载除了启动加载的代码减少，还能长期防止业务增加代码引起启动劣化，因为业务的初始化在第一次访问的时候完成的。 这个方案还有其他优点，比如动态库化后本地编译时间会大幅度降低，对其他性能指标也有好处，缺点是会牺牲一定程度的包大小，但可以用段压缩等方式优化懒加载的动态库来打平这部分损耗。 启动阶段 ![image-20230227114633430](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227114633430.png) ![image-20230227122559375](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227122559375.png) ![image-20230227122716726](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227122716726.png![image-20230227123220049](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227123220049.png) 在运行时按需加载： dlopen：传入动态库的路径，加载成功会返回动态库在内存中的句柄。 dlerror：获取失败信息。 懒加载的动态库不能直接通过类或方法调用动态库中的逻辑。 因为： 1、没有依赖关系，2、不知道动态库是否加载，相关的类是否在内存中。 所以：需要将动态库对外提供的能力进行逻辑出口，使用特定的协议和实现，在组件化框架在调用接口的时候尝试去加载动态库。组件化框架则需要通过NSClassFromString方法的返回值来判断类和动态库是否已加载。 防劣化![image-20230227120616813](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227120616813.png) 1、开发阶段-断言：调用dlopen时机早于启动完成，提示修改 2、MR阶段-流水线检查：push代码，diff修改，静态文本分析，检查风险点，code review 上线前阶段：埋点、监控，报警 各个机型平均优化35%左右的pre main耗时收益，如600ms可优化200ms. ![image-20230227122416059](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227122416059.png) 预获取动态库注册信息![image-20230227141938355](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227141938355.png) iOS App 的一种规范启动项执行流程方案Protocol-class、url-class/block、String-Class 他们都有一些相同点，都是又一种映射关系。 根据Protocol、URL或者String来找到具体的实现类Class、Block。 达到代码解耦，跨语言调用的目的。业务代码一般在启动阶段就完成了注册关系的绑定。 1、启动注册：需要依赖所有的实现类，就没办法达到解耦的目的。而且业务也需要依赖启动状态是完成的状态才可以，真正进行调用 2、+load注册：虽然可以代码隔离，但会影响pre main阶段的耗时增加。 3、data段注册：使用更广泛的是data段注册方式![image-20230227151812259](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227151812259.png) 编译期写入：我们可以将attribute,used,section的这种方法把指定的数据写入data段中 运行期读取：首先我们要拿到当前已经加载的所有可执行文件的数量，进行逐个遍历拿到每个可执行文件的header。去掉用getsectiondata()方法，获取指定data段，指定section中的数据。根据写入类容的内存布局，我们就可以成功解析出所有我们需要的注册信息。这种注册方式，既可以实现代码隔离，又可以选择时机，也不会像+load那样真加pre main阶段耗时。 矛盾点、难点![image-20230227153538993](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227153538993.png) 1、循环依赖的现象：调用动态库逻辑时，需要先读取注册信息，读取注册信息又依赖动态库已经加载。而动态库加载需要动态库名称、动态库路径。动态库名称路径又是与注册信息绑定在一起的。 解决方案：预获取动态库注册信息![image-20230227161133988](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227161133988.png) 动态库也是macho order结构：header、load commands、data。系统lyld根据文件中的数据，解析之后来进行加载。 1、直接解析动态库文件，提前获取到我们在编译期写入的注册信息。 2、注册信息与动态库路径、名称一并存储，这样调用具体逻辑时按需加载动态库 启动时候，读取已加载的动态库信息，再读取未加载的动态库信息。 调用动态库时候，从注册信息里边找到动态库名称或者路径，来加载动态库。加载完成之后就会触发已加载动态库的读取逻辑，覆盖原本的映射信息，再完成最终的逻辑调用。 动态库改静态库苹果官方有提到尽可能减少启动阶段加载动态库数量。 减少启动时间。 把启动动态库的代码，都集成到主执行文件当中。 非启动的动态库，继续保持懒加载。 问题懒加载的动态库无法在xcode中配置成依赖主执行文件。在编译的时候，会找不到位于base动态库的链接符号。 ![image-20230227163110268](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227163110268.png) ![image-20230227163506930](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227163506930.png) 这个配置可以忽略，编译器哪些找不到符号的错误，在加载的时候，再去内存中查找所需要的符号。 ![image-20230227164420621](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227164420621.png) 主执行文件导出符号问题 动改静pre main收益10%左右： ![image-20230227164352653](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227164352653.png) 优化1、智能预加载：根据业务逻辑，用户习惯。在不影响启动性能的前提下，预加载动态库。 2、prewarm ![image-20230227165230082](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230227165230082.png) 总结1、动态库懒加载： 把启动不需要的业务，以动态库的形式进行懒加载，可以减少启动pre main阶段的耗时。 2、如何实现懒加载： 去除启动依赖，避免被系统拉起 在运行阶段，通过dlopen按需加载 防止劣化，防止启动阶段调用dlopen的措施 3、 两个难点方案 与获取动态库注册信息，通过直接解析动态库文件。解决的懒加载动态库调用的循环依赖问题。 4、后续展望 代码持续减少 智能预加载 ios15的pre warm方案","link":"/2022/08/14/%E5%8A%A8%E6%80%81%E5%BA%93%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"title":"多线程问题专项治理","text":"1、目的多线程专项治理目的就是降低crash，手机发烫，耗电等问题。 2、问题分析2.1 滥用使用全局队列，并且使用了队列的默认优先级123dispatch_async(dispatch_get_global_queue(0, 0), ^{ //TODO }); 导致大量的全局队列默认优先级，导致了一人干活，全家围观，还增加了造成线程死锁风险，从而引发crash 2.2 大量不必要的线程切换2.3 在高并发场景，没有控制并发量，而使用了全局队列创建了大量线程 实时获取位置信息 异步 多个业务请求需要依赖getAddress异步返回的数据，所以会导致，多个getAddress并发，然而方法内部并未控制并发，而且还采用了全局队列默认优先级，当业并发大的时候，这里会偶现死锁。 //实时获取位置信息 异步 12345678- (void)getAddress{ dispatch_async(dispatch_get_global_queue(0, 0), ^{ __block CLLocation *location; __block NSDictionary *regeoInfo; //业务处理 });} 2.4 业务使用线程的不合理123456dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSMutableArray&lt;NSDictionary *&gt; *imageArray = [NSMutableArray array]; for (NSDictionary *photoDict in readyUploadImageArray) { // 上传照片 }}); 业务使用线程不合理，业务要求是所有需要上传的图片，并发上传。实际上全局队列默认优先级分配一个线程后，多个任务挤在一个线程，并未达到业务预期的目的。 2.5 线程死锁引起的crash当大面积出现psynch_cvwait，semwait_signal，psynch_mutexwait，psynch_mutex_trylock，dispatch_sync_f_slow等信息时，可以初步判定为线程死锁。比如： 当然优先级反转也会导致死锁，具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。导致陷入死锁 。 2.6 子线程刷新UI引起的crash子线程刷新UI的问题，有比较具体的提示信息，还是比较容易发现的。 2.7 线程安全引发的crash由于多线程读写问题的crash比较隐秘，发现难，定位难，所以，当出现pthread_kill，_objc_release，malloc: error for object 0x7912d6d0: pointer being freed was not allocated等信息时，可以初步判定为多线程读写问题 3、方案主要从队列的管理和分配，高并发业务的梳理和重构，线程使用的合理性评估与改造，线程相关crash的排查和修复，长效机制的建立几个方面。 3.1 采取新的队列管理和优先级分配制度根据业务特点，我们决定为不同的优先级，创建与CPU核数相等的串行队列，通过优先级的合理使用和串行队列的调度，充分利用时间片和多核的效率 123456789101112131415#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN @interface HSAQueuePool : NSObject//与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，cell高度，frame等UI的计算extern dispatch_queue_t HSAQueueForQoSUserInteractive(void);//由用户发起的并且需要立即得到结果的任务，比如读取数据（配置，用户信息等）来加载UI，会在几秒或者更短的时间内完成extern dispatch_queue_t HSAQueueForQoSUserInitiated(void);//一些耗时的任务，比如复杂的组合的网络请求，图片下载，上传extern dispatch_queue_t HSAQueueForQoSUtility(void);//对用户不可见，可以长时间在后台运行，比如，拉取配置，地理位置上报，日志上报等extern dispatch_queue_t HSAQueueForQoSBackground(void);//默认，不推荐作为首选使用extern dispatch_queue_t HSAQueueForQoSDefault(void); @endNS_ASSUME_NONNULL_END 业务使用改动小，只需在原有基础上根据业务特点，补充合理的优先级即可。 1234dispatch_async(HLLQueueForQoSUserInitiated(), ^{ //垃圾机型，读取data，可能会导致卡顿,所以加了个线程。 NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]];}); 3.2 梳理线程并发较大的业务进行重构当大量的业务并发，调用getAddress时，getAddress方法内部采用全局队列(默认的优先级)生成大量线程去处理数据，从而造成死锁或者线程资源耗尽，crash。 梳理业务，适当降低并发甚至规避并发。 当业务并发调用getAddress时，如果有该业务数据缓存，则直接返回。 3.3 线程使用的合理性评估与改造，减低线程使用，线程切换 不可预估完成时间的任务，比如图片上传下载，普通接口请求 计算量比较大的，比如加解密，数据计算和处理 有可能卡顿主线程的任务，比如UI的计算与渲染 如无必要，不要随意开启线程。 3.4 死锁问题的重点攻坚线程的生命周期：新建、就绪、运行、阻塞、死亡 由于死锁问题比较隐蔽，通常很难发现从而去排查，我们只能通过在bugly和内部的crash系统上，分析堆栈信息 当发现线程大面积的堆栈出现了psynch_cvwait，semwait_signal，psynch_mutexwait，psynch_mutex_trylock，dispatch_sync_f_slow等信息时，就可以大胆怀疑线程非正常原因阻塞，而导致的死锁 排查： 1.锁用的是否合理 2.线程的数量是否远超平时的线程数量 3.是否使用了NSRecursiveLock，此递归锁不支持多线程递归，因为会造成优先级反转 4.排查业务，线程长时间的阻塞，导致任务无法正常执行，也会造成死锁 5.SCNetworkReachabilityGetFlags，此方法只能在子线程调用，否则会造成主线程同步阻塞 3.5 子线程刷新UI的重点排查与治理为什么子线程刷UI，只是偶现crash呢？因为在苹果现有框架下，刷新UI是一种线程不安全的操作，所以必须放在主线程。放在子线程，恰好竞争同一资源时，才会crash。 统一检查处理： h5交互的回调 二方库，三方库的代理和回调 通知 kvo相关 接口回调 因为通知和kvo的触发和处理都在同一线程，如果子线程触发，那么就有可能子线程刷新UI 3.6 线程安全问题的实质，就是多线程写的问题所以在涉及到多线程读写问题时，对所有的写进行串行或者加锁操作 锁和串行队列的区别，锁中间的执行操作相当于是串行队列。锁的特点是，锁定范围越小越好，但是锁会造成死锁。gcd串行队列，则不会有死锁的问题 4、建立线程数量监控预警体系pthread库中提供了一个用于监控线程创建、运行、结束、销毁的内省函数。 1typedef void (*pthread_introspection_hook_t)(unsigned int event, pthread_t thread, void *addr, size_t size); 在启动时，可以选择启动监控，开始监控线程数量。 12345678910enum { PTHREAD_INTROSPECTION_THREAD_CREATE = 1, //创建线程 PTHREAD_INTROSPECTION_THREAD_START, // 线程开始运行 PTHREAD_INTROSPECTION_THREAD_TERMINATE, //线程运行终止 PTHREAD_INTROSPECTION_THREAD_DESTROY, //销毁线程}; 通过线程状态改变，来记录线程数量。 12345678void pthread_introspection_hook_t(unsigned int eventpthread_t thread, void *addr, size_t size){ //创建线程，则线程数量和线程增长数都加1 if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) {} //销毁线程，则线程数量和线程增长数都减1 else if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY){}} 在iOS开发中，我们常将耗时任务提交给GCD的并发队列，但是并发队列并不会去管理最大并发数，无限制提交任务给并发队列，会给性能带来问题。 YYKit组件中的YYDispatchQueuePool 也能控制并发队列的并发数；其思路是为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。 DispatchQueue是使用信号量让并发队列中的任务并发数得到抑制；YYDispatchQueuePool是让一定数量的串行队列代替并发队列，避开了并发队列不好控制并发数的问题。 ​ 降低crash和性能损耗，从复盘数据来看，crash修复情况和性能优化均符合预期 涉及到的crash数量大约在500左右，粗略计算降低了crash率万分之8 线程的平均数量从之前的51.3，降低到现在的41.6，线程损耗大约是原来的81%，性能节省了大约18.7%","link":"/2022/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B2%BB%E7%90%86/"},{"title":"首页容器化","text":"1、首页容器类Controller问题 首页承担了短视频推荐、关注、直播等场景，基础功能，登录、性能监控，预加载等细节的业务逻辑差异较多，目前多业务代码耦合在一起，增加新功能时需要考虑其他业务方，容易引入问题，开发和测试效率低。导致 ViewController 越来越膨胀 一个版本经常会有多个业务在VC中进行修改导致冲突的情况，此时就需要多方进行 review，保证改动不出问题。 容器功能1、VC生命周期：ViewDidload、ViewWillAppear、ViewWilldisAppear，业务：cell管理、直播、推荐、关注等 2、TableView管理和代理方法：cellForRow: willDisplayCell等， 3、网络请求、其他 业务迭代效率低一个版本经常会有多个业务在容器中进行修改导致冲突的情况。 2、目标 架构分层，明确每层职责，容器和业务解耦，多业务之间解耦，做到容器和业务各自闭环； 业务组件可插拔，不同场景支持灵活的组合和扩展业务组件； 搭建监控体系，实现稳定性、性能、问题定位，建立看板，实时了解各项指标； 防劣化，容器和业务分仓隔离，收敛维护人员； 3、方案ControlerKit 工具实现了生命周期方法的分发，并且通过 Context 进行状态管理，实现了各个业务间的通信和状态维护 4、基础容器 基础容器，采用组件化框架，支持基础组件和业务组件的动态组合和扩展，由业务无关、统一的列表形态组成，通过数据驱动页面展现。同时对外暴露生命周期事件，方便组件进行监听。其中基础容器由平台方进行统一维护，并提供了完善的监控体系，方便进行问题的定位和追查 ![image-20220811172413700](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220811172413700.png) 4.1基础组件 容器的基础组件部分主要包括播放控制、播放策略优化、列表预加载以及页面管理等。为多业务共用，具备可复用、可扩展等优势。 4.2 业务组件 业务组件是和业务强相关的组件，业务方可以根据自身的需要进行灵活定制，组件本身可插拔，由各业务方进行维护 4.3应用场景 业务方基于 容器，组合业务组件和基础组件构建的页面，在构造过程中可以基于配置文件实现容器的定制，比如推荐和关注。 4.4 容器化工具![image-20230314172427279](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314172427279.png) ContainerViewController ContainerViewController 是容器 ViewController，实现了 ContainerProtocol，保存了上下文环境，负责了各个生命周期方法的分发。 ContainerProtocol 声明了容器对外提供的属性和方法，方便各个 SubController 进行访问。 ControllerProtocol 声明了基础的声明周期和共有的方法。 Controller Controller 是将 ViewController 中的代码拆分出来的子模块，可以接收分发出来的 viewDidLoad、viewWillAppear 等生命周期及自定义方法调用，还可以向 ViewController 中添加子 View。 ControllerManager ControllerManager 负责 Controller 的注册、管理、方法分发。通过 classNameArray 返回 Controller 的字符串类名数组即可，可以支持 Controller 在其他仓库的能力 Manager 需要声明分发的 Controller 协议，只需要声明，不需要实现，Manager 内部会通过消息转发机制统一分发。 各角色之间的关系 ContainerViewController 实现了 ContainerProtocol，并持有 ControllerManager，各个子 Controller 注册到 ControllerManager 中，各个 Controller 可以通过 ContainerProtocol 访问容器的能力，ControllerManager 通过 ControllerProtocol 里面声明的方法进行分发。 比如：ContainerViewController 初始化后调用 viewDidLoad 时，会通过 ControllerManager 依次分发到实现该方法的 controller 中，各个 Controller 在自己的 viewDidLoad 方法中实现自己的逻辑即可。 Controller 优先级 方法分发优先级按照数组提供的顺序，因此更基础的 Controller 应排在前面 5、防劣化建设首先进行框架和业务分仓： 代码隔离，修改权限收敛; 业务方修改容器代码，review 通过后才能合入 存量功能拆分 - 监控 监控功能在 TableVC 中处理了很多业务，而且这些逻辑也其他业务存在着耦合。 网络请求监控和数据处理 页面滚动 播放处理 采用新方案进行拆分首先创建 MonitorController，增加业务相关的属性、生命周期方法中实现对应的逻辑，之后抽取单独的业务 controller 在生命周期方法中处理熟人相关逻辑。同时注册到 controllerManager 中，并设置 AB、原有代码判断 AB。上线验证，全量后删除容器老代码。之后业务自闭环，再进行迭代时直接在 MonitorController 内容修改即可。 ![image-20220813105752765](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220813105752765.png) 容器不依赖具体子组件，因此容器不能调指定子组件的方法容器通过管理器分发方法到所有子组件中，实现即被调用，未实现跳过容器分发的方法都应该是抽象的，不是具体某个功能方法 ![image-20230413153626508](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413153626508.png) 容器通过容器协议提供子组件使用能力，子组件持有容器协议弱引用，因此可以直接调用容器协议提供的能力是有限的、抽象的，不能是具体某个功能的某个方法 ![image-20230413160824553](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413160824553.png) 子组件之间不希望有耦合不能直接调用其他子组件特殊情况，通过Context对象解决Context是页面内上下文对象，4个特性:基础对象，可以直接加属性共享局部生效K-V结构、可绑定K-Handler，KV存储时，调用Hander，类似通知 ![image-20230413161029573](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413161029573.png) 整体是MVVM结构ViewModel负责数据逻辑处理，对视频Model的增、删、改、查、去重、过滤等DataController负责刷新、加载更多网络请求调用ViewModel数据变化驱动ViewController渲染UI ![image-20230314175254300](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314175254300.png) 明确职责、明确owner合理的设计、标准、流程工具、系统辅助 明确容器、业务职责容器由平台专人负责，并有保底投入时间各功能由业务方负责容器提供有限能力，如能力无法满足，和容器维护同学沟通，判断是否需要完善容 03 设计方案 - 品质建设 - 线上 - 容灾Obiective-C调用未实现方法会崩溃重构时，接口很多，可能遗漏方法实现，导致不必要的崩溃利用Obiective-C语言消息转发可以实现这特性 ![image-20230314180714745](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314180714745.png) 实施方案-启动阶段 好的开始，是成功的一半，否则，可能没开始就结束了。 获得支持 who? leader、产品、测试、协作开发 Why? 问题的严重性、趋势，适当的夸张修辞手法 what? 人力 乐观规划 When? 时间，乐观估时 重构方式，不影响开发进度方案目标:重构质量，功能使用体验一致，如果出问题，可迅速还原代码重构过程中。 可正常迭代基本思路:实现一个全新(子)功能，通过ABTest动态切换两个功能、通过协议统一新旧功能使用。 方式ABTest数据打平后，删除旧(子)功能ABTest: 切换开关、灰度放量能力、数据指标 一期: 抽象协议，使用方面向协议编程，不依赖具体实现类 二期: 基于协议，实现新功能，ABTest控制获取新旧功能实例 三期: 删掉旧功能、ABTest，保留协议、新功能，完成替换工作图形长度代表工总量 ![image-20230413151043072](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413151043072.png) 预先上车，先合入代码，开关控制功能生效合入后，新页面可以迭代了，业务同学，开发、测试2套功能同步需求并测试、真正的上车 收益/投RO产品数据、质量数据: ABTest、产品核心指标显著正向效率相关 (不容易度量) : 调研问卷，两套页面共存期间可对照比较调研问卷显示开发效率和质量提升均在20%以上 ![image-20230413162913625](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413162913625.png)","link":"/2023/01/11/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"title":"弱网优化","text":"1、DNS优化 【核心解决安全问题】 DNS（Domain Name System），它的作用是根据域名查出IP地址 核心问题 1）由于DNS劫持或故障造成的服务不可用 2）由于DNS调度不准确导致的性能退化 防止DNS的劫持，Eg：OS劫持率由0.12%降低到0.0002%，Android劫持率由0.25%降低到0.05% 降低网络时延，在调度不准确的情况下，会增大网络的时延，降低用户的体验 2、连接优化 降低延迟 提升成功率 3、弱网优化 问题点1：移动网络环境如此复杂，我们如何确定当下就是弱网环境 问题点2: 确定为弱网环境下，我们如何提升弱网下的成功率，降低弱网下的时延，进而提升用户的网络体验 线下进行测试获取阈值：获取一些符合我们预期的阈值，这个时候我们需要借助一些网络测试工具，比如苹果的Network Link Conditioner，Facebook的ATC（Augmented Traffic Control），来获取到线下不同网络情况的阈值，一般我们会测试App冷启动的场景，网络切换的场景，DNS故障场景，弱网场景（一般都是配置上下行的带宽，丢包率，延迟，DNS延迟参数，或者更为简单的是使用工具默认的一些弱网配置） *解决方案***： 主动网络探测：就是触发某些条件后，主动的进行网络探测，并按照一定的条件检测出是否弱网状态 大概逻辑步骤 ① 网络请求成功时，如何进入弱网状态？检查weakhttprtt的阀值（eg：95分位）大于这个值就会进入弱网检测，为了防止频繁触发探测加了时间间隔维度（eg：10分钟） ② 网络请求成功时，如何退出弱网状态？检查goodhttprtt的阀值（一般这个值会取整体网络的95分位或者更大分位的值），小于这个值证明要切换回正常网络状态，为了防止频繁触发探测加了时间间隔的限制30秒，还加入了次数的限制，连续成功次数%次数阈值（4次）等于0。但这看起来还是频次有点高，所以我们引入了阶梯递增机制，随着次数的增长，成60秒几何倍数增长。 线下模拟测试得出：只要小于这个阀值，检测结果必然是正常状态，如果大于或者等于这个阀值，不能证明一定不是正常网络，所以需发起网络探测（成功回调里，加上时间间隔30秒，还加入阶梯次数限制） ③ 网络请求失败时，如何判断进入弱网状态？首先会判断连 续失败次数。连续失败次数/次数阈值（2次）等于1并且连续失败次数%次数阈值（2次）等于0 探测基础能力层，主要提供弱网检测的手段，一是dns query，一是ping 一个网络请求，分为DNS-&gt;TLS-&gt;TCP-&gt;数据传输 四个阶段。想判定网络连通性主要在DNS和TCP阶段，所以dns query和ping就是用来检测这两个阶段的连通性手段。dns query向百度核心域名mbd.baidu.com发起dns查询，查询的DNS服务器为系统配置的DNS服务器(iOS通过res_ninit函数构建一个__res_state的结构体，Android通过systemproperty获取net.dns1和net.dns2的值，便可获取系统配置的DNS服务器)，DNS查询的超时时间为3s。ping的次数为两次，每次超时时间是默认的1s。 被动网络采集：每一次网络请求的所有细节都进行记录，并按照一定的条件将信息进行上报，上层根据条件判断是否是弱网状态。 优化收益： 1.弱网开启QUIC后，网络连接成功率提升，平均耗时降低 2.弱网开启QUIC预连接后，QUIC协议的pv从XX涨到XX 3.弱网开启复合连接后，bad状态下耗时降低XX%，offline状态下耗时降低XX% 四、弱网优化之性能优化1.网络状态设置：无网络提示 2.设定不同网络状态下的超时时间 3.多子模块请求的“延迟性” 对一次请求所有接口数据页面，可以进行分段“延迟”请求 优先模块：数据量少，业务上优先显示 延迟模块：数据量大，延迟加载处理等 4.固定模块加入缓存机制、或增量更新机制 有些页面数据进行数据缓存处理，一定有效时间内再次请求可直接从缓存读取，可避免空白页影响体验 5、前后端采用gzip方式请求和响应,数据压缩和解压, 请求header添加：”content-encoding” 为 “gzip” QUIC:Quick UDP Internet Connections QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征： QUIC 协议的主要目的，是为了整合 TCP 协议的可靠性和 UDP 协议的速度和效率。 1）利用缓存，显著减少连接建立时间； 2）改善拥塞控制，拥塞控制从内核空间到用户空间； 3）没有 head of line 阻塞的多路复用； 4）前向纠错，减少重传； 5）连接平滑迁移，网络状态的变更不会影响连接断线。 QUIC 协议非常复杂，因为它做了太多事情： 为了实现传输的可靠性，它基本上实现并且改进了整个 TCP 协议的功能，包括序列号，重传，拥塞控制，流量控制等； 为了实现传输的安全性，它又彻底重构了 TLS 协议，包括证书压缩，握手消息，0RTT 等。虽然后续可能会采用 TLS1.3 协议，但是事实上是 QUIC 推动了 TLS1.3 的发展； 为了实现传输的并发性，它又实现了 HTTP2 的大部分特性，包括多路复用，流量控制等。 五、TLS的连接优化连接优化的收益主要体现在网络时延和网络成功率上 ![image-20220802170956904](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220802170956904.png) 1）Session Identifier：Session Identifier中文为会话标识符，更像我们熟知的session的概念。是 TLS 握手中生成的 Session ID。服务端会将Session ID保存起来，客户端也会存储Session ID，在后续的ClientHello中带上它，服务端如果能找到匹配的信息，就可以完成一次快速握手。 2）Session Ticket：Session Identifier存在一些弊端，比如客户端多次请求如果没有落在同一台机器上就无法找到匹配的信息，但Session Ticket可以。Session Ticket更像我们熟知的cookie的概念，Session Ticket用只有服务端知道的安全密钥加密过的会话信息，保存在客户端上。客户端在ClientHello时带上了Session Ticket，服务器如果能成功解密就可以完成快速握手。 2、False Start不管是Session Identifier还是Session Ticket都存在时效性问题，不是永久生效 ![image-20220802171249443](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220802171249443.png) 上图很清晰的说明在TLS第一步握手成功后，客户端在发送Change Cipher Spec Finished的同时开始数据传输，服务端在TLS握手完成时直接返回应用数据。应用数据的发送实际上并未等到握手全部完成，所以称之为抢跑。 从结果看省去了1个RTT的时间。False Start有两个前提条件： 一是要通过应用层协议协商ALPN（Application Layer Protocol Negotiation）握手； 二是要支持前向安全的加密算法。 3、预连接预连接：预先创建好的连接。它解决的场景是在App使用阶段可以无耗时的获取连接。下面用四个问答来解释预连接。 *问题一：预连接是否能解决所有网络请求的提前连接建立？* 答：答案是否定的，预连接需要业务方进行核心业务的评估，针对核心的域名进行预连接的建立。 *问题二：预连接既然针对的是特定的域名，那么是如何配置的呢？* 答：采用域名+连接数的方式进行配置，比如https://a.api.com|2，表示给a.api.com这个域名配置两条预连接，这里要说明下，在HTTP/1.x协议下，网络库的实现都会对于单域名有最大连接数的限制，不同网络库的个数限制不一样，有5个也有6个，但对于HTTP/2协议，这个连接数就只能是1个 *预连接是如何建立的？* 答：在网络库初始化的时候，会根据使用者的配置延迟5s进行预连接的建立，主要是考虑网络库在冷启动下对于启动性能的影响，为了保证网络库的整体性能，预连接的总个数限制在20个。 *问题四：预连接是如何保持的？* 答：在网络库初始化的时候，除了进行预连接的建立，还会创建一个预连接的定时器，这个定时器会每隔31s重新建立连接 其他纯网络层面的优化如使用QUIC协议、请求预建链和精简字段等 有三重奏来对数据进行分析的，一，线下数据的采集和分析，得出正向收益，二，灰度数据的采集和分析，得出正向收益，三，线上数据的采集和分析，得出正向收益。 对于客户端同学，我们在PC上要学会使用tcpdump和Wireshark等工具，适当使用Fiddler和Charles等工具，很多时候电脑和手机的网络环境不见得一致，所以要在手机上使用iNetTools，Ping&amp;DNS或终端工具。学会使用工具后，要学着创造不同的网络环境，有很多工具能帮助你完成这点，比如苹果的Network Link Conditioner，FaceBook的ATC（Augmented Traffic Control）等。具备以上两个场景后，你的第一条储备就发挥了作用，你要能看懂握手过程，传输过程，异常断开过程等。 备注:1）httprtt：httprtt（http Round-Trip Time）又名TTFB（Time to first byte），指从客户端请求的第一个字节开始发送到接收到http header的第一个字节的时间差。httprtt的时间如果过长，一方面是客户端本身接入网络质量的问题，另一方面是服务的延时比较大。 2）tcprtt：tcprtt（tcp Round-Trip Time）指客户端tcp信道第一个字节发送到接收第一个字节的时间差。因为HTTP协议底层是基于TCP的，所以在复用同一条tcp连接的前提下，httprtt的时间是包含tcprtt的时间的。大部分情况下httprtt已经可以说明问题的原因。 3）throughput：throughput，中文名字吞吐量，它是用来衡量单位时间内成功传送数据的数量，是可以比较客观的衡量网络质量的指标。吞吐量 =（获bits结束大小 - 获bits开始大小）/（获bits结束时间 - 获bits开始时间），这里有个细节需要注意，posix socket的read函数返回值是bytes，所以要乘以8得到bits。通常在httprtt比较小的情况下，网络依然很慢，这个时候就可以使用吞吐量来确定网络的质量。 4）signal strength：signal strength，这里指的是无线信号强度，在Android上可以通过PhoneStateListener的onSignalStrengthsChanged方法获取到信号强弱，但要注意只能在Android M以上的版本才生效。iOS上暂时没有靠谱的实现。 5）bandwidth-delay product：bandwidth-delay product，中文名带宽时延乘积，指的是一个数据链路的能力（throughput）与来回通信延迟（rtt）的乘积。带宽时延乘积的结果是比特不是位，这个比特值反应出当前网络管道的最大容量。TCP中有一个窗口大小的概念，会限制发送和接收数据的大小，所以TCP窗口大小的调节是直接受带宽时延乘积的影响，根据带宽时延乘积的值去设置套接字的setsockopt方法，设置的option是SO_RCVBUF（接收缓冲区大小）和SO_SNDBUF（发送缓冲区大小 网络状态接口层提供的状态是对标主动采集的网络状态的，所以也包括 GOOD、BAD、UNKNOWN、OFFLINE GOOD 3G网、4G网、5G网，任一条件满足即标记为GOOD状态。 通过阈值标记3G和广义的4G，httprtt大于等于273ms，tcprtt大于等于204ms，即标记为3G状态。 小于这两个值则被标记为4G、5G网。 BAD 2G网、httprtt大于1.31s，任一条件满足则标记为BAD状态。阈值需要在网上查询资料，根据业务线调整。 UNKNOWN 非法的httprtt、tcprtt、吞吐量，任一条件满足则标记为UNKNOWN状态。比如初始化的时候，有的值会标为-1 OFFLINE 依赖平台能力进行判断，Android可以利用 ConnectivityManager得到 NetworkInfo，判断网络信息（没有连接wifi、或者wifi无网络等） 相同url，但资源更新验证Http、Https缓存机制中提供了验证机制，利用Last-Modified 或者Entity Tag（ET）来验证当前已缓存的资源是否与服务端最新资源相同","link":"/2020/12/28/%E5%BC%B1%E7%BD%91%E4%BC%98%E5%8C%96/"},{"title":"打包问题记录","text":"通过jenkins打包ipa包报错：Command CodeSign failed with a nonzero exit code（errSecInternalComponent）描述 ： 在打包机通过 xcode打包不报错 在打包机直接运行打包shell不报错 但是通过jenkin打包就会出现下面的错误 ： 123KitExtension.appex/Users/5i5j/Library/Developer/Xcode/DerivedData/cbs_new5iwork-ebjitbdetyopmbadzpizhbztfpyw/Build/Intermediates.noindex/ArchiveIntermediates/cbs_new5iwork/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/CallKitExtension.appex: errSecInternalComponentCommand CodeSign failed with a nonzero exit code 出现这个问题的主要原因是是Jenkins，以ssh方式到slave机上，默认是没有账户的，但是访问钥匙串要求必须有用户身份 （回忆了一下自己通过Xcode打包的过程中，的确是要求输入过登录密码，之后才打包成功的。没想到通过xcode打包成功之后，再使用shell脚本直接打包，也还需要输入登录密码才能打包成功） 解决办法 添加一步输入密码解锁钥匙串，可以给Jenkins一个用户身份。 build步骤前添加一步解锁钥匙串。 1security unlock-keychain -p &quot;login pwd&quot; ~/Library/Keychains/login.keychain","link":"/2021/03/07/%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"机器学习/深度学习路线与资料","text":"###吴恩达机器学习视频及资料 docx：笔记的word版本 markdown：笔记的markdown版本 html：笔记的html版本 images：笔记的图片 ppt：课程的原版课件 srt：课程的中英文字幕（mp4文件需要在百度云下载，大家可以用记事本或者字幕编辑软件来编辑字幕，共同完善，百度云链接：https://pan.baidu.com/s/1h8QjqBlOm0Exh7orm9teMQ 密码：d3we，下载后解压） code：课程的python代码（有一部分是国外大牛写的） 机器学习视频下载链接：https://pan.baidu.com/s/1raoOPOg 密码：48m8，包含视频和字幕，下载后解压，建议用potplayer播放，此视频与mp4一致。 ###吴恩达深度学习视频 教程地址：https://mooc.study.163.com/university/deeplearning_ai#/c 有同学提供了一个离线视频的下载：链接：https://pan.baidu.com/s/1ciq3qHo0lgoD3MLRwfeqnA 密码：0kim 基础数学(高等数学，线性代数，概率论等)→机器学习(数学导向推荐李航的《统计学习方法》，技术导向推荐周志华的《机器学习》吴恩达机器学习)→吴恩达深度学习 Part 1：从机器学习开始（两个月）最好的入门教程，就是吴恩达讲授的机器学习。吴恩达这套课程发布很久了，虽然有些地方稍微过时，但相信我，现在没有任何公开的课程，能比吴恩达讲得更好。真的，课程结束时我几乎哭了出来。 这个课程可以说适合任何水平的学生，当然，你最好还是得知道两个矩阵如何相乘，以及对编程有一些基本的了解。 这套课程可以前往Coursera学习，传送门：https://www.coursera.org/learn/machine-learning也可以上网易公开课收看，传送门：http://open.163.com/special/opencourse/machinelearning.html 如果你有时间，一定要听完全部的课程。如果时间紧张，至少要听完前五节课程，后面的可以暂时跳过。 吴恩达的机器学习课程深入讲解了经典的机器学习模型，如线性回归、逻辑回归、神经网络、支持向量机、PCA、无监督学习等等。大部分重要概念，都以简单易懂的方式进行了介绍。 课程延伸 当你学习到第五节课，也就是开始讲述神经网络时，建议开始查看与课程平行的外部资料。比方3bule1brown推出的神经网络讲解视频。推荐必看。 YouTube传送门：https://youtu.be/aircAruvnKk?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi或者可以前往B站查看：http://space.bilibili.com/88461692/#/ 以及，我觉得吴恩达在讲神经网络时有点快，所以建议补充阅读一些资料。比如有关神经网络和深度学习的在线书籍，免费的就很好了。 传送门：http://neuralnetworksanddeeplearning.com/ ![img] 作者Michael A. Nielsen以一种简单直观的方式，深入探究了神经网络的每个细节。建议阅读这本书的前两章，与吴恩达的课程并行。当你熟悉更多概念后，开始搞深度学习时，可以再看书中的其余部分。 如果你英文不好，这本《神经网络与深度学习》也有中文翻译版本，可以免费在线查看。 传送门在此：https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/ 这个部分的学习结束之后，你就能明白机器/深度学习的许多概念。最后推荐阅读Christopher Olah的博客，很有意思。 传送门：http://colah.github.io/ ![img] Part 2：涉足深度学习（1个月）开始研究深度学习之前，最好重温一下大学数学。Ian Goodfellow传奇般的“花书”《深度学习》，简明扼要的概括了大部分重要主题。 建议大家尽可能深入地阅读线性代数、概率、信息理论的章节。每当读论文遇到深度学习概念时，都可以在书中找到参考。 ![img]以及，这本书有在线的版本。 例如英文版在此：https://github.com/janishar/mit-deep-learning-book-pdf/blob/master/complete-book-bookmarked-pdf/deeplearningbook.pdf。而中文翻译版本在此：https://github.com/exacity/deeplearningbook-chinese ![img] 关于深度学习的在线资料有很多，你可能会挑花了眼。 再一次，我觉得最好的选择，还是听吴恩达的《深度学习专项系列课程（Deep Learning Specialization）》。 Coursera传送门：https://www.coursera.org/specializations/deep-learning网易云课堂的传送门：https://mooc.study.163.com/smartSpec/detail/1001319001.htm/ 这门课程包括五大章节。其实不是免费的，你可以按照50美元/月购买。当然，如果你负担不起，还能申请“助学金”。申请时请详细阐明理由，处理的时间大概需要15天左右。 当然不付费，大部分内容都是可以看的。以及视频的部分，在很多地方也能免费收看。 这五门课程主要讲的是： 1、神经网络和深度学习（4周） 2、改善深度神经网络（3周） 3、结构化机器学习项目（2周） 4、卷积神经网络（4周） 5、序列模型（3周） ![img] 前三门课程涉及一般的神经网络和深度学习，第四、第五门课程涉及特定主题。如果你打算搞视觉，第四课必听；如果你搞NLP、音频等，第五课必听。但如果你需要听第五课，那么建议也把第四课好好听一下。 这里鼓励大家一下，课程里每周的内容，实际上一两天就能学完，所以不要被课程表吓倒。劳逸集合、提升效率。 学到这个地步，其实就可以再去http://neuralnetworksanddeeplearning.com/，查看第三到第六章的内容，来强化你的概念。如果你有什么还没搞懂的，请前往Olah的博客。 以及，这时候你要开始看深度学习的论文了，从中学习知识。深度学习有个强烈的特点，那就是内容都非常新，阅读论文是跟上时代唯一的方法。不想被抛下，那么还是养成阅读论文的好习惯吧。 Part 3：深度学习上手练（两个月）学到这里，你应该对机器学习和深度学习中的大多数概念有了正确的理解，现在是时候投入沸腾的实际生活中了。 练手深度学习，最好的资源在fast.ai。 ![img] 传送门在此：http://course.fast.ai/ 他们在流行的深度学习工具PyTorch上构建了一个库，只需要几行代码，就能实现世界级的性能。 fast.ai的理念有点不同。吴恩达等老师的教授方法是自上而下，先讲再做。而fast.ai倡导自下而上，先做再讲。 所以在他们的课程中，第一节就带你建立一个强大的图像分类器。自己训练模型的快感，刺激着你去完成其余的课程。 ![img] 除此以外，还要推荐两门课。 斯坦福大学的CS231n和CS224n。CS231n专注于计算机视觉的深度学习，而CS224n专注于序列建模。 CS231n，李飞飞等主讲。官网传送门：http://cs231n.stanford.edu/CS224n，目前是Richard Socher主讲。官网传送门：http://web.stanford.edu/class/cs224n/ 此前的课程，网上也有中文字幕版本，大家可自行搜索。 到这里，为期五个月的机器/深度学习入门就结束了。 希望大家都能稳扎稳打，夯实基础。 以及最后，兑现一个开头的承诺。如果你确实时间很紧张，必须尽快入门机器/深度学习，那么请看—— 速成指南我最多只有俩月 1、完成吴恩达机器学习课程的前五周，要做编程练习。 2、看完3Blue1Brown的视频。 3、完成吴恩达的深度学习专项系列课程，做练习。 4、如果你想搞图像，看专项课程第四讲，搞NLP或序列数据，看第五讲。 5、搜索你感兴趣的开源实现。如果你还没想好用什么语言，推荐Keras。然后根据需要，再迁到TensorFlow或者PyTorch框架。 我，只有一个月 想要在30天完成入门超级困难。除非，你只是想了解机器学习的工作原理，然后应用到自己的项目中。 如果是这样的话，速成建议如下： 1、略读吴恩达机器学习课程第1-5周的课程，只看视频，掌握概念即可。第三周可以跳过MATLAB/Octave课程。 2、看完3Blue1Brow的视频。 3、略读吴恩达深度学习专项系列课程的第一课，也就是神经网络和深度学习。 4、如果你想做图像处理项目，看一下Nielsen书中的第六章：http://neuralnetworksanddeeplearning.com/chap6.html 如果你需要序列建模的一些想法，可以看看Olah的博客：http://colah.github.io/posts/2015-08-Understanding-LSTMs/ 5、Siraj Raval拍了很多有趣的视频，涉及大多数机器/深度学习的主题。传送门在此：https://www.youtube.com/channel/UCWN3xxRkmTPmbKwht9FuE5A 6、搜索跟你感兴趣的开源实现，随时调整以满足你的需求。如前所述，我推荐你先用带有TensorFlow后端的Keras语言。","link":"/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/"},{"title":"检测私有API","text":"preg cd到工程根目录 1cd 工程根目录 遍历查找关键字 12grep 关键字 -r .以上面的邮件举例的话：”grep com.apple.springboard.complete -r .“ 此命令会查找根目录以及多级目录以下的所有文件，包括.framework和.a库，找到匹配结果的话，会打印出来。 -r参数表示会遍历多级目录下的文件。 注意:-r和.之间有个空格 strings首先需要找到app对应的一个Unix可执行文件，可以从两个途径获取这个文件。 工程中获取 在Xcode文件树中搜索“.app” 找到对应文件，右键“Show in Finder” 选中.app文件，右键“显示包内容” 下拉可找到一个跟app名字一致的Unix执行文件 ipa文件中获取 将.ipa改变成.zip后缀 解压文件，进入文件夹，进入Payload子文件，找到.app文件 选中.app文件，右键“显示包内容” 下拉可找到一个跟app名字一致的Unix执行文件 查找指令1strings - -a -arch armv7 Unix可执行文件 | grep 关键字 -a、-arch、armv7这几个参数作用未知，此处只是做一个简单记录，以后有空再做学习。 otool跟strings一样，需要先找到Unix可执行文件，然后运行指令。 1otool -L Unix可执行文件 会打印出工程中用到的系统库，我尝试的结果是只有系统库，可以在打印结果中检查是否引入了私有库。 nm跟strings一样，需要先找到Unix可执行文件，然后运行指令。 1nm Unix可执行文件 | grep 关键字 会打印关键字对应的方法调用的位置等，未仔细研究，暂且做记录。 检查私有API的开源库查资料过程中，发现一个开源库iOS-private-api-checker，可以用来检查app是否使用了私有API，并定位调用位置。 进入开源库的GitHub界面，显示“Deprecated”状态，最终测试结果，不能检测出私有API的问题，不知道是否我的配置有问题。 总结在查找“定位调用私有API位置的方法”的过程，发现大多数文章的作者通过grep的方式就可以定位到问题所在。我之所以查找了其他工具的使用方法，是因为我用grep的方式没有查找到问题，最终花了很多时间来查找问题，结果是让人很无奈。 原因竟然是提交审核的包跟我查找问题的包不是同一份代码，最后用提交审核对应的工程马上就定位到问题了，工作中很多时候，一个异常查找很久没有定位到问题的时候，需要跳出来，考虑一下是否是源头出了问题。","link":"/2020/10/21/%E6%A3%80%E6%B5%8B%E7%A7%81%E6%9C%89API/"},{"title":"直播性能指标监控方案","text":"一、数据收集完整的直播环节：采集、预处理、编码、推流、（传输、转码、分发）、拉流、解码、播放 主播和观众端各自每10秒向服务器打点。 服务器接收到打点信息，为前端监控页面实时统计客户端直播播放情况。 1、主播端 摄像头（分辨率、帧率、机型）–&gt; 视频预处理（cpu占用、内存占用）–&gt; 编码（视频质量、帧率）–&gt; 码率自适应（码率、丢帧数、卡顿数）–&gt; 地理位置、服务器的IP 2、播放端 cdn边缘节点（节点运营商、地理位置、ping值）–&gt; 发送端至接收端延迟 –&gt; 接收缓冲（开播buffer长度、卡顿次数、卡顿时长）–&gt; 视频解码（帧率）–&gt; 播放（首帧时间） 播放失败的时候，上报错误信息和原因 二、直播性能指标建立 帧率：正常来说每秒15帧以上的视频流才能保证观看的流畅度，常规推流如果 FPS 在10帧以下，观众就会明显的感到画面卡顿 1、技术指标： 房间故障，包括卡顿、丢帧、音视频不同步等。 分地域统计数据端到端延迟平均情况。 统计实时整体卡顿率（出现卡顿的在线用户数/在线总用户数*100%，通过此指标可以衡量当前卡顿影响的人群范围）。 统计人均卡顿次数（在线卡顿总次数/在线用户数，通过此指标可以从卡顿频次上衡量整体的卡顿严重程度）。 2、用户体验指标： 次均观看时长 在线人数 看完播率 用户评论卡顿数（用户在评论区打出，“卡”等相关意义字符） 三、视频直播卡顿原因、优化卡顿的原因主要有三种： 原因1：上传阻塞 原因2：推流帧率太低 原因3：下行不佳 80%以上的直播间卡顿问题，均是由于主播端上传阻塞所致。 1. 上传阻塞的评判 1.1：BITRATE 与 NET_SPEED 的关系BITRATE( = VIDEO_BITRATE + AUDIO_BITRATE ) 指的是编码器每秒产生了多少音视频数据要推出去，NET_SPEED 指的是每秒钟实际推出了多少数据，所以如果 BITRATE == NET_SPEED 的情况是常态，则推流质量会非常良好；而如果 BITRATE &gt;= NET_SPEED 这种情况的持续时间比较长，推流质量就很难有什么保障。 1.2：CACHE_SIZE 和 DROP_CNT 的数值BITRATE &gt;= NET_SPEED 的情况一旦出现，编码器产生的音视频数据就会在主播的手机上积压起来，积压的严重程度以 CACHE_SIZE 这个状态值展示出来，如果 CACHE_SIZE 超过警戒线，SDK 会主动丢弃一些音视频数据，从而触发 DROP_CNT 的增长。下图所示就是一个典型的上行阻塞，途中 CACHE_SIZE 始终在红色警戒线以上，说明上行网络不足以满足数据的传输需求，也就是上行阻塞严重 2. 上传阻塞优化方案 2.1 主动提示主播 2.2 合理的编码设置 分辨率：540 * 960，码率：1200kbps 3.1 帧率太低的评判通过直播 LivePushListener 的 VIDEO_FPS 的状态数据，我们可以获得当前推流的视频帧率。正常来说每秒15帧以上的视频流才能保证观看的流畅度，常规推流如果 FPS 在10帧以下，观众就会明显的感到画面卡顿 3. 针对性优化方案 3.1 观察 CPU_USAGE 的大小 通过直播 SDK 的 LivePushListener 的 CPU_USAGE 的状态数据，我们可以获得当前推流 SDK 的 CPU 占用情况和当前系统的 CPU 占用情况。如果当前系统的整体 CPU 使用率超过80%，那么视频的采集和编码都会受到影响，无法正常发挥作用；如果 CPU 使用率达到100%，那么主播端本身就已经很卡，观众端要有流畅的观看体验显然是不可能的 2.3 不盲目追高分辨率过高的视频分辨率并不一定能带来清晰的画质：首先，较高的分辨率要配合较高的码率才能发挥效果，低码率高分辨的清晰度很多时候比不上高码率低分辨率。其次，像1280 x 720这样的分辨率在平均5寸左右的手机屏幕上并不能看出优势，要想跟960 x 540的分辨率拉开差距，只有在 PC 上全屏观看才能有明显的感官差异。但较高的分辨率会显著提升 SDK 的 CPU 使用率，因此常规情况下推荐使用 直播 SDK 中 LivePusher 的 setVideoQuality 设置高清档即可，盲目追高分辨率有可能达不到预期的目标。 2.4 适当使用硬件加速现在的智能手机都支持硬件编码来降低视频编码对 CPU 的依赖，如果您发现您的 App 的 CPU 使用率过高，可以开启硬件编码来降低 CPU 使用率 4、优化播放端4.1 卡顿与延迟​ 如果想要让观看端的视频卡顿尽量少，就要尽可能地让 App 缓存足够多的视频数据，以保证它能平安度过这些“饥饿期”，但是 App 缓存太多的音视频数据会引入一个新的问题，即高延迟。延迟和流畅是一架天平的两端。 ​ setAutoAdjustCache自动模式。在该模式下播放器会根据当前网络情况，对延迟进行自动调节（默认情况下播放器会在1秒 - 5秒这个区间内自动调节延迟大小 4.2造成直播视频卡顿的原因主要有设备、视频流、网络这三方面的问题。设备： 高清视频往往会给硬件带来解码压力 降低视频码率，选择流畅或者标清画质进行视频播放； 增大播放器缓冲区，缓解因网络或解码不稳定引起的卡顿。 视频流参数配置问题 设置合理的码率，帧率，分辨率，关键帧间隔，音视频编码格式等参数； 尽量遵循标准的视频编码方案，流媒体传输协议，对视频流进行采集，编码，解码，播放等操作。 上传网络 当主播端网络较差时，会导致推流端上行不稳定，这个时候可以通过 speedtest 进行测速，判断主播端的网络速度 下行网络 用户通过 speedtest 进行测速，判断终端的网络速度； 用户 ping 播放域名，查看解析到的服务器节点，判断自身IP 到服务器之间是否有延迟过大或者丢包的情况出现； 联系 CDN 厂商排查线路是否有不稳定的现象，也可以通过播放器打点上报，统计所有客户端的整体卡顿率情况，分地区做一些线路和资源的调整和优化。","link":"/2021/07/20/%E7%9B%B4%E6%92%AD%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/"},{"title":"离线化","text":"1、方案比较H5离线包的基本原理是将html、js、css、图片等静态资源打包成压缩包，然后下载到客户端并解压，H5加载时直接从本地读取静态资源文件，减少网络请求，提高速度. 方案名 优点 缺点 备注 加载本地路径 简单可靠，无需hook和调用私有API 有跨域问题，影响cookie和localstorage，H5需做少量改动 请求拦截 不修改加载URL，没有跨域问题，且支持网页部分资源离线化，灵活性和兼容性好 iOS端目前提供的NSURLProtocol和WKURLSchemehandler拦截方案，需要hook和调用私有API，来注册拦截。post请求体丢失 本地Web Server 兼容性好 对客户端耗电和CPU性能有影响 Service Worker 前端兼容性好 iOS端WKWebView不提供官方支持，实现技术难度大 腾讯开源了离线包方案VasSonic（[github.com/Tencent/Vas…] NSURLProtocol 默认会拦截所有经过 URL Loading System 的请求,WKWebView 独立于应用进程运行，发出去的请求默认是不会经过 URL Loading System WKURLSchemeHandler 是 iOS 11 引入的新特性，负责自定义请求的数据管理，如果需要支持 scheme 为 http 或 https请求的数据管理则需要 hook WKWebView 的 handlesURLScheme: 方法，然后返回NO即可 2、请求拦截 关于私有API，对需要拦截的协议进行注册 对拦截的 WKWebView 请求做处理，不仅接管请求还要将请求结果通过NSURLProtocolClient返还给__WKWebView__， 因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。 //注册自己的protocol [NSURLProtocol registerClass:[CustomProtocol class]]; //创建WKWebview WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init]; WKWebView * wkWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) configuration:config]; [wkWebView loadRequest:webViewReq]; [self.view addSubview:wkWebView]; //注册scheme Class cls = NSClassFromString(@&quot;WKBrowsingContextController&quot;); SEL sel = NSSelectorFromString(@&quot;registerSchemeForCustomProtocol:&quot;); if ([cls respondsToSelector:sel]) { // 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System [cls performSelector:sel withObject:@&quot;http&quot;]; [cls performSelector:sel withObject:@&quot;https&quot;]; } // 所有的请求都会先进入到这里，如果希望拦截下来自己处理，那么就返回YES，否则就返回NO + (BOOL)canInitWithRequest:(NSMutableURLRequest *)request { 关于post请求 大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在文章 12345678910111213141516171819202122#pragma mark -#pragma mark 处理POST请求相关POST 用HTTPBodyStream来处理BODY体- (NSMutableURLRequest *)handlePostRequestBodyWithRequest:(NSMutableURLRequest *)request { NSMutableURLRequest * req = [request mutableCopy]; if ([request.HTTPMethod isEqualToString:@&quot;POST&quot;]) { if (!request.HTTPBody) { uint8_t d[1024] = {0}; NSInputStream *stream = request.HTTPBodyStream; NSMutableData *data = [[NSMutableData alloc] init]; [stream open]; while ([stream hasBytesAvailable]) { NSInteger len = [stream read:d maxLength:1024]; if (len &gt; 0 &amp;&amp; stream.streamError == nil) { [data appendBytes:(void *)d length:len]; } } req.HTTPBody = [data copy]; [stream close]; } } return req;} 2.1 更新H5离线包和线上H5类似也能进行更新和升级，有三个更新时机： 1）webview容器打开时更新。开启离线包功能的H5页面每次打开时，会去检查对应的离线包是否有更新。如果有更新，则下载离线包到本地，绝大部分场景是下次打开时生效。 2）启动查询离线包更新。对于实时性要求比较高的页面，可配置在启动时更新离线包。 3）长连接推送实时更新。更新实时性要求极高的场景使用。 2.2 架构改进之前webview容器采用的是两层结构，每个业务方从基础WebVC派生出自己的业务WebVC容器。 现在中间插入一层独立的离线化webView，继承至基础webview。再派生业务层webview。 2.3 查询并行化目前已有多个H5页面采用离线包，为了提高查询效率，多个业务离线包检查的请求采取并行请求的方式。由于HTTP2支持多路复用，所以查询时共用一个NSURLSession对象，多次查询操作自动复用一个TCP连接，减少建立连接次数 2.4 下载任务去重下载过程也是并行进行，可同时下载多个离线包。由于查询操作有多个触发时机，存在重复下载的情况。为了节省流量，采用下载URL作为key，不重复下载正在下载或已下载的文件 2.5 启动预下载大部分离线包查询和下载的时机为打开H5页面时，由于离线包查询、下载、解压总体耗时超过1秒，导致首次打开无法命中离线包。所以离线包支持配置部分离线包在启动时检查和下载离线包，提升首次打开H5页面离线包命中率。配置json格式为： 1234{ &quot;predownloadlist&quot;: //选填。需要启动就下载的离线包列表清单 [&quot;test-offline&quot;]} 2.6 解压异步化和串行化解压过程是CPU和IO密集型操作，放在子线程中处理，有多个文件需要解压时，采用串行队列的方式，一次只解压一个文件，避免同时解压多个文件影响客户端性能。 2.7 降级策略客户端自动降级。本地没有离线包时，客户端会自动将启用离线包的H5页面降级为线上H5页面。 远程配置降级。可以设置局部降级，即临时将某个使用离线包的H5页面降级为线上，也可设置全局降级，关闭所有页面的离线包功能。配置json为： 12345{ &quot;switch&quot;: 1, //总开关，1开启，0关闭 &quot;disablelist&quot;: //选填，配置禁用某个离线包 [&quot;act-test&quot;],} 服务端接口降级。 服务端提供的离线包查询接口可设置将某个页面降级为线上H5，亦可配置客户端更新离线包后强制刷新 2.8 性能监控对webview的加载成功率，错误码、耗时进行了统计上报，通过监控面板查看。 2.9 离线包和URL映射配置化客户端webview通过URL是否有offweb参数判断该页面走线上请求还是加载本地离线包。URL来源广泛，有客户端硬编码、运营系统下发、JS action调用多种来源，手动修改URL效率太低，因此通过远程配置，自动给指定URL添加离线包参数并命中对应的H5离线包。 配置json格式如下：主要通过host，path配置匹配规则。 12345678910111213141516171819202122232425{ &quot;rules&quot; :[ { &quot;host&quot; :[ &quot;test1.zzz.cn&quot; , &quot;test2.zzz.cn&quot; ], &quot;path&quot; :[ &quot;/testapp&quot; ], &quot;offweb&quot; : &quot;test-offline1&quot; }, { &quot;host&quot; :[ &quot;test3.xxx.cn&quot; , &quot;test4.xxx.cn&quot; ], &quot;path&quot; :[ &quot;test/offweb&quot; , &quot;test/abc&quot; ], &quot;offweb&quot; : &quot;test-offline2&quot; } ]} 2.10 解压操作可靠性设计文件解压耗时较长（大约30ms），如果程序异常退出可能会出现解压操作完成一半的情况，影响后续离线包功能。所以文件解压操作采取先解压，然后重命名，保证最后得到的文件完整性。同时当离线包正在使用时，一般情况下采取先解压，下次生效的策略，极端情况下立刻生效，但会导致页面强刷，影响用户体验，使用较少。离线包存放时使用tmp、new、cur三个文件夹，不采用版本号命名，简化离线包缓存管理逻辑 加载速度提升改造完成的H5页面，平均加载速度从2s提升至1s 加载成功率提升页面主框架（不考虑动态数据）加载成功率从96%提升到100%。 3 下载解压异步串行队列中解压，防止多个任务对cpu负载太大，影响页面展示 123456789101112131415161718192021222324//开始下载当前离线包[downloadManager download:curOfflineModel.updatePackageUrl progress:^(NSInteger thisTimeWrittenSize, NSInteger totlalReceivedSize, NSInteger TotalExpectedSize) { NSLog(@&quot;🎋离线：离线包大小 %ld 已下载数进度：%.2f&quot;,TotalExpectedSize,totlalReceivedSize*1.0/TotalExpectedSize*1.0); dispatch_async(dispatch_get_main_queue(), ^{ [WMHUDUntil showMessageToWindow:[NSString stringWithFormat:@&quot;已下载数进度：%.2f%%&quot;,totlalReceivedSize*1.0/TotalExpectedSize*1.0 * 100]]; }); if (totlalReceivedSize*1.0/TotalExpectedSize*1.0==1) { NSLog(@&quot;🎋离线：下载完成=====！！！&quot;); dispatch_async(dispatch_get_main_queue(), ^{ [WMHUDUntil showMessageToWindow:@&quot;下载完成=====！！！&quot;]; }); //子线程进行解压 dispatch_queue_t zipQueue = dispatch_queue_create(&quot;zipQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(zipQueue, ^{ [self mergeZipAndUnZipFileIsPatch:curOfflineModel.isPatch]; }); } } state:^(WMDownloadState state, NSString * _Nullable filePath, NSError * _Nullable error) { }]; 4.1 合并按照我们的需求内容我们下载的内容分为差分包或全量包，和服务约定本地有版本并且与最新版本3个以内下载差分包否者下载全量包。 既然下载的差分包的话就需要与之前的离线包合并，我们这边使用的bsdiff工具。这个工具需要三端统一使用，保证规则一致。 bsdiff简单介绍bsdiff是一种二级制差分工具，由b sdiff与bspatch组成， 将oldfile与newfile做二进制数据差分（bsdiff操作），得到更新的部分（patch文件），再与oldfile进行合成（bspatch操作）。 5.1 解压解压工具也是直接使用目前github上最为常用的SSZipArchive使用起来也是非常的简单 123456789101112131415161718192021NSLog(@&quot;🎋离线：----- 解压开始 ------&quot;);[SSZipArchive unzipFileAtPath:fromPath toDestination:destinationPath progressHandler:^(NSString * _Nonnull entry, unz_file_info zipInfo, long entryNumber, long total) { } completionHandler:^(NSString * _Nonnull path, BOOL succeeded, NSError * _Nullable error) { NSLog(@&quot;🎋离线：path = %@,succeeded = %d&quot;,path,succeeded); NSLog(@&quot;🎋离线：----- 解压完成 ------&quot;); if (succeeded) { NSArray *pathArray = [self getContentsOfDirectoryAtPath:destinationPath]; NSLog(@&quot;🎋离线：解压成功 %@&quot;,pathArray); [WMOfflineH5Cache setDiskOfflineModel:curOfflineModel]; dispatch_async(dispatch_get_main_queue(), ^{ [WMHUDUntil showMessageToWindow:[NSString stringWithFormat:@&quot;解压成功 \\n 本地文件 %@&quot;,pathArray]]; }); }else{ [self renameWithPath:fromPath]; NSLog(@&quot;🎋离线：解压失败 error = %@&quot;,error); dispatch_async(dispatch_get_main_queue(), ^{ [WMHUDUntil showMessageToWindow:[NSString stringWithFormat:@&quot;解压失败&quot;]]; }); }}]; 跨域源于浏览器的同源策略，指的是两个请求接口URL的协议(protocol)、域名(host)和端口(port)一致","link":"/2021/03/10/%E7%A6%BB%E7%BA%BF%E5%8C%96/"},{"title":"组件化方案比较","text":"组件化第一步－剥离公共库和产品基础库组件化第二步－独立业务模块单独成库 模块间解耦 模块重用 提高团队协作开发效率 单元测试 iOS 上绝大部分的路由工具都是基于 URL 匹配的，或者是根据命名约定，用 runtime 方法进行动态调用 缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误 target-actionA-&gt;中间-&gt;B 通过分类给组件来封装一层target对象来给外界提供服务，然后调用者通过依赖中间件来使用服务；中间件是通过runtime来调用组件的服务，达到的解耦。然后，通过实现中间件的category添加新接口来提供服务给调用者，这样使用者只需要依赖中间件，而组件则不需要依赖中间件。 利用 category 为路由工具添加新接口，在接口中通过字符串硬编码获取对应的类，再用 runtime 创建实例，动态调用实例的方法 下图是 CTMediator的组件化方案架构图： ![image-20220917165703491](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220917165703491.png) 这就要求target类名要加前缀Target_ ：目标模块对外服务的分类名，方法名要加前缀Action_：目标模块调用具体的VC ，params:设置回调。同时必须要有并且只有一个参数，参数类型必须是字典NSDictionary，还必须要要有返回参数，返回参数必须是指针类型，不能为int、float等C语言类型。 优点： 利用 category 可以明确声明接口，进行编译检查 内存中不需要维护映射表。不需要注册。 实现方式轻量 缺点： 需要在 mediator 和 target 中重新添加每一个接口，模块化时代码较为繁琐 在 category 中仍然引入了字符串硬编码，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题 无法保证所使用的模块一定存在，target 模块在修改后，使用者只有在运行时才能发现错误 过于依赖 runtime 特性，无法应用到纯 Swift 上。在 Swift 中扩展 mediator 时，无法使用纯 Swift 类型的参数 可能会创建过多的 target 类 使用 runtime 相关的接口调用任意类的任意方法，需要注意别被苹果的审核误伤。参考：Are performSelector and respondsToSelector banned by App Store? 字典传参的问题字典传参时无法保证参数的数量和类型，只能依赖调用约定，就和字符串传参一样，一旦某一方做出修改，另一方也必须修改。 相比于 URL 路由，target-action 通过 category 的接口把字符串管理的问题缩小到了 mediator 内部，不过并没有完全消除，而且在其他方面仍然有很多改进空间。上面的8个指标中其实只能满足第2个”支持模块单独编译”，另外在和接口相关的第3、5、6点上，比 URL 路由要有改善。 URL router123456789// 注册某个URL[URLRouter registerURL:@&quot;app://editor&quot; handler:^(NSDictionary *userInfo) { UIViewController *editorViewController = [[EditorViewController alloc] initWithParam:userInfo]; return editorViewController;}];// 调用路由[URLRouter openURL:@&quot;app://editor/?debug=true&quot; completion:^(NSDictionary *info) {}]; App 启动时实例化各组件模块或者使用class注册，然后组件向ModuleManager注册Url 当组件A需要调用组件B时，向ModuleManager传递URL，参数可以拼接在URL后面或者放在字典里传递，类似 openURL。然后由ModuleManager负责调度组件B，最后完成目标 URL router 的优点： 极高的动态性，适合经常开展运营活动的 app，例如电商 方便地统一管理多平台的路由规则 易于适配 URL Scheme URL router 的缺点： 传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来 只适用于界面模块，不适用于通用模块 参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式。 依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理。 无法保证所使用的的模块一定存在 解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大 改进:protocol-class实现思路是将 protocol 和对应的类进行字典匹配，之后就可以用 protocol 获取 class，再动态创建实例。 组件化的方案，就是通过protocol定义服务接口，组件通过实现该接口来提供接口定义的服务，具体实现就是把protocol和class做一个映射，同时在内存中保存一张映射表，使用的时候，就通过protocol找到对应的class来获取需要的服务。 下图是protocol-class的架构图： 注册：[ModuleManager registerClass:ClassA forProtocol:ProtocolA] 调用：[ModuleManager classForProtocol:ProtocolA] 优点： 利用接口调用，实现了参数传递时的类型安全 直接使用模块的 protocol 接口，无需再重复封装 缺点： 由框架来创建所有对象，创建方式有限，例如不支持外部传入参数，再调用自定义初始化方法 用 OC runtime 创建对象，不支持 Swift 只做了 protocol 和 class 的匹配，不支持更复杂的创建方式和依赖注入 无法保证所使用的 protocol 一定存在对应的模块，也无法直接判断某个 protocol 是否能用于获取模块 相比直接 protocol-class 匹配的方式，protocol-block 的方式更加易用。例如 Swinject。 Protocol RouterZIKRouter 进行了进一步的改进,并不是直接对 protocol 和 class 进行匹配，而是将 protocol 和 router 子类或者 router 对象进行匹配，在 router 子类中再提供创建模块的实例的方式。这时，模块的创建职责就从 BeeHive 单例上转到了每个单独的 router 上，从集约型变成了离散型。 大部分组件化方案都会带来一个问题，就是减弱甚至抛弃编译检查，因为模块已经变得高度动态化了。当调用一个模块时，怎么能保证这个模块一定存在？直接引用类时，如果类不存在，编译器会给出引用错误，但是动态组件就无法在静态时检查了。 可以在 router 上添加许多通用的扩展接口，例如创建模块、依赖注入、界面跳转、界面移除，甚至增加 URL 路由支持 在每个 router 子类中可以进行更详细的依赖注入和自定义操作 可以自定义创建对象的方式，例如自定义初始化方法、工厂方法，在重构时可以直接搬运现有的创建代码，无需在原来的类上增加或修改接口，减少模块化过程中的工作量 可以让多个 protocol 和同一个模块进行匹配 可以让模块进行接口适配，允许外部做完适配后，为 router 添加新的 protocol，解决编译依赖的问题 返回的对象只需符合 protocol，不再和某个单一的类绑定。因此可以根据条件，返回不同的对象，例如适配不同系统版本时，返回不同的控件，让外部只关注接口 优势 1、优势：保证所使用的 protocol 一定存在，在编译阶段就能防止使用不存在的模块。这个功能可以让你更安全、更简单地管理所使用的路由接口，不必再用其他复杂的方式进行检查和维护。 2、当使用了错误的 protocol 时，会产生编译错误 只有被声明为可路由的 protocol 才能用于路由，否则会产生编译错误 可路由的 protocol 必定有一个对应的模块存在 一、路由声明怎么才能声明一个 protocol 是可以用于路由的呢？ 要实现第一个机制，关键就是要为 protocol 添加特殊的属性或者类型，使用时，如果 protocol 不符合特定类型，就产生编译错误 1.1、Objective-C：protocol 继承链在 Objective-C 中，可以要求 protocol 必须继承自某个特定的父 protocol，并且通过宏定义 + protocol 限定，对 protocol 的父 protocol 继承链进行静态检查。 例如 ZIKRouter 中获取 router 类的方法是这样的： 123456@protocol ZIKViewRoutable@end@interface ZIKViewRouter()@property (nonatomic, class, readonly) ZIKViewRouterType *(^toView)(Protocol&lt;ZIKViewRoutable&gt; *viewProtocol);@end toView用类属性的方式提供，以方便链式调用，这个 block 接收一个Protocol&lt;ZIKViewRoutable&gt; *类型的 protocol，返回对应的 router 类。 Protocol&lt;ZIKViewRoutable&gt; *表示这个 protocol 必须继承自ZIKViewRoutable。普通 protocol 的类型是Protocol *，所以如果传入@protocol(EditorViewProtocol)就会产生编译警告。 而如果用宏定义再给 protocol 变量加上一个 protocol 限定，进行一次类型转换，就可以利用编译器检查 protocol 的继承链： 1.2、Swift：条件扩展Swift 中不支持宏定义，也不能随意进行类型转换，因此需要换一种方式来进行编译检查。 可以用 struct 的泛型传递 protocol，然后用条件扩展为特定泛型的 struct 添加初始化方法，从而让没有声明过的泛型类型不能直接创建 struct。 例如： 12345678910111213141516// 用 RoutableView 的泛型来传递 protocolstruct RoutableView&lt;Protocol&gt; { // 禁止默认的初始化方法 @available(*, unavailable, message: &quot;Protocol is not declared as routable&quot;) public init() { }}// 泛型为 EditorViewProtocol 的扩展extension RoutableView where Protocol == EditorViewProtocol { // 允许初始化 init() { }}// 泛型为 EditorViewProtocol 时可以初始化RoutableView&lt;EditorViewProtocol&gt;()// 没有声明过的泛型无法初始化，会产生编译错误RoutableView&lt;UndeclaredProtocol&gt;() 二、 路由检查通过路由声明，我们做到了在编译时对所使用的 protocol 做出限制。下一步就是保证声明过的 protocol 必定有对应的模块，类似于程序在 link 阶段，会检查头文件中声明过的类必定有对应的实现。 这一步是无法直接在编译阶段实现的，不过可以参考 iOS 在启动时检查动态库的方式，我们可以在启动阶段实现这个功能。 2.1 Objective-C: protocol 遍历在 app 以 DEBUG 模式启动时，我们可以遍历所有继承自 ZIKViewRoutable 的 protocol，在注册表中检查是否有对应的 router，如果没有，就给出断言错误。 另外，还可以让 router 同时注册创建模块时用到类： 1EditorViewRouter.registerView(EditorViewController.self) 2.2 Swift: 符号遍历自动推断返回值类型还有最后一个问题，在 BeeHive 中使用[[BeeHive shareInstance] createService:@protocol(EditorViewProtocol)]获取模块时，返回值是一个id类型，使用者需要手动指定返回变量的类型，在 Swift 中更是需要手动类型转换，而这一步是可能出错的，并且编译器无法检查。要实现最完备的类型检查，就不能忽视这个问题。 有没有一种方式能让返回值的类型和 protocol 的类型对应呢？ OC 中的泛型在这时候就发挥作用了。","link":"/2019/04/17/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83/"},{"title":"网络优化","text":"网络优化及监控一、短连接优化方案1、域名合并：客户端修改huiyuan.api.2dfire.com、tuangou.api.2dfire.com合并api.2dfire.com/huiyuan 、api.2dfire.com/tuangou ，服务端Server Load Balancing中还原转发到不同业务服务器优势：1）域名得到了收编，减少了DNS调用次数，降低了DNS劫持风险；2）针对同一域名，可以利用Keep-Alive来复用Http的连接；3）客户端业务层不需要修改代码，后端业务服务也不需要进行任何修改。 2、IP直连客户端架设自己的DNS服务1）程序启动的时候拉取“api.2dfire.com”对应的所有的IP列表；2）对所有IP进行跑马测试，找到速度最快的IP（后续所有的HTTPS请求都将域名更换为跑马最快的IP即可）。比如：经过跑马测试发现域名“api.dianping.com”对应最快的IP是“1.23.456.789”。URL“http://api.2dfire.com/ad/command?param1=123”将被替换为“http:// 1.23.456.789/ad/command?param1=123”优势：1）摒弃了系统DNS，减少外界干扰，摆脱DNS劫持困扰；2）自建DNS更新时机可以控制；3）IP列表更换方便。 3、代理长连模式客户端与代理服务器之间的长连通道是通过IP建立的，与DNS没有关系。客户端的HTTP请求被转换为二进制数据流送到代理服务器，也不需要进行DNS解析。代理服务器转发请求到业务服务器时，都处于同一内网，因此可以自己搭建DNS服务，减少对公网DNS服务的依赖。相比公网http通道，代理服务器与业务服务器之间的网络通道也可以进行优化，通过架设专线或者租用腾讯云等方式可以大大提升通道服务质量","link":"/2020/05/23/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"},{"title":"视频相关优化","text":"一、常见播放问题 列表加载慢 视频起播慢 视频播放失败 播放过程中卡顿 视频画面模糊 串音、有声无画、有画无声、声话不同步 1、收集问题 主动发现、收集，解决用户在播放过程中遇到的问题 推进从发布到播放的全链路优化，不断迭代播放策略 ![image-20230314155256604](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314155256604.png) ![image-20230314160938516](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314160938516.png) ![image-20230314161338006](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314161338006.png) 二、首刷缓存方案![image-20230314162200347](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314162200347.png) 数据获取：受网络、服务响应 （数据传输、推荐算法）因素影响，是造成耗时的主要因素 渲染过程：受机型配置等客观因素影响，不在优化的范畴。 为了缩短数据获取的时间，将数据获取方式优化为从本地磁盘读取（空间换时间思路) 启动读取缓存视频的同时正常请求新的视频列表 缓存视频关键点：需要保障画风符合用户喜好 缓存机制关键点：需要兼容广告等其他业务，可以灵活控制 三、视频分辨率选档策略如何在保证流畅度的前提下，提供用户最佳清晰度的视频（平衡卡顿与画质之间的关系） ![image-20230314162623076](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314162623076.png) ![image-20230314162843398](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314162843398.png) ![image-20230314163020117](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314163020117.png) 四、画质提升![image-20230314163524427](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314163524427.png) ![image-20230314163734063](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314163734063.png) 五、播放质量![image-20230314164122343](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314164122343.png) ![image-20230314164248908](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314164248908.png) ![image-20230314164517181](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314164517181.png) ![image-20230314164956646](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314164956646.png) 六、新方向![image-20230314165527206](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314165527206.png) ![image-20230314165731471](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314165731471.png) 总结![image-20230314165826344](/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230314165826344.png)","link":"/2021/05/14/%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"},{"title":"遇见多线程问题记录","text":"1. NSNotification我们都知道，NSNotification 在哪个线程 post，最终就会在哪个线程执行。如果我们不是在主线程 post 的，但是却在主线程接收的，而且我们期望 selector 在主线程执行。这时候我们需要注意下，在 selector 需要 dispatch 到主线程才可以。当然你也可以使用 addObserverForName:object:queue:usingBlock: 来指定执行 block 的 queue。 12345678910111213141516171819202122232425@implementation BLPostNotification- (void)postNotification { dispatch_queue_t queue = dispatch_queue_create(&quot;com.bool.post.notification&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ // 从非主线程发送通知 （通知名字最好定义成一个常量） [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;downloadImage&quot; object:nil]; });}@end@implementation ImageViewController- (void)viewDidLoad { [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(show) name:@&quot;downloadImage&quot; object:nil];}- (void)showImage { // 需要 dispatch 到主线程更新 UI dispatch_async(dispatch_get_main_queue(), ^{ // update UI });}@end 2. NSTimer使用 NSTimer 时，在哪个线程生成的 timer，就在哪个线程销毁，否则会有意想不到的结果。官方这样描述的： However, for a repeating timer, you must invalidate the timer object yourself by calling its invalidate method. Calling this method requests the removal of the timer from the current run loop; as a result, you should always call the invalidate method from the same thread on which the timer was installed. 12345678910111213141516171819202122232425262728293031@interface BLTimerTest ()@property (nonatomic, strong) dispatch_queue_t queue;@property (nonatomic, strong) NSTimer *timer;@end@implementation BLTimerTest- (instancetype)init { self = [super init]; if (self) { _queue = dispatch_queue_create(&quot;com.bool.timer.test&quot;, DISPATCH_QUEUE_SERIAL); } return self;}- (void)installTimer { dispatch_async(self.queue, ^{ self.timer = [NSTimer scheduledTimerWithTimeInterval:3.0f repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@&quot;test timer&quot;); }]; });}- (void)clearTimer { dispatch_async(self.queue, ^{ if ([self.timer isValid]) { [self.timer invalidate]; self.timer = nil; } });}@end 3. Dispatch Once 死锁在开发中，我们经常使用 dispatch_once，但是递归调用会造成死锁。例如下面这样： 123456- (void)dispatchOnceTest { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [self dispatchOnceTest]; });} 至于为什么会死锁，上文介绍 Dispatch Once 的时候已经说明了，这里就不多做介绍了。提醒一下使用的时候要注意，不要造成递归调用。 4. Dispatch Group在使用 dispatch_group 的时候，dispatch_group_enter(taskGroup) 和 dispatch_group_leave(taskGroup) 一定要成对，否则也会出现崩溃。大多数情况下我们都会注意，但是有时候可能会疏忽。例如多层 for loop 时 ： 123456789101112131415161718- (void)testDispatchGroup { NSString *path = @&quot;&quot;; NSFileManager *fileManager = [NSFileManager defaultManager]; NSArray *folderList = [fileManager contentsOfDirectoryAtPath:path error:nil]; dispatch_group_t taskGroup = dispatch_group_create(); for (NSString *folderName in folderList) { dispatch_group_enter(taskGroup); NSString *folderPath = [@&quot;path&quot; stringByAppendingPathComponent:folderName]; NSArray *fileList = [fileManager contentsOfDirectoryAtPath:folderPath error:nil]; for (NSString *fileName in fileList) { dispatch_async(_queue, ^{ // 异步任务 dispatch_group_leave(taskGroup); }); } }} 上面的 dispatch_group_enter(taskGroup) 在第一层 for loop 中，而 dispatch_group_leave(taskGroup) 在第二层 for loop 中，两者的关系是一对多，很容造成崩溃。有时候嵌套层级太多，很容易忽略这个问题。","link":"/2020/02/21/%E9%81%87%E8%A7%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"量化交易","text":"1、 量化交易介绍股票的量化投资：可以说是一种价值投资，我们所做的也是去挖掘市场中的价值股票，而并非去预测股票涨跌来进行投资等等（至少目前机构不会采取这种方式指导投资），这需要大家明确的一个问题。 量化回测框架提供完整的数据，以及回测机制进行策略评估研究，并能够实时进行模拟交易。为实盘交易提供选择。 1.1流程包含的内容 获取数据： 公司财务、新闻数据 基本行情数据 数据分析挖掘： 数据处理，标准化，去极值，中性化分组回测，行业分布 构建策略: 多因子策略 回测、策略分析: 评估分析策略可行性 模拟交易: 接入实时行情，实时获取成交回报 实时监控，实时归因分析 实盘交易: 接入真实券商账户 1.2 分析结果我们最终想要的结果就是在回测当中表现的较好的分析方法和策略。比如： 2、回测框架介绍 2.1、RiceQuant平台https://www.ricequant.com/algorithms wind平台获取全面数据https://www.wind.com.cn/NewSite/data.html 3、Alpha和Beta每个投资策略的收益率可以分解成为两部分: 一部分与市场完全相关，整个市场的平均收益率乘以一个贝塔系数。贝塔可以称为这个投资组合的系统风险 另一部分和整个市场无关的叫做阿尔法(Alpha) 1、Alpha很难得，Beta很容易。2、Alpha就是精选个股，跑赢市场。3、Beta就是有市场行情时跟上，有风险时候躲避 3.1 多因子策略的优势 多元因子，阿尔法收益的来源丰富，多因子持续稳定 根据市场环境的变化选取最优因子和权重，模型可修改 3.2 FF五因子模型市场资产组合、市值因子(SMB)、账面市值比因子(HML)、盈利因子和成长因子 4、多因子策略流程 1、单因子有效性分析- 因子IC分析 ：因子暴露值和 股票下期的实际回报值的相关系数 - IC分析平台 alphalens https://github.com/quantopian/alphalens 因子收益率分析：确定因子的方向 2、多因子相关性分析 相关性分析还是使用斯皮尔曼秩相关系数 IC分析值建立表格，筛选出数值 3、多因子合成 先从上百个因子当中分析出对股票收益率有效的部分因子（这个数量可以根据筛选的严格程度去做） 在每个大类因子当中去做筛选，每个大类因子中筛选出有效的N个因子 例如筛选出20个有效因子 2、合并相关性强的因子 最终得出有效的，相关性弱的因子，数量不多，一般在10个左右 5、策略评价指标 2.3 收益指标 回测收益率 年化收益率 基准收益率相同条件下，一个简单的买入并持有基准合约策略的收益率（默认基准合约为沪深300指数，这里假设指数可交易，最小交易单位为1）。 2.4 风险指标风险指标指的是在获得收益的时候，承担一些风险值 最大回撤 最大回撤越小越好，最大回撤最好保持10~30%之间 夏普比率 举例而言，假如国债的回报是4%，而您的投资组合预期回报是16%，您的投资组合的标准偏差是5%，那么用16%－4%,可以得出12%（代表您超出无风险投资的回报），再用12%÷5%＝2.4，代表投资者风险每增长1%，换来的是2.4%的多余收益。夏普比率越大，说明单位风险所获得的风险回报越高。 最终夏普比率越高越好，达到1.5以上已经是很好的结果 6、 打分法选股7、1、MACD策略交易信号分析","link":"/2019/08/30/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"},{"title":"随机深林","text":"要点 说名随机森林每棵决策树的建立过程 知道为什么需要随机有放回(Bootstrap)的抽样 说明随机森林的超参数 应用 泰坦尼克号乘客生存预测 1、 什么是集成学习方法集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是生成多个分类器/模型，各自独立地学习和作出预测。这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。 2、 什么是随机森林在机器学习中，随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 例如, 如果你训练了5个树, 其中有4个树的结果是True, 1个数的结果是False, 那么最终投票结果就是True 3、 随机森林原理过程学习算法根据下列算法而建造每棵树： 用N来表示训练用例（样本）的个数，M表示特征数目。 1、一次随机选出一个样本，重复N次， （有可能出现重复的样本） 2、随机去选出m个特征, m &lt;&lt;M，建立决策树 采取bootstrap抽样1 3.1 为什么采用BootStrap抽样 为什么要随机抽样训练集？ 如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的 为什么要有放回地抽样？ 如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。 3.2 API class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2) 随机森林分类器 n_estimators：integer，optional（default = 10）森林里的树木数量120,200,300,500,800,1200 criteria：string，可选（default =“gini”）分割特征的测量方法 max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30 max_features=”auto”,每个决策树的最大特征数量 If “auto”, then max_features=sqrt(n_features). If “sqrt”, then max_features=sqrt(n_features) (same as “auto”). If “log2”, then max_features=log2(n_features). If None, then max_features=n_features. bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样 min_samples_split:节点划分最少样本数 min_samples_leaf:叶子节点的最小样本数 超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf 3.3 代码1234567891011# 随机森林去进行预测rf = RandomForestClassifier()param = {&quot;n_estimators&quot;: [120,200,300,500,800,1200], &quot;max_depth&quot;: [5, 8, 15, 25, 30]}# 超参数调优gc = GridSearchCV(rf, param_grid=param, cv=2)gc.fit(x_train, y_train)print(&quot;随机森林预测的准确率为：&quot;, gc.score(x_test, y_test)) 4、总结 在当前所有算法中，具有极好的准确率 能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维 能够评估各个特征在分类问题上的重要性","link":"/2019/09/18/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/"}],"tags":[{"name":"iOS AppDelegate","slug":"iOS-AppDelegate","link":"/tags/iOS-AppDelegate/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"flutter","slug":"flutter","link":"/tags/flutter/"},{"name":"强化学习","slug":"强化学习","link":"/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"Xcode","slug":"Xcode","link":"/tags/Xcode/"},{"name":"cocoaPods","slug":"cocoaPods","link":"/tags/cocoaPods/"},{"name":"量化交易","slug":"量化交易","link":"/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"categories":[]}