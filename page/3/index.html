<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>xushuanghui</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="xushuanghui">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="xushuanghui">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="xushuanghui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="xushuanghui" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xushuanghui</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Flutter-Tree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/17/Flutter-Tree/" class="article-date">
  <time class="dt-published" datetime="2020-01-17T09:47:01.000Z" itemprop="datePublished">2020-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/17/Flutter-Tree/">Flutter Tree</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://i.loli.net/2020/12/17/vh2TFclGnkx1mDC.png" alt="2020-12-17-5.47.46.png"></p>
<p>我们也可以看到上图中每个控件所形成的树结构中隐含了一些关系，例如在上图中，我们可以说 Text 组件是 Column 组件的子组件，Scaffold 是 AppBar 的父组件，这样的层级关系使得每个控件都清晰的连接到了一起，树结构由此而来（俄罗斯套娃）。</p>
<p>在 Flutter 中，Container、Text 等组件都属于 Widget，所以我们将这种树称为 Widget 树，也可以叫做控件树，它就表示了我们在 dart 代码中所写的控件的结构。</p>
<p><img src="https://i.loli.net/2020/12/17/aI3GmoWswkR1dHr.png" alt="2020-12-17-5.47.54.png"></p>
<p>然而，在 Flutter 体系结构中，真正做组件渲染在屏幕上这个任务的并非在 控件层（Widget）层，而是在渲染（Rendering）层，那么我们在代码中所写组件又是怎么通过渲染层显示的呢？Flutter 中又引入了 Element 树和 RenderingObject 树两棵树。</p>
<p>Element 是什么，我们可以把它称之为 Widget 另一种抽象。读者也可以把它看作一个更为实际控件，因为在我们的手机屏幕上显示的控件并非我们在代码中所写的 Widget，我们在代码中所使用的像 Container、Text 等这类组件和其属性只不过是我们想要构建的组件的配置信息，当我们第一次调用 <code>build()</code> 方法想要在屏幕上显示这些组件时，Flutter 会根据这些信息生成该 Widget 控件对应的 Element，同样地，Element 也会被放到相应的 Element 树当中。在 Flutter 中，一个 Widget 通过多次复用可以对应多个 Element 实例，Element 才是我们真正在屏幕上显示的元素。</p>
<blockquote>
<p>Element 与 Widget 另一个区别在于，Widget 天然是不可变的（immutable），它如要更新便需要重建，如果想要把可变状态与 Widget 关联起来，可以使用 StatefulWidget，StatefulWidget 通过使用StatefulWidget.createState 方法创建 State 对象，并将之扩充到 Element 以及合并到树中；</p>
</blockquote>
<p>这里，为了更为深刻的理解以上描述的含义，我们可以举一个更为形象的例子。Widget 作为大 Boss，他把近期的战略部署，即配置信息，写在纸上下发给经理人 Element，Element 看到详细的配置信息开始真正的开起活来了。我们还需要注意一点，大 Boss 随时会改变战略部署，然后不会在原有的纸上修改而是重新写下来，这时经理人为了减少工作量需要将新的计划与旧的计划比较来作出相应的更新措施。这也是 Flutter 框架层做的一大优化。下面又来了，Element 作为经理人也很体面，当然不会把活全干完，于是又找了一个 RenderObject 的员工来帮它做粗重的累活。</p>
<p>RenderObject 在 Flutter 当中做组件布局渲染的工作，其为了组件间的渲染搭配及布局约束也有对应的 RenderObject 树，我们也称之为渲染树。</p>
<p>熟悉了 Flutter 中的上述三颗树，相信读者会对组件的渲染过程有了一个清晰的认识，这对我们之后学习常用组件有很大的帮助，我们需要用不同的眼光去看待我们所建立的布局和控件，之后我们也会更加深入的去理解其中更不为人知的奥秘。</p>
        
          <p class="article-more-link">
            <a href="/2020/01/17/Flutter-Tree/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/17/Flutter-Tree/" data-id="clgqem7vf000eh9d36iqt5es1" data-title="Flutter Tree" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flutter/" rel="tag">flutter</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CocoaPods组件支持Carthage打包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/03/CocoaPods%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81Carthage%E6%89%93%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2019-12-03T10:27:07.000Z" itemprop="datePublished">2019-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/03/CocoaPods%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81Carthage%E6%89%93%E5%8C%85/">CocoaPods组件支持Carthage打包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>虽说 CocoaPods 有 <a target="_blank" rel="noopener" href="https://github.com/CocoaPods/cocoapods-packager">cocoapods-packager</a> 这个插件可以生成二进制版本，但这个库的维护者似乎并不活跃，很多 issue 和 pr 过了一两年还堆积着没处理。于是我决定试试 Carthage ，不过不利用 Cartfile 生成依赖，还是用的 CocoaPods 那一套。</p>
<p>要让组件支持 Carthage ，工程里只需要有一个 <code>shared framework target</code> 即可。针对 CocoaPods 生成的工程，我们先在 Podfile 里面设置 <code>use_frameworks!</code> ，来满足 <code>framework target</code> 。</p>
<p>对于剩下的 <code>share</code> 部分，可以用 <a target="_blank" rel="noopener" href="https://github.com/CocoaPods/CocoaPods/pull/5254">Add share schemes for development pods</a> 这个 pr 里面的方法解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install! &#x27;cocoapods&#x27;, :share_schemes_for_development_pods =&gt; false</span><br></pre></td></tr></table></figure>

<p>不过上面的那种方式把所有的 <code>development pods</code> 对应的 target 都 share 了，这里我们可以这样设置特定的 <code>development pods</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install! &#x27;cocoapods&#x27;, :share_schemes_for_development_pods =&gt; [&#x27;PodA&#x27;]</span><br></pre></td></tr></table></figure>

<p>在 CocoaPods 1.4.0 版本中，<code>share_schemes_for_development_pods</code> 默认是 false 的，所以需要手动在 Podfile 里面去添加这一句。</p>
<p>最后执行一下 <code>pod install</code> ，然后再执行 <code>carthage build --no-skip-current --platform ios</code> 就可以打出 ios 版本的 dynamic framework 了。想利用 Carthage 打出 static framework 的可以查看 <a target="_blank" rel="noopener" href="https://github.com/Carthage/Carthage/blob/master/Documentation/StaticFrameworks.md">Build static frameworks to speed up your app’s launch times</a>。</p>
<p>再进一步，我们可以把这个默认设置写入团队专有的 CocoaPods 插件中，比如 <code>cocoapods-xxx-plugin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pod::HooksManager.register(&#x27;cocoapods-xxx-plugin&#x27;, :pre_install) do |context, _|</span><br><span class="line">	first_target_definition = context.podfile.target_definition_list.select&#123; |d| d.name != &#x27;Pods&#x27; &#125;.first</span><br><span class="line">	development_pod = first_target_definition.name.split(&#x27;_&#x27;).first unless first_target_definition.nil?</span><br><span class="line">	    </span><br><span class="line">	Pod::UI.section(&quot;Auto set share scheme for development pod: \&#x27;#&#123;development_pod&#125;\&#x27;&quot;) do</span><br><span class="line">		# carthage 需要 shared scheme 构建 framework</span><br><span class="line">		context.podfile.install!(&#x27;cocoapods&#x27;, :share_schemes_for_development_pods =&gt; [development_pod])</span><br><span class="line">	end unless development_pod.nil?</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>在 Podfile 添加以下代码，让插件生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin &#x27;cocoapods-xxx-plugin&#x27;</span><br></pre></td></tr></table></figure>

<p>好处就是以后有更多相似配置的话都可以通过更改这个插件解决，而不用每次都去 Podfile 里面改 <code>pre_install</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/03/CocoaPods%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81Carthage%E6%89%93%E5%8C%85/" data-id="clgqem7ve000ah9d3aso52tpa" data-title="CocoaPods组件支持Carthage打包" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AsyncDisplayKit" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/12/AsyncDisplayKit/" class="article-date">
  <time class="dt-published" datetime="2019-11-12T07:45:53.000Z" itemprop="datePublished">2019-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/12/AsyncDisplayKit/">AsyncDisplayKit</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView&#x2F;CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView&#x2F;CALayer，它具有和 UIView&#x2F;CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView&#x2F;CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView&#x2F;CALayer 去。</p>
<p>ASDK 仿照 QuartzCore&#x2F;UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/12/AsyncDisplayKit/" data-id="clgqem7v90003h9d3ci2icm08" data-title="AsyncDisplayKit" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-机器学习-深度学习路线与资料" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T09:18:16.000Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/">机器学习/深度学习路线与资料</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>###吴恩达机器学习视频及资料</p>
<p><strong>docx</strong>：笔记的<strong>word</strong>版本</p>
<p><strong>markdown</strong>：笔记的<strong>markdown</strong>版本</p>
<p><strong>html</strong>：笔记的<strong>html</strong>版本</p>
<p><strong>images</strong>：笔记的图片</p>
<p><strong>ppt</strong>：课程的原版课件</p>
<p><strong>srt</strong>：课程的中英文字幕（<strong>mp4</strong>文件需要在百度云下载，大家可以用记事本或者字幕编辑软件来编辑字幕，共同完善，百度云链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1h8QjqBlOm0Exh7orm9teMQ">https://pan.baidu.com/s/1h8QjqBlOm0Exh7orm9teMQ</a> 密码：d3we，下载后解压）</p>
<p><strong>code</strong>：课程的<strong>python</strong>代码（有一部分是国外大牛写的）</p>
<p>机器学习视频下载链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1raoOPOg">https://pan.baidu.com/s/1raoOPOg</a> 密码：48m8，包含视频和字幕，下载后解压，建议用<strong>potplayer</strong>播放，此视频与<strong>mp4</strong>一致。</p>
<p>###吴恩达深度学习视频</p>
<p><strong>教程地址：</strong><a target="_blank" rel="noopener" href="https://mooc.study.163.com/university/deeplearning_ai#/c">https://mooc.study.163.com/university/deeplearning_ai#/c</a></p>
<p><strong>有同学提供了一个离线视频的下载</strong>：链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ciq3qHo0lgoD3MLRwfeqnA">https://pan.baidu.com/s/1ciq3qHo0lgoD3MLRwfeqnA</a> 密码：0kim</p>
<p>基础数学(高等数学，线性代数，概率论等)→机器学习(数学导向推荐李航的《统计学习方法》，技术导向推荐周志华的《机器学习》吴恩达机器学习)→吴恩达深度学习</p>
        
          <p class="article-more-link">
            <a href="/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/" data-id="clgqem7vw0022h9d36gmg0u22" data-title="机器学习/深度学习路线与资料" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-cocoapod加载插件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/23/cocoapod%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2019-09-23T08:28:09.000Z" itemprop="datePublished">2019-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/23/cocoapod%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/">cocoapods加载插件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>CocoaPods 为开发者提供了插件注册功能，可以使用 <code>pod plugins create NAME</code> 命令创建插件，并在 Podfile 中通过 <code>plugin &#39;NAME&#39;</code> 语句引入插件。虽然在一般情况下很少使用这个功能，但在某些场景下，利用插件能比较方便快捷地解决问题。</p>
<h2 id="实现探索"><a href="#实现探索" class="headerlink" title="实现探索"></a>实现探索</h2><p>首先，由于 <code>pod install</code> 过程会涉及到插件的加载，所以直接查看 <code>installer.rb</code> 文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Runs the registered callbacks for the plugins post install hooks.</span><br><span class="line">#</span><br><span class="line">def run_plugins_post_install_hooks</span><br><span class="line">  context = PostInstallHooksContext.generate(sandbox, aggregate_targets)</span><br><span class="line">  HooksManager.run(:post_install, context, plugins)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># Runs the registered callbacks for the plugins pre install hooks.</span><br><span class="line">#</span><br><span class="line"># @return [void]</span><br><span class="line">#</span><br><span class="line">def run_plugins_pre_install_hooks</span><br><span class="line">  context = PreInstallHooksContext.generate(sandbox, podfile, lockfile)</span><br><span class="line">  HooksManager.run(:pre_install, context, plugins)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># Ensures that all plugins specified in the &#123;#podfile&#125; are loaded.</span><br><span class="line">#</span><br><span class="line"># @return [void]</span><br><span class="line">#</span><br><span class="line">def ensure_plugins_are_installed!</span><br><span class="line">  require &#x27;claide/command/plugin_manager&#x27;</span><br><span class="line"></span><br><span class="line">  loaded_plugins = Command::PluginManager.specifications.map(&amp;:name)</span><br><span class="line"></span><br><span class="line">  podfile.plugins.keys.each do |plugin|</span><br><span class="line">    unless loaded_plugins.include? plugin</span><br><span class="line">      raise Informative, &quot;Your Podfile requires that the plugin `#&#123;plugin&#125;` be installed. Please install it and try installation again.&quot;</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>其中 <code>run_plugins_pre_install_hooks</code> 和 <code>run_plugins_post_install_hooks</code> 分别执行了插件注册的 <code>pre_install</code> 和 <code>pod_install</code> 方法， <code>ensure_plugins_are_installed</code> 则确认插件是否已被安装。</p>
<p>接下来看下 <code>Command::PluginManager</code> ，这个类在 <code>claide/command/plugin_manager</code> 文件内，属于 <code>claide</code> gem :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># @return [Array&lt;Gem::Specification&gt;] Loads plugins via RubyGems looking</span><br><span class="line">#         for files named after the `PLUGIN_PREFIX_plugin` and returns the</span><br><span class="line">#         specifications of the gems loaded successfully.</span><br><span class="line">#         Plugins are required safely.</span><br><span class="line">#</span><br><span class="line">def self.load_plugins(plugin_prefix)</span><br><span class="line">  loaded_plugins[plugin_prefix] ||=</span><br><span class="line">    plugin_gems_for_prefix(plugin_prefix).map do |spec, paths|</span><br><span class="line">      spec if safe_activate_and_require(spec, paths)</span><br><span class="line">    end.compact</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># @group Helper Methods</span><br><span class="line"></span><br><span class="line"># @return [Array&lt;[Gem::Specification, Array&lt;String&gt;]&gt;]</span><br><span class="line">#         Returns an array of tuples containing the specifications and</span><br><span class="line">#         plugin files to require for a given plugin prefix.</span><br><span class="line">#</span><br><span class="line">def self.plugin_gems_for_prefix(prefix)</span><br><span class="line">  glob = &quot;#&#123;prefix&#125;_plugin#&#123;Gem.suffix_pattern&#125;&quot;</span><br><span class="line">  Gem::Specification.latest_specs(true).map do |spec|</span><br><span class="line">    matches = spec.matches_for_glob(glob)</span><br><span class="line">    [spec, matches] unless matches.empty?</span><br><span class="line">  end.compact</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># Activates the given spec and requires the given paths.</span><br><span class="line"># If any exception occurs it is caught and an</span><br><span class="line"># informative message is printed.</span><br><span class="line">#</span><br><span class="line"># @param  [Gem::Specification] spec</span><br><span class="line">#         The spec to be activated.</span><br><span class="line">#</span><br><span class="line"># @param  [String] paths</span><br><span class="line">#         The paths to require.</span><br><span class="line">#</span><br><span class="line"># @return [Bool] Whether activation and requiring succeeded.</span><br><span class="line">#</span><br><span class="line">def self.safe_activate_and_require(spec, paths)</span><br><span class="line">  spec.activate</span><br><span class="line">  paths.each &#123; |path| require(path) &#125;</span><br><span class="line">  true</span><br><span class="line">rescue Exception =&gt; exception # rubocop:disable RescueException</span><br><span class="line">  message = &quot;\n---------------------------------------------&quot;</span><br><span class="line">  message &lt;&lt; &quot;\nError loading the plugin `#&#123;spec.full_name&#125;`.\n&quot;</span><br><span class="line">  message &lt;&lt; &quot;\n#&#123;exception.class&#125; - #&#123;exception.message&#125;&quot;</span><br><span class="line">  message &lt;&lt; &quot;\n#&#123;exception.backtrace.join(&quot;\n&quot;)&#125;&quot;</span><br><span class="line">  message &lt;&lt; &quot;\n---------------------------------------------\n&quot;</span><br><span class="line">  warn message.ansi.yellow</span><br><span class="line">  false</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码调用几个的 <code>Gem::Specification</code> 方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取最新 spec 集合</span><br><span class="line"># Return the latest specs, optionally including prerelease specs if prerelease is true.</span><br><span class="line">latest_specs(prerelease = false) </span><br><span class="line"></span><br><span class="line"># 获取 gem 中匹配的文件路径</span><br><span class="line"># Return all files in this gem that match for glob.</span><br><span class="line">matches_for_glob(glob) </span><br><span class="line"></span><br><span class="line"># 激活 spec，注册并将其 lib 路径添加到 $LOAD_PATH （$LOAD_PATH 环境变量存储 require 文件时查找的路径）</span><br><span class="line"># Activate this spec, registering it as a loaded spec and adding it&#x27;s lib paths to $LOAD_PATH. Returns true if the spec was activated, false if it was previously activated. Freaks out if there are conflicts upon activation.</span><br><span class="line">activate()</span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>loaded_plugins[plugin_prefix]</code> 为空的情况下，程序会执行 <code>plugin_gems_for_prefix</code> 方法，<code>plugin_gems_for_prefix</code> 方法通过 <code>latest_specs</code> 获取了最新的 spec ，并通过 spec 的 <code>matches_for_glob</code> 方法对文件进行匹配，当 spec 中存在匹配 <code>&quot;#&#123;prefix&#125;_plugin#&#123;Gem.suffix_pattern&#125;&quot;</code> 格式的文件时，则视其为 CocoaPods 插件。在拿到插件及其匹配文件后，<code>safe_activate_and_require</code> 方法将文件加入 $LOAD_PATH 中并 require 之。</p>
<p>另外 <code>CLAide::Command</code> 类会在 <code>run</code> 类方法中加载所有插件，然后根据解析后的信息，执行对应的命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># @param  [Array, ARGV] argv</span><br><span class="line">#         A list of (remaining) parameters.</span><br><span class="line">#</span><br><span class="line"># @return [Command] An instance of the command class that was matched by</span><br><span class="line">#         going through the arguments in the parameters and drilling down</span><br><span class="line">#         command classes.</span><br><span class="line">#</span><br><span class="line">def self.run(argv = [])</span><br><span class="line">  plugin_prefixes.each do |plugin_prefix|</span><br><span class="line">    PluginManager.load_plugins(plugin_prefix)</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  argv = ARGV.coerce(argv)</span><br><span class="line">  command = parse(argv)</span><br><span class="line">  ANSI.disabled = !command.ansi_output?</span><br><span class="line">  unless command.handle_root_options(argv)</span><br><span class="line">    command.validate!</span><br><span class="line">    command.run</span><br><span class="line">  end</span><br><span class="line">rescue Object =&gt; exception</span><br><span class="line">  handle_exception(command, exception)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>对于通过 <code>pod plugin create</code> 命令创建的插件来说，lib 目录下都会自动生成一个 <code>cocoapods_plugin.rb</code> 文件，这个文件就是用来标识此 gem 为 CocoaPods 插件的。如果想手动创建 CocoaPods 插件，需要满足以下两个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Handles plugin related logic logic for the `Command` class.</span><br><span class="line">#</span><br><span class="line"># Plugins are loaded the first time a command run and are identified by the</span><br><span class="line"># prefix specified in the command class. Plugins must adopt the following</span><br><span class="line"># conventions:</span><br><span class="line">#</span><br><span class="line"># - Support being loaded by a file located under the</span><br><span class="line"># `lib/#&#123;plugin_prefix&#125;_plugin` relative path.</span><br><span class="line"># - Be stored in a folder named after the plugin.</span><br><span class="line"></span><br><span class="line"># - 支持通过 `lib/#&#123;plugin_prefix&#125;_plugin` 路径的文件加载</span><br><span class="line">#   (也就是说，如果要对外暴露插件内部存的方法，需要在此文件中 require 之，比如自定义的 Podfile DSL 文件)</span><br><span class="line"># - 保存在以插件命名的文件夹中</span><br></pre></td></tr></table></figure>



<p>在 CocoaPods 上下文中，以上的 <code>plugin_prefix</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.plugin_prefixes = %w(claide cocoapods)</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果需要外部 gem 以插件的形式提供某些功能，可以通过和 CocoaPods 一样的方式实现，即规定特定的命名规则，然后通过 <code>Gem::Specification</code> 提供的方法获取满足条件的 gem ，再 require 入口文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec = Gem::Specification.find_by_name(&#x27;naruto&#x27;)</span><br><span class="line">spec.activate</span><br><span class="line">matches = spec.matches_for_glob(&#x27;naruto&#x27;)</span><br><span class="line">matches.each do |path|</span><br><span class="line">  require(path)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/23/cocoapod%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/" data-id="clgqem7vp001dh9d33q0z8ckt" data-title="cocoapods加载插件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocoaPods/" rel="tag">cocoaPods</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-随机深林" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/18/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/" class="article-date">
  <time class="dt-published" datetime="2019-09-18T03:03:50.000Z" itemprop="datePublished">2019-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/18/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/">随机深林</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>要点<ul>
<li>说名随机森林每棵决策树的建立过程</li>
<li>知道为什么需要随机有放回(Bootstrap)的抽样</li>
<li>说明随机森林的超参数</li>
</ul>
</li>
<li>应用<ul>
<li>泰坦尼克号乘客生存预测</li>
</ul>
</li>
</ul>
<h2 id="1、-什么是集成学习方法"><a href="#1、-什么是集成学习方法" class="headerlink" title="1、 什么是集成学习方法"></a>1、 什么是集成学习方法</h2><p>集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是<strong>生成多个分类器&#x2F;模型</strong>，各自独立地学习和作出预测。<strong>这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。</strong></p>
<h2 id="2、-什么是随机森林"><a href="#2、-什么是随机森林" class="headerlink" title="2、 什么是随机森林"></a>2、 什么是随机森林</h2><p>在机器学习中，<strong>随机森林是一个包含多个决策树的分类器</strong>，并且其输出的类别是由个别树输出的类别的众数而定。</p>
<p><img src="/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97t/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.png" alt="随机森林"></p>
<p>例如, 如果你训练了5个树, 其中有4个树的结果是True, 1个数的结果是False, 那么最终投票结果就是True</p>
<p><img src="/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/%E6%8A%95%E7%A5%A8.png" alt="投票"></p>
<h2 id="3、-随机森林原理过程"><a href="#3、-随机森林原理过程" class="headerlink" title="3、 随机森林原理过程"></a>3、 随机森林原理过程</h2><p>学习算法根据下列算法而建造每棵树：</p>
<ul>
<li>用N来表示训练用例（样本）的个数，M表示特征数目。<ul>
<li>1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）</li>
<li>2、随机去选出m个特征, m &lt;&lt;M，建立决策树</li>
</ul>
</li>
<li>采取bootstrap抽样1</li>
</ul>
<h3 id="3-1-为什么采用BootStrap抽样"><a href="#3-1-为什么采用BootStrap抽样" class="headerlink" title="3.1 为什么采用BootStrap抽样"></a>3.1 为什么采用BootStrap抽样</h3><ul>
<li>为什么要随机抽样训练集？　　<ul>
<li>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</li>
</ul>
</li>
<li>为什么要有放回地抽样？<ul>
<li>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</li>
</ul>
</li>
</ul>
<h3 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h3><ul>
<li><p>class sklearn.ensemble.RandomForestClassifier(n_estimators&#x3D;10, criterion&#x3D;’gini’, max_depth&#x3D;None, bootstrap&#x3D;True, random_state&#x3D;None, min_samples_split&#x3D;2)</p>
<ul>
<li>随机森林分类器</li>
<li>n_estimators：integer，optional（default &#x3D; 10）森林里的树木数量120,200,300,500,800,1200</li>
<li>criteria：string，可选（default &#x3D;“gini”）分割特征的测量方法</li>
<li>max_depth：integer或None，可选（默认&#x3D;无）树的最大深度 5,8,15,25,30</li>
<li>max_features&#x3D;”auto”,每个决策树的最大特征数量<ul>
<li>If “auto”, then <code>max_features=sqrt(n_features)</code>.</li>
<li>If “sqrt”, then <code>max_features=sqrt(n_features)</code> (same as “auto”).</li>
<li>If “log2”, then <code>max_features=log2(n_features)</code>.</li>
<li>If None, then <code>max_features=n_features</code>.</li>
</ul>
</li>
<li>bootstrap：boolean，optional（default &#x3D; True）是否在构建树时使用放回抽样</li>
<li>min_samples_split:节点划分最少样本数</li>
<li>min_samples_leaf:叶子节点的最小样本数</li>
</ul>
</li>
<li><p>超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</p>
</li>
</ul>
<h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机森林去进行预测</span></span><br><span class="line">rf = RandomForestClassifier()</span><br><span class="line"></span><br><span class="line">param = &#123;<span class="string">&quot;n_estimators&quot;</span>: [<span class="number">120</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">1200</span>], <span class="string">&quot;max_depth&quot;</span>: [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">30</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超参数调优</span></span><br><span class="line">gc = GridSearchCV(rf, param_grid=param, cv=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">gc.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;随机森林预测的准确率为：&quot;</span>, gc.score(x_test, y_test))</span><br></pre></td></tr></table></figure>

<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ul>
<li>在当前所有算法中，具有极好的准确率</li>
<li>能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维</li>
<li>能够评估各个特征在分类问题上的重要性</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/18/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/" data-id="clgqem7w0002dh9d339i49ouo" data-title="随机深林" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AppDelegate组件解耦" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/" class="article-date">
  <time class="dt-published" datetime="2019-09-16T03:29:30.000Z" itemprop="datePublished">2019-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/">AppDelegate组件解耦</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在没有实行组件化的项目中，经常会在 AppDelegate 看到各类初始化代码，这一部分代码一般用以配置某些 key 以及 secret ，或者开启某些服务，常见的有第三方推送、统计分析、IM服务等。当然，也有可能是开启一些自身的服务，比如 log 日志、 数据库初始化等。当一个 App 达到一定体量后， 未经整理的 AppDelegate 可能会变得臃肿。那么在实行组件化之后，该如何处理这部分代码呢？</p>
<h2 id="不管理组件生命周期"><a href="#不管理组件生命周期" class="headerlink" title="不管理组件生命周期"></a>不管理组件生命周期</h2><p>不对组件生命周期进行管理，那么只能继续将这些初始化代码放在主工程的 AppDelegate 中，而针对上文所说的 AppDelegate 臃肿的问题，也可以通过简单的封装来优化。</p>
<p>但是，这种做法会引发组件独立性问题。比如存在能独立运行的组件 A、B，B 依赖 A， A 生效需要在 App Launch 时调用配置代码 Code-A。如果采用上述做法，那么组件 A 所在示例工程的 AppDelegate 中，需要调用 Code-A 进行配置，而组件 B 因为依赖了 组件 A ，要使组件 B 能成功运行，也需要在 B 的示例工程添加 Code-A 进行配置。同样主工程的 AppDelegate 中也存在一份 Code-A 配置代码。可以看到，这种重复手动配置的做法是比较繁琐和难看的，这也是为什么要对组件生命周期进行管理的原因。</p>
<h2 id="现有实现管理方案"><a href="#现有实现管理方案" class="headerlink" title="现有实现管理方案"></a>现有实现管理方案</h2><p>从组件和主工程的关系切入，既然组件需要在 App 生命周期的某些阶段处理特定的事务，那么就提供特定的回调方法供组件使用。 App 生命周期各个阶段产生的事件，可以通过让 AppDelegate 遵守 UIApplicationDelegate 协议并实现不同的代理方法进行捕获。</p>
<p>要想把当前阶段 App 产生的事件分发给各个组件，最简单的方案就是如 <a target="_blank" rel="noopener" href="http://limboy.me/tech/2016/03/10/mgj-components.html">limboy</a> 所说，在 AppDelegate 的各个代理方法里，手动调一遍组件的对应方法，如果组件实现了对应的代理方法，就执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [MGJApp startApp];</span><br><span class="line"></span><br><span class="line">    [[ModuleManager sharedInstance] loadModuleFromPlist:[[NSBundle mainBundle] pathForResource:@&quot;modules&quot; ofType:@&quot;plist&quot;]];</span><br><span class="line">    NSArray *modules = [[ModuleManager sharedInstance] allModules];</span><br><span class="line">    for (id&lt;ModuleProtocol&gt; module in modules) &#123;</span><br><span class="line">        if ([module respondsToSelector:_cmd]) &#123;</span><br><span class="line">            [module application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self trackLaunchTime];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这种方式缺点也很明显，组件需要依赖主工程的 AppDelegate 是否实现了 UIApplicationDelegate 的代理方法，如果没有的话，即使组件方实现了对应的代理方法，依然无法捕获到事件。</p>
<p>再来看下 <a target="_blank" rel="noopener" href="http://www.jianshu.com/u/d8a653fc1cb1">caojun</a> 的处理方案 <a target="_blank" rel="noopener" href="https://github.com/mdsb100/YTXModule">YTXModule</a>。 这个方案主要思路是通过 runtime method swizzling，替换 AppDelegate 中实现的 UIApplicationDelegate 代理方法，然后在 swizzled method 中，执行事件分发。 YTXModule 提供了一些宏定义，精简了方法替换流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIApplication (YTXModule)</span><br><span class="line">- (void)module_setDelegate:(id&lt;UIApplicationDelegate&gt;) delegate</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    static dispatch_once_t delegateOnceToken;</span><br><span class="line">    dispatch_once(&amp;delegateOnceToken, ^&#123;</span><br><span class="line">        SWIZZLE_DELEGATE_METHOD(applicationDidFinishLaunching:);</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    [self module_setDelegate:delegate];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation YTXModule</span><br><span class="line">...</span><br><span class="line">+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions</span><br><span class="line">&#123;   </span><br><span class="line">    DEF_APPDELEGATE_METHOD_CONTAIN_RESULT(application, launchOptions);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，由于 method swizzling 是在不同类型载体（AppDelegate对象 &lt;-&gt; YTXModule类）间交换的方法，所以会造成在 <code>+ytxmodule_applicationDidFinishLaunching:</code> 中调用 <code>self</code> 时，获取的并不是 YTXModule类，而是 AppDelegate对象，因为方法替换实际上替换了 IMP，并没有改变实参，参照 <code>objc_msgSend(id self, SEL op, ... )</code> 的参数排列，可以明确第一个参数是消息接收者，也就是 AppDelegate对象。通过上述分析可以知道，如果直接进行方法替换，不做特殊处理，使用以下代码将会抛出 <code>unrecognized selector </code>异常 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	// self is AppDelegate instance</span><br><span class="line">    [self ytxmodule_application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而以下代码，是可以正常运行的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line"> 	[YTXModule ytxmodule_application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 caojun 在方法替换时，给 AppDelegate 添加了相同命名的实例方法，规避了这个异常 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Swizzle(Class class, SEL originalSelector, Method swizzledMethod)</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">    SEL swizzledSelector = method_getName(swizzledMethod);</span><br><span class="line"></span><br><span class="line">    BOOL didAddMethod =</span><br><span class="line">    class_addMethod(class,</span><br><span class="line">                    originalSelector,</span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">    if (didAddMethod &amp;&amp; originalMethod) &#123;</span><br><span class="line">        class_replaceMethod(class,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    // 这一步给 AppDelegate 添加相同命名的实例方法，并且其 IMP 是 AppDelegate 自身方法的原实现</span><br><span class="line">    class_addMethod(class,</span><br><span class="line">                    swizzledSelector,</span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽说这种方案也能实现事件的分发，但是在不同类型载体间使用 method swizzling 还是应该避免的，对其他开发者不是很友好。并且这种方案也存在依赖 YTXModule 是否替换了 UIApplicationDelegate 的代理方法问题，如果没有，组件方是无法捕获事件的。</p>
        
          <p class="article-more-link">
            <a href="/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/" data-id="clgqem7v60001h9d389nbda5p" data-title="AppDelegate组件解耦" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS-AppDelegate/" rel="tag">iOS AppDelegate</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-carsh定位总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/09/carsh%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2019-09-09T04:01:49.000Z" itemprop="datePublished">2019-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/09/carsh%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/">carsh定位总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Crash-日志的渠道"><a href="#Crash-日志的渠道" class="headerlink" title="Crash 日志的渠道"></a>Crash 日志的渠道</h3><ul>
<li><strong>苹果收集的 Crash 日志</strong></li>
<li><ul>
<li>用户手机上 设置 -&gt; 隐私 -&gt; 分析 里面的，可以连接电脑 Xcode 导出。</li>
<li>在 Xcode -&gt; Window -&gt; Organizer -&gt; Crashes 里面可以查看</li>
</ul>
</li>
<li><strong>自己应用内收集的</strong></li>
<li><ul>
<li>接入一些 APM 产品， 如 EMAS、mPaaS、phabricator 等。</li>
<li>接入 PLCrashReporter 、 KSCrash 等 SDK 进行收集，上报到自建平台统计</li>
</ul>
</li>
</ul>
<p>![image-20220909155818088](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220909155818088.png)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/09/carsh%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/" data-id="clgqem7vo0018h9d3d28mdfdu" data-title="carsh定位总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-App瘦身" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/02/App%E7%98%A6%E8%BA%AB/" class="article-date">
  <time class="dt-published" datetime="2019-09-02T09:07:21.000Z" itemprop="datePublished">2019-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/02/App%E7%98%A6%E8%BA%AB/">App瘦身</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-分析当前ipa的组成"><a href="#1-分析当前ipa的组成" class="headerlink" title="1 分析当前ipa的组成"></a>1 分析当前ipa的组成</h2><p>一般一个ipa会包含：</p>
<p>1） 资源文件</p>
<ul>
<li>本地文件：数据、配置、数据库等等</li>
<li>字体文件</li>
<li>图片资源</li>
</ul>
<ol start="2">
<li>源代码</li>
</ol>
<p>通过生成linkmap文件，分析源代码生成的编译文件的大小。在Build Settings中Write Link Map File设置为Yes (记住release时候不要设置为Yes)。</p>
<p>编译之后会在build目录中生成两个LinkMap文件： XXX-LinkMap-normal-i386和XXX-LinkMap-normal-x86_64，分别代表在模拟器中32位和64位指令集生成的LinkMap文件。关于LinkMap的文件详细结构解释可以参考：<a target="_blank" rel="noopener" href="http://blog.cnbang.net/tech/2296/">http://blog.cnbang.net/tech/2296/</a></p>
<p>LinkMap会包含每个可执行文件的偏移量及大小，所以可以很方便的知道每个可执行文件的大小。可以使用LinkMap分析工具：<a target="_blank" rel="noopener" href="https://github.com/huanxsd/LinkMap">https://github.com/huanxsd/LinkMap</a></p>
<p><img src="https://images2017.cnblogs.com/blog/746857/201709/746857-20170906191955007-1995207350.png" alt="img"></p>
<h2 id="2-资源瘦身"><a href="#2-资源瘦身" class="headerlink" title="2 资源瘦身"></a>2 资源瘦身</h2><h3 id="无用的图片文件"><a href="#无用的图片文件" class="headerlink" title="无用的图片文件"></a>无用的图片文件</h3><p>查找无用的图片文件，使用LSUnusedResources（<a target="_blank" rel="noopener" href="https://github.com/tinymind/LSUnusedResources%EF%BC%89">https://github.com/tinymind/LSUnusedResources）</a></p>
<p><img src="https://github.com/tinymind/LSUnusedResources/raw/master/LSUnusedResourcesExample.gif" alt="img"></p>
<h3 id="无损压缩图片"><a href="#无损压缩图片" class="headerlink" title="无损压缩图片"></a>无损压缩图片</h3><p>使用ImageOptim（<a target="_blank" rel="noopener" href="https://github.com/ImageOptim/ImageOptim%EF%BC%89%E8%BF%9B%E8%A1%8Cpng%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9">https://github.com/ImageOptim/ImageOptim）进行png文件的无损压缩</a></p>
<p><img src="https://images2017.cnblogs.com/blog/746857/201709/746857-20170906192458647-804731014.png" alt="img"></p>
<h3 id="WebP图片压缩"><a href="#WebP图片压缩" class="headerlink" title="WebP图片压缩"></a>WebP图片压缩</h3><p>WebP是Google提供的一种图片编码格式，通常情况下WebP格式的图片是原始JPG&#x2F;PNG图片的1&#x2F;3，所以对于重度依赖图片显示的应用，转换使用WebP可以节省大量的网络传输数据和时间。对于APP瘦身，使用WebP格式可能是一种方式，可以使用WebP格式的图片替代现有的图片资源，可以一定程度的节省空间。</p>
<p>使用WebP转换工具（<a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/precompiled%EF%BC%89%E5%B0%9D%E8%AF%95%E8%BD%AC%E6%8D%A2%E4%BA%86%E5%87%A0%E5%BC%A0%E8%BE%83%E5%A4%A7%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://developers.google.com/speed/webp/docs/precompiled）尝试转换了几张较大的图片，效果如下：</a></p>
<p><img src="https://images2017.cnblogs.com/blog/746857/201709/746857-20170906192710054-1516701797.png" alt="img"></p>
<p>iOS原生并不支持WebP格式加载，需要引入SDWebImage&#x2F;WebP，详细可以参考：<a target="_blank" rel="noopener" href="http://blog.devzeng.com/blog/ios-webp-usage.html">http://blog.devzeng.com/blog/ios-webp-usage.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`NSString *path = [[NSBundle mainBundle] pathForResource:``@&quot;logo&quot;` `ofType:``@&quot;webp&quot;``];``NSData *data = [[NSData alloc] initWithContentsOfFile:path];``UIImage *img = [UIImage sd_imageWithWebPData:data];``self.imageView.image = img;`</span><br></pre></td></tr></table></figure>

<p>使用WebP格式的图片，似乎就抛弃了iOS @2x @3x按照设备加载对应图片的机制，所以应该还可以删除所有@2x图片，不过加载速度比原生较慢。</p>
        
          <p class="article-more-link">
            <a href="/2019/09/02/App%E7%98%A6%E8%BA%AB/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/02/App%E7%98%A6%E8%BA%AB/" data-id="clgqem7vc0006h9d32pv752vz" data-title="App瘦身" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-CocoaPods忽略三方组件编译警告" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/30/CocoaPods%E5%BF%BD%E7%95%A5%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A/" class="article-date">
  <time class="dt-published" datetime="2019-08-30T12:23:11.000Z" itemprop="datePublished">2019-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/30/CocoaPods%E5%BF%BD%E7%95%A5%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A/">cocoaPods忽略警告</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>为了减少组件化后的工程集成时间，我们一般都会将三方库放到私有 GitLab 中，这也有利于开发者根据自家业务，对三方库进行定制包装。但是如果有些三方库更新较慢，以至于让新版本的 Xcode 产生很多警告，这就比较烦了，因为大部分情况下，更改三方库并不是一个明智的选择。</p>
<p>Podfile 提供了 <code>inhibit_all_warnings!</code> 以屏蔽所有 pod target 的警告，但其中也包括了非三方组件。同时，Podfile 提供了 <code>inhibit_warnings</code> 去针对单个 pod 的编译警告进行控制，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;SSZipArchive&#x27;, :inhibit_warnings =&gt; true</span><br></pre></td></tr></table></figure>

<p>以上代码只会屏蔽 SSZipArchive 组件的警告，这比较符合我们的诉求。不过 <code>inhibit_warnings</code> 只会禁止当前 pod 的警告，并不会一同处理依赖组件的警告，这就要求我们在 Podfile 中显式依赖所有三方组件，并且设置 <code>inhibit_warnings</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def add_files_to_build_phases(native_target, test_native_targets)</span><br><span class="line">	...</span><br><span class="line">	flags = compiler_flags_for_consumer(consumer, arc)</span><br><span class="line">  regular_file_refs = project_file_references_array(files, &#x27;source&#x27;)</span><br><span class="line">  native_target.add_file_references(regular_file_refs, flags)</span><br><span class="line">	...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def compiler_flags_for_consumer(consumer, arc)</span><br><span class="line">  ...</span><br><span class="line">  if target.inhibit_warnings?</span><br><span class="line">    flags &lt;&lt; &#x27;-w -Xanalyzer -analyzer-disable-all-checks&#x27;</span><br><span class="line">  end</span><br><span class="line">  flags * &#x27; &#x27;</span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>可以看到，在添加文件至对应 target 时，<code>-w -Xanalyzer -analyzer-disable-all-checks</code> 同时被添加到了文件的 compiler flags （在Target -&gt; Build Phases -&gt; Compile Sources 中可见）。结合 Installer 的 install! 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def install!</span><br><span class="line">  prepare</span><br><span class="line">  resolve_dependencies</span><br><span class="line">  download_dependencies</span><br><span class="line">  validate_targets</span><br><span class="line">  generate_pods_project</span><br><span class="line">  if installation_options.integrate_targets?</span><br><span class="line">    integrate_user_project</span><br><span class="line">  else</span><br><span class="line">    UI.section &#x27;Skipping User Project Integration&#x27;</span><br><span class="line">  end</span><br><span class="line">  perform_post_install_actions</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def download_dependencies</span><br><span class="line">  UI.section &#x27;Downloading dependencies&#x27; do</span><br><span class="line">    install_pod_sources</span><br><span class="line">    run_podfile_pre_install_hooks</span><br><span class="line">    clean_pod_sources</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><code>generate_pods_project</code> 方法执行了 PodTargetInstaller 的 install! 操作，将文件添加到了 pod target ，那么只能在其之前的 <code>pre_install</code> 设置相关属性了。从上面的代码还可以看出，执行 <code>pre_install</code> 前就已经 <code>resolve_dependencies</code> 了，也就是说我们可以拿到 Analyzer 分析的完整结果 AnalysisResult :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># @return [Hash&#123;TargetDefinition =&gt; Array&lt;Specification&gt;&#125;] the</span><br><span class="line">#         specifications grouped by target.</span><br><span class="line">#</span><br><span class="line">attr_accessor :specs_by_target</span><br><span class="line"></span><br><span class="line"># @return [Array&lt;Specification&gt;] the specifications of the resolved</span><br><span class="line">#         version of Pods that should be installed.</span><br><span class="line">#</span><br><span class="line">attr_accessor :specifications</span><br><span class="line"></span><br><span class="line"># @return [Array&lt;AggregateTarget&gt;] The aggregate targets created for each</span><br><span class="line">#         &#123;TargetDefinition&#125; from the &#123;Podfile&#125;.</span><br><span class="line">#</span><br><span class="line">attr_accessor :targets</span><br></pre></td></tr></table></figure>

<p>上面列出了此次需要涉及到的 AnalysisResult 属性。这里要注意的是 <code>targets</code> 属性是不包含 Pods Target 的，它只包含了 Podfile 里面声明的 target ，一般为组件本身，以及组件Tests。如果不确定要设置哪个 target ，可以手动设置 <code>inhibit_warnings</code> ，然后通过以下代码打印出 hash :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">pod &#x27;SSZipArchive&#x27;, :inhibit_warnings =&gt; true</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pre_install do |installer|</span><br><span class="line">	require &#x27;pp&#x27;</span><br><span class="line">  installer.analysis_result.specs_by_target.each_key do |target_definition|</span><br><span class="line">  	pp target_definition.to_hash</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这里我们对所有涉及到的 target 都进行设置。接着看下 CocoaPods Core 代码中 Podfile 是如何设置 <code>inhibit_warnings</code> 的 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def pod(name = nil, *requirements)</span><br><span class="line">  ...</span><br><span class="line">  current_target_definition.store_pod(name, *requirements)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def store_pod(name, *requirements)</span><br><span class="line">	...</span><br><span class="line">  parse_inhibit_warnings(name, requirements)</span><br><span class="line">  ...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def parse_inhibit_warnings(name, requirements)</span><br><span class="line">	...</span><br><span class="line">  set_inhibit_warnings_for_pod(pod_name, should_inhibit)</span><br><span class="line">	...</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"># Inhibits warnings for a specific pod during compilation.</span><br><span class="line">def set_inhibit_warnings_for_pod(pod_name, should_inhibit)</span><br><span class="line">  hash_key = case should_inhibit</span><br><span class="line">             when true</span><br><span class="line">               &#x27;for_pods&#x27;</span><br><span class="line">             when false</span><br><span class="line">               &#x27;not_for_pods&#x27;</span><br><span class="line">             when nil</span><br><span class="line">               return</span><br><span class="line">             else</span><br><span class="line">               raise ArgumentError, &quot;Got `#&#123;should_inhibit.inspect&#125;`, should be a boolean&quot;</span><br><span class="line">             end</span><br><span class="line">  raw_inhibit_warnings_hash[hash_key] ||= []</span><br><span class="line">  raw_inhibit_warnings_hash[hash_key] &lt;&lt; pod_name</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>找到了设置 inhibit_warnings 的 public 方法 <code>set_inhibit_warnings_for_pod</code>。</p>
<p>由于我们的三方库集中放在 cocoapods-repos 的 group 下，最终的 <code>pre_install</code> 长这样 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pre_install do |installer|</span><br><span class="line">  installer.analysis_result.specs_by_target.each_key do |target_definition|</span><br><span class="line">    installer.analysis_result.specifications.each do |spec|</span><br><span class="line">      source = spec.attributes_hash[&#x27;source&#x27;]</span><br><span class="line">      source &amp;&amp;= source[&#x27;git&#x27;]</span><br><span class="line">      next unless source &amp;&amp; source.include?(&#x27;cocoapods-repos&#x27;)</span><br><span class="line"></span><br><span class="line">      targets = (Array(target_definition) + target_definition.children)</span><br><span class="line">      targets.each do |target|</span><br><span class="line">        target.set_inhibit_warnings_for_pod(spec.root.name, true)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/08/30/CocoaPods%E5%BF%BD%E7%95%A5%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A/" data-id="clgqem7vd0008h9d3ew6ba2aq" data-title="cocoaPods忽略警告" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocoaPods/" rel="tag">cocoaPods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/" rel="tag">flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS-AppDelegate/" rel="tag">iOS AppDelegate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" rel="tag">强化学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" rel="tag">量化交易</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/cocoaPods/" style="font-size: 10px;">cocoaPods</a> <a href="/tags/flutter/" style="font-size: 10px;">flutter</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS-AppDelegate/" style="font-size: 10px;">iOS AppDelegate</a> <a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">强化学习</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" style="font-size: 10px;">量化交易</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/11/%E5%AE%B9%E5%99%A8%E5%8C%96/">首页容器化</a>
          </li>
        
          <li>
            <a href="/2022/08/14/%E5%8A%A8%E6%80%81%E5%BA%93%E6%87%92%E5%8A%A0%E8%BD%BD/">动态库懒加载</a>
          </li>
        
          <li>
            <a href="/2022/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B2%BB%E7%90%86/">多线程问题专项治理</a>
          </li>
        
          <li>
            <a href="/2021/07/20/%E7%9B%B4%E6%92%AD%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/">直播性能指标监控方案</a>
          </li>
        
          <li>
            <a href="/2021/05/14/%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/">视频相关优化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 xushuanghui<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>