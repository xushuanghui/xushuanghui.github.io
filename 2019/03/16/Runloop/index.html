<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Runloop | xushuanghui</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：  控制线程的生命周期【线程保活】 解决NSTimer在滑动过程中停止工作的问题及衍生问题 监控应用卡顿 性能优化   一、线程保活线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且">
<meta property="og:type" content="article">
<meta property="og:title" content="Runloop">
<meta property="og:url" content="http://example.com/2019/03/16/Runloop/index.html">
<meta property="og:site_name" content="xushuanghui">
<meta property="og:description" content="概述 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：  控制线程的生命周期【线程保活】 解决NSTimer在滑动过程中停止工作的问题及衍生问题 监控应用卡顿 性能优化   一、线程保活线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/bGvNnoDlcUdYy74.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/I5ULo7fuzgTEmct.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/f8IKlHWxghdbcwS.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/8c2TWPbS35avn6t.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVF5ChLqicEMicHL29cjNDL6wJ7qRwaHlZSP7rVd56GTpZD74jXr4mhalibWQgDzwO1OojMYzWmYTGL1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="article:published_time" content="2019-03-16T07:23:07.000Z">
<meta property="article:modified_time" content="2023-04-13T10:34:27.645Z">
<meta property="article:author" content="xushuanghui">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png">
  
    <link rel="alternate" href="/atom.xml" title="xushuanghui" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">xushuanghui</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Runloop" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/03/16/Runloop/" class="article-date">
  <time class="dt-published" datetime="2019-03-16T07:23:07.000Z" itemprop="datePublished">2019-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Runloop
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：</p>
<ul>
<li>控制线程的生命周期【线程保活】</li>
<li>解决NSTimer在滑动过程中停止工作的问题及衍生问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
<p><img src="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png" alt="2020-12-16-4.12.57.png"></p>
<h2 id="一、线程保活"><a href="#一、线程保活" class="headerlink" title="一、线程保活"></a>一、线程保活</h2><p>线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且让子线程一直存活着,为了避免来回多次创建毁线程的动作, 降低性能消耗.</p>
<h3 id="情景1"><a href="#情景1" class="headerlink" title="情景1"></a>情景1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">//定义继承自NSThread线程</span><br><span class="line">@interface ZXYThread : NSThread</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZXYThread</span><br><span class="line">//线程销毁会被调用</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    self.thread = [[ZXYThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    NSLog(@&quot;%s ----end----&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>当执行完上面的代码后,会发现打印出如下-[子线程也就销毁了]</p>
<p>但是运行完App,当点击App时没有反应,也可以证明此线程已经销毁.如果改进让线程处于随时接受命令的状态呢?</p>
<h3 id="情景2"><a href="#情景2" class="headerlink" title="情景2"></a>情景2</h3><p>从Runloop中得知,如果Mode里没有任何的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer, Runloop会立马退出.</p>
<p>所以会想到能不能向其中加入上面中的一个是否可以如下: [run 方法中]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 这个方法的目的：线程保活</span><br><span class="line">- (void)run &#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">    // 往RunLoop里面添加Source\Timer\Observer</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">//    [[NSRunLoop currentRunLoop] addTimer:[[NSTimer alloc]init] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">    NSLog(@&quot;%s ----end----&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在run方法中加入上面代码,让线程一直不死,打印屏幕界面:</p>
<p><img src="https://i.loli.net/2020/12/16/bGvNnoDlcUdYy74.png" alt="2020-12-16-4.14.23.png"></p>
<p>好像上面已经满足了要求,达到了线程不死的状态,但是能不能在销毁页面控制器的时候,也销毁定时器,并且随时停掉定时器.</p>
<span id="more"></span>

<h3 id="情景3"><a href="#情景3" class="headerlink" title="情景3"></a>情景3</h3><p><strong>知识点:</strong> </p>
<blockquote>
<p>如何停止runloop?通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>方法可停掉定时器,但是对于用<code>[[NSRunLoop currentRunLoop] run]</code>的Runloop是不会停掉的,因为通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>方法仅仅是停掉了本次的Runloop,而不是停掉所有的,但是<code>[[NSRunLoop currentRunLoop] run]</code>的run方法是一直有runloop循环,所以通过<code>[[NSRunLoop currentRunLoop] run]</code>方法是不可能被停掉runloop的</p>
<p>那应该改成什么样的? —-[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</p>
</blockquote>
<p>下面直接用代码来解释,里面已经写明了代码思路,下面是A页面-&gt;B页面-&gt;A页面</p>
<p><img src="https://i.loli.net/2020/12/16/I5ULo7fuzgTEmct.png" alt="2020-12-16-4.14.32.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">//继承自NSThead的子线程</span><br><span class="line">@property (strong, nonatomic) ZXYThread *thread;</span><br><span class="line">//有个暂停定时器的需求,stopped代表是否点击了暂停</span><br><span class="line">@property (assign, nonatomic, getter=isStoped) BOOL stopped;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //NSThread使用block的方法,消除循环引用</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">    self.stopped = NO;</span><br><span class="line">    self.thread = [[ZXYThread alloc] initWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;%@----begin----&quot;, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">        // 往RunLoop里面添加Source\Timer\Observer</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">        while (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;%@----end----&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    if (!self.thread) return;</span><br><span class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子线程需要执行的任务</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void) stop &#123;</span><br><span class="line">    if (!self.thread) return;</span><br><span class="line">    // 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走）</span><br><span class="line">    [self performSelector:@selector(stopThread) onThread:self.thread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用于停止子线程的RunLoop</span><br><span class="line">- (void)stopThread</span><br><span class="line">&#123;</span><br><span class="line">    // 设置标记为YES</span><br><span class="line">    self.stopped = YES;</span><br><span class="line"></span><br><span class="line">    // 停止RunLoop</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    NSLog(@&quot;%s %@&quot;, __func__, [NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">    // 清空线程</span><br><span class="line">    self.thread = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line"></span><br><span class="line">    [self stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果想将上面的代码抽取出来应该怎么办呢?</p>
<h3 id="情景4"><a href="#情景4" class="headerlink" title="情景4"></a>情景4</h3><p>此处封装工具类并不是直接继承自NSThread,而是继承自NSObject[因为并不想让别人直接能调用NSThread里面的方法.]这样符合开闭原则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">typedef void (^ZXYPermenantThreadTask)(void);</span><br><span class="line">@interface ZXYPermenantThread : NSObject</span><br><span class="line">/**</span><br><span class="line"> 在当前子线程执行一个任务</span><br><span class="line"> */</span><br><span class="line">- (void)executeTask:(ZXYPermenantThreadTask)task;</span><br><span class="line">/**</span><br><span class="line"> 结束线程</span><br><span class="line"> */</span><br><span class="line">- (void)stop;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ZXYPermenantThread.h&quot;</span><br><span class="line"></span><br><span class="line">/** ZXYThread **/</span><br><span class="line">@interface ZXYThread : NSThread</span><br><span class="line">@end</span><br><span class="line">@implementation ZXYThread</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/** ZXYPermenantThread **/</span><br><span class="line">@interface ZXYPermenantThread()</span><br><span class="line">@property (strong, nonatomic) ZXYThread *innerThread;</span><br><span class="line">@property (assign, nonatomic, getter=isStopped) BOOL stopped;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZXYPermenantThread</span><br><span class="line">#pragma mark - public methods</span><br><span class="line">- (instancetype)init&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.stopped = NO;</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        self.innerThread = [[ZXYThread alloc] initWithBlock:^&#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        [self.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)executeTask:(ZXYPermenantThreadTask)task&#123;</span><br><span class="line">    if (!self.innerThread || !task) return;</span><br><span class="line"></span><br><span class="line">    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stop&#123;</span><br><span class="line">    if (!self.innerThread) return;</span><br><span class="line">    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">    [self stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - private methods</span><br><span class="line">- (void)__stop&#123;</span><br><span class="line">    self.stopped = YES;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">    self.innerThread = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)__executeTask:(ZXYPermenantThreadTask)task&#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>上面是针对Runloop在实际开发中的第一个使用场景,那么我们是否在一些好的开源项目中使用过呢或者是看到过呢?</p>
<p><strong>拓展[AFNetworking也使用到了Runloop的线程保活]</strong></p>
<p>AFNetworking中的ANURLConnectionOperation是基于NSURLConnection构建,本质是希望能在后台线程接收到Delegate回调.为此AFNetworking单独创建了一个线程, 并在这个线程中开启了一个Runloop:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runloop启动前必须要至少一个Timer&#x2F;Observer&#x2F;Source,所以AFNetworking在[runLoop run]</p>
<p>之前创建了NSMachPort添加进去了.通常情况下调用者需要持有这个NSMachPort并在外部线程通过这个port发送消息到loop内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时,AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中</p>
<h2 id="二、NSTimer问题"><a href="#二、NSTimer问题" class="headerlink" title="二、NSTimer问题"></a>二、NSTimer问题</h2><p>在日常开发中,列表经常会用到NSTimer倒计时问题,或者Interview的时候被面试官问到: NSTimer准时嘛等问题?今天就展开讲述一下原因及方案,最后讲述衍生出来的问题循环引用!争取彻底解决NSTimer带来的疑问?</p>
<h3 id="问题一、-NSTimer定时器不准"><a href="#问题一、-NSTimer定时器不准" class="headerlink" title="问题一、 NSTimer定时器不准"></a>问题一、 NSTimer定时器不准</h3><p><strong>原因</strong></p>
<ul>
<li>NSTimer被添加在mainRunloop中,模式是NSDefaultRunLoopMode, mainRunloop负责所有的主线程事件,例如UI界面的操作,负责的运算使当前Runloop持续的时间超过了定时器的间隔时间,那么下一次定时就被延后,这样就造成timer的阻塞</li>
<li>模式的切换,当创建的timer被加入到NSDefaultRunLoopMode时,此时如果有滑动UIScrollView的操作时,runloop的mode会切换为TrackingRunloopMode,这时tiemr会停止回调</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>Mode方式的改变,兼顾TrackingRunloopMode</li>
<li>在子线程中创建timer,在主线程进行定时任务的操作或者在子线程中创建timer,在子线程中进行定时任务的操作,需要UI的操作时再切换到主线程进行操作</li>
<li>GCD操作: dispatch_source_create以及depatch_resume等方法</li>
</ul>
<p><strong>方案一</strong></p>
<p>主线程的Runloop使用到的主要有两种模式, NSDefaultRunLoopMode与TrackingRunloopMode模式</p>
<p>添加定时器到主线程的CommonMode中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop mainRunLoop]addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>

<p><strong>方案二</strong></p>
<p>子线程创建timer,主线程执行定时或者子线程创建timer,在子线程执行定时,需要刷新再到主线程</p>
<p>子线程启动NSTimer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        __strong __typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf) &#123;</span><br><span class="line">            strongSelf.countTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:strongSelf selector:@selector(countDown) userInfo:nil repeats:YES];</span><br><span class="line">            NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class="line">            [runloop addTimer:strongSelf.countTimer forMode:NSDefaultRunLoopMode];</span><br><span class="line">            [runloop run];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>主线程更新UI</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self.jumpBTN setTitle:[NSString stringWithFormat:@&quot;跳过 %lds&quot;,(long)self.count] forState:UIControlStateNormal];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>方案三</strong></p>
<p>使用 GCD 的定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;myqueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    //创建定时器</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    //设置时间（start:几s后开始执行；interval:时间间隔）</span><br><span class="line">    uint64_t start = 2.0;    //2s后开始执行</span><br><span class="line">    uint64_t interval = 1.0; //每隔1s执行</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);</span><br><span class="line">    //设置回调</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">       NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    //启动定时器</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line"></span><br><span class="line">    self.timer = timer;</span><br></pre></td></tr></table></figure>

<h3 id="问题二、NSTimer循环引用"><a href="#问题二、NSTimer循环引用" class="headerlink" title="问题二、NSTimer循环引用"></a>问题二、NSTimer循环引用</h3><p><strong>常识</strong></p>
<p>这三个方法直接将timer添加到了当前runloop default mode，而不需要我们自己操作，当然这样的代价是runloop只能是当前runloop，模式是default mode:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;</span><br></pre></td></tr></table></figure>

<p>下面五种创建，不会自动添加到runloop，还需调用addTimer:forMode:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;</span><br></pre></td></tr></table></figure>

<p>在实际项目开发中,使用NSTimer解决定时发送任务的需求,但是还是会产生循环引用,今天讲述本项目中的解决方案.<br>循环引用（Circular Reference）是指两个对象之间相互强引用，两者无法按时释放，从而导致内存泄露.如下:</p>
<p><img src="https://i.loli.net/2020/12/16/f8IKlHWxghdbcwS.png" alt="2020-12-16-4.14.47.png"></p>
<p>发现两者相互引用,都不能得以释放,造成了循环引用</p>
<p><strong>方案一、给self添加中间件</strong></p>
<p>引入一个对象proxy,proxy弱引用self,然后proxy传入NSTimer. self强引用NSTimer, NSTimer强引用proxy,proxy弱引用着self,这样通过弱引用解决了相互引用,就不会造成环..本项目中使用的方法是引入中间控件HCCProxy1</p>
<p><img src="https://i.loli.net/2020/12/16/8c2TWPbS35avn6t.png" alt="2020-12-16-4.14.54.png"></p>
<p>定义一个继承自NSObject的中间代理对象HCCProxy1,ViewController不持有timer,而是持有HCCProxy1实例, 让HCCProxy1实例弱引用ViewController, timer强引用HCCProxy1实例,如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface HCCProxy1 : NSObject</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@property (weak, nonatomic) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HCCProxy1</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</span><br><span class="line">    HCCProxy1 *proxy = [[HCCProxy1 alloc] init];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    return self.target;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在项目中使用如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[HCCProxy1 proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展:</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector是什么？</li>
</ul>
<p>  消息转发，简单来说就是如果当前对象没有实现这个方法，系统会到这个方法里来找实现对象。</p>
<p>本文中由于当前target是HCCProxy1，但是HCCProxy1没有实现方法(当然也不需要它实现)，让系统去找target实例的方法实现，也就是去找ViewController中的方法实现。</p>
</blockquote>
<p><strong>方案二、使用继承自NSProxy类HCCProxy的消息转发</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface HCCProxy : NSProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@property (weak, nonatomic) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HCCProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target&#123;</span><br><span class="line">    // NSProxy对象不需要调用init，因为它本来就没有init方法</span><br><span class="line">    HCCProxy *proxy = [HCCProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation&#123;</span><br><span class="line">    [invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在项目中使用如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[HCCProxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、监控卡顿"><a href="#三、监控卡顿" class="headerlink" title="三、监控卡顿"></a>三、监控卡顿</h2><p>卡顿问题主要是主线程上无法响应用户交互的问题, 如果一个App时不时给你卡一下,有时还长时间没有响应,你还会继续使用嘛?答案当然是显然的</p>
<p>对于iOS开发来说,监控卡顿就是要去找到主线程都做了哪些事情,线程的消息事件依赖于NSRunloop的,所以从NSRunloop入手,就可以知道主线程上都调用了哪些方法.可以监听NSRunloop的状态,就能够发现调用方法是否执行时间过长从而判断是否出现了卡顿.所以推荐的监控卡顿方案是: 通过监控Runloop的状态来判断是否出现卡顿</p>
<p>下面我们讲解一下Runloop的底层常识吧</p>
<h3 id="1、知识-Runloop原理"><a href="#1、知识-Runloop原理" class="headerlink" title="1、知识-Runloop原理"></a>1、知识-Runloop原理</h3><p>Runloop的目的是,当有事情要去处理时保持线程忙,当没有事件要处理的时候让线程进入休眠.下面通过CFRunloop的源码来分享下Runloop的原理</p>
<p><strong>第一步:</strong></p>
<p>通知observers: Runloop要开始进入loop了,紧接着进入loop,代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//通知 observers</span><br><span class="line">if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) </span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">//进入 loop</span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong></p>
<p>开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通知 Observers RunLoop 会触发 Timer 回调</span><br><span class="line">if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">// 通知 Observers RunLoop 会触发 Source0 回调</span><br><span class="line">if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">// 执行 block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br></pre></td></tr></table></figure>

<p>接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (MACH_PORT_NULL != dispatchPort ) &#123;</span><br><span class="line">    Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">    if (hasMsg) goto handle_msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong></p>
<p>回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);</span><br><span class="line">if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) &#123;</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步</strong></p>
<p>进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒：</p>
<ul>
<li>基于 port 的 Source 事件；</li>
<li>Timer 时间到；*RunLoop 超时；</li>
<li>被调用者唤醒。</li>
</ul>
<p>等待唤醒的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">        // 基于 port 的 Source 事件、调用者唤醒</span><br><span class="line">        if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // Timer 时间到、RunLoop 超时</span><br><span class="line">        if (currentMode-&gt;_timerFired) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>

<p><strong>第五步</strong></p>
<p>唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br></pre></td></tr></table></figure>

<p><strong>第六步</strong></p>
<p>RunLoop 被唤醒后就要开始处理消息了：</p>
<ul>
<li>如果是 Timer 时间到的话，就触发 Timer 的回调；</li>
<li>如果是 dispatch 的话，就执行 block；</li>
<li>如果是 source1 事件的话，就处理这个事件。</li>
</ul>
<p>消息执行完后，就执行加到 loop 里的 block。代码如下：<br>handle_msg:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 如果 Timer 时间到，就触发 Timer 回调</span><br><span class="line">if (msg-is-timer) &#123;</span><br><span class="line">    __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125; </span><br><span class="line">// 如果 dispatch 就执行 block</span><br><span class="line">else if (msg_is_dispatch) &#123;</span><br><span class="line">    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// Source1 事件的话，就处理这个事件</span><br><span class="line">else &#123;</span><br><span class="line">    CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">    if (sourceHandledThisLoop) &#123;</span><br><span class="line">        mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第七步</strong></p>
<p>根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">     // 事件已处理完</span><br><span class="line">    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; else if (timeout) &#123;</span><br><span class="line">    // 超时</span><br><span class="line">    retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">    // 外部调用者强制停止</span><br><span class="line">    retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">    // mode 为空，RunLoop 结束</span><br><span class="line">    retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全部的内部代码如下: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">    /// 1\. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"></span><br><span class="line">            /// 2\. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3\. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 4\. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 5\. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 7\. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 8\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 10\. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。<br>整个Runloop过程,可以总结如下一张图片</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVF5ChLqicEMicHL29cjNDL6wJ7qRwaHlZSP7rVd56GTpZD74jXr4mhalibWQgDzwO1OojMYzWmYTGL1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="2、如何监测卡顿"><a href="#2、如何监测卡顿" class="headerlink" title="2、如何监测卡顿"></a>2、如何监测卡顿</h3><p>要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context);</span><br></pre></td></tr></table></figure>

<p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。</p>
<p>一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。</p>
<p>开启一个子线程监控的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建子线程监控</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    //子线程开启一个持续的 loop 用来进行监控</span><br><span class="line">    while (YES) &#123;</span><br><span class="line">        long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));</span><br><span class="line">        if (semaphoreWait != 0) &#123;</span><br><span class="line">            if (!runLoopObserver) &#123;</span><br><span class="line">                timeoutCount = 0;</span><br><span class="line">                dispatchSemaphore = 0;</span><br><span class="line">                runLoopActivity = 0;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿</span><br><span class="line">            if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                //将堆栈信息上报服务器的代码放到这里</span><br><span class="line">            &#125; //end activity</span><br><span class="line">        &#125;// end semaphore wait</span><br><span class="line">        timeoutCount = 0;</span><br><span class="line">    &#125;// end while</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是封装的一个工具类HCCMonitor,用于卡顿监测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface HCCMonitor : NSObject</span><br><span class="line">+ (instancetype)shareInstance;</span><br><span class="line">- (void)beginMonitor; //开始监视卡顿</span><br><span class="line">- (void)endMonitor;   //停止监视卡顿</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;HCCMonitor.h&quot;</span><br><span class="line">#import &quot;HCCCallStack.h&quot;</span><br><span class="line">#import &quot;HCCCPUMonitor.h&quot;</span><br><span class="line"></span><br><span class="line">@interface HCCMonitor() &#123;</span><br><span class="line">    int timeoutCount;</span><br><span class="line">    CFRunLoopObserverRef runLoopObserver;</span><br><span class="line">    @public</span><br><span class="line">    dispatch_semaphore_t dispatchSemaphore;</span><br><span class="line">    CFRunLoopActivity runLoopActivity;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, strong) NSTimer *cpuMonitorTimer;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HCCMonitor</span><br><span class="line"></span><br><span class="line">#pragma mark - Interface</span><br><span class="line">+ (instancetype)shareInstance &#123;</span><br><span class="line">    static id instance = nil;</span><br><span class="line">    static dispatch_once_t dispatchOnce;</span><br><span class="line">    dispatch_once(&amp;dispatchOnce, ^&#123;</span><br><span class="line">        instance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)beginMonitor &#123;</span><br><span class="line">    //监测 CPU 消耗</span><br><span class="line">    self.cpuMonitorTimer = [NSTimer scheduledTimerWithTimeInterval:3</span><br><span class="line">                                                             target:self</span><br><span class="line">                                                           selector:@selector(updateCPUInfo)</span><br><span class="line">                                                           userInfo:nil</span><br><span class="line">                                                            repeats:YES];</span><br><span class="line">    //监测卡顿</span><br><span class="line">    if (runLoopObserver) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchSemaphore = dispatch_semaphore_create(0); //Dispatch Semaphore保证同步</span><br><span class="line">    //创建一个观察者</span><br><span class="line">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">    runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                              kCFRunLoopAllActivities,</span><br><span class="line">                                              YES,</span><br><span class="line">                                              0,</span><br><span class="line">                                              &amp;runLoopObserverCallBack,</span><br><span class="line">                                              &amp;context);</span><br><span class="line">    //将观察者添加到主线程runloop的common模式下的观察中</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    //创建子线程监控</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        //子线程开启一个持续的loop用来进行监控</span><br><span class="line">        while (YES) &#123;</span><br><span class="line">            long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 20*NSEC_PER_MSEC));</span><br><span class="line">            if (semaphoreWait != 0) &#123;</span><br><span class="line">                if (!runLoopObserver) &#123;</span><br><span class="line">                    timeoutCount = 0;</span><br><span class="line">                    dispatchSemaphore = 0;</span><br><span class="line">                    runLoopActivity = 0;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿</span><br><span class="line">                if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    // 将堆栈信息上报服务器的代码放到这里</span><br><span class="line">                    //出现三次出结果</span><br><span class="line">//                    if (++timeoutCount &lt; 3) &#123;</span><br><span class="line">//                        continue;</span><br><span class="line">//                    &#125;</span><br><span class="line">                    NSLog(@&quot;monitor trigger&quot;);</span><br><span class="line">                    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">//                        [HCCCallStack callStackWithType:HCCCallStackTypeAll];</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; //end activity</span><br><span class="line">            &#125;// end semaphore wait</span><br><span class="line">            timeoutCount = 0;</span><br><span class="line">        &#125;// end while</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)endMonitor &#123;</span><br><span class="line">    [self.cpuMonitorTimer invalidate];</span><br><span class="line">    if (!runLoopObserver) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    CFRunLoopRemoveObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(runLoopObserver);</span><br><span class="line">    runLoopObserver = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Private</span><br><span class="line"></span><br><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</span><br><span class="line">    HCCMonitor *lagMonitor = (__bridge HCCMonitor*)info;</span><br><span class="line">    lagMonitor-&gt;runLoopActivity = activity;</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateCPUInfo &#123;</span><br><span class="line">    thread_act_array_t threads;</span><br><span class="line">    mach_msg_type_number_t threadCount = 0;</span><br><span class="line">    const task_t thisTask = mach_task_self();</span><br><span class="line">    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);</span><br><span class="line">    if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">        thread_info_data_t threadInfo;</span><br><span class="line">        thread_basic_info_t threadBaseInfo;</span><br><span class="line">        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;</span><br><span class="line">        if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;</span><br><span class="line">            threadBaseInfo = (thread_basic_info_t)threadInfo;</span><br><span class="line">            if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / 10;</span><br><span class="line">                if (cpuUsage &gt; 70) &#123;</span><br><span class="line">                    //cup 消耗大于 70 时打印和记录堆栈</span><br><span class="line">                    NSString *reStr = HCCStackOfThread(threads[i]);</span><br><span class="line">                    //记录数据库中</span><br><span class="line">//                    [[[HCCDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(id x) &#123;&#125;];</span><br><span class="line">                    NSLog(@&quot;CPU useage overload thread stack：\n%@&quot;,reStr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a>四、性能优化</h2><p>当tableview的cell有多个ImageView，并且是大图的话，会不会在滑动的时候导致卡顿，答案是显然意见的。</p>
<p>通过上面讲述Runloop的原理，我们可以使用Runloop每次循环添加一张图片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 为什么要优化：</span><br><span class="line">    Runloop会在一次循环中绘制屏幕上所有的点，如果加载的图片过大，过多，就会造成需要绘制很多的</span><br><span class="line">的点，导致一次循环的时间过长，从而导致UI卡顿。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h3 id="监听Runloop"><a href="#监听Runloop" class="headerlink" title="监听Runloop"></a>监听Runloop</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//添加runloop监听者</span><br><span class="line">- (void)addRunloopObserver&#123;</span><br><span class="line"></span><br><span class="line">    //    获取 当前的Runloop ref - 指针</span><br><span class="line">    CFRunLoopRef current =  CFRunLoopGetCurrent();</span><br><span class="line"></span><br><span class="line">    //定义一个RunloopObserver</span><br><span class="line">    CFRunLoopObserverRef defaultModeObserver;</span><br><span class="line"></span><br><span class="line">    //上下文</span><br><span class="line">    /*</span><br><span class="line">     typedef struct &#123;</span><br><span class="line">        CFIndex version; //版本号 long</span><br><span class="line">        void * info;    //这里我们要填写对象（self或者传进来的对象）</span><br><span class="line">        const void *(*retain)(const void *info);        //填写&amp;CFRetain</span><br><span class="line">        void (*release)(const void *info);           //填写&amp;CGFRelease</span><br><span class="line">        CFStringRef (*copyDescription)(const void *info); //NULL</span><br><span class="line">     &#125; CFRunLoopObserverContext;</span><br><span class="line">     */</span><br><span class="line">    CFRunLoopObserverContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)(self),</span><br><span class="line">        &amp;CFRetain,</span><br><span class="line">        &amp;CFRelease,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     1 NULL空指针 nil空对象 这里填写NULL</span><br><span class="line">     2 模式</span><br><span class="line">        kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">        kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">        kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">        kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">        kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">        kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">        kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">     3 是否重复 - YES</span><br><span class="line">     4 nil 或者 NSIntegerMax - 999</span><br><span class="line">     5 回调</span><br><span class="line">     6 上下文</span><br><span class="line">     */</span><br><span class="line">    //    创建观察者</span><br><span class="line">    defaultModeObserver = CFRunLoopObserverCreate(NULL,</span><br><span class="line">                                                  kCFRunLoopBeforeWaiting, YES,</span><br><span class="line">                                                  NSIntegerMax - 999,</span><br><span class="line">                                                  &amp;Callback,</span><br><span class="line">                                                  &amp;context);</span><br><span class="line"></span><br><span class="line">    //添加当前runloop的观察着</span><br><span class="line">    CFRunLoopAddObserver(current, defaultModeObserver, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    //释放</span><br><span class="line">    CFRelease(defaultModeObserver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void Callback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;</span><br><span class="line"></span><br><span class="line">    //通过info桥接为当前的对象</span><br><span class="line">    ZXYRunloop * runloop = (__bridge ZXYunloop *)info;</span><br><span class="line"></span><br><span class="line">    //如果没有任务，就直接返回</span><br><span class="line">    if (runloop.tasks.count == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL result = NO;</span><br><span class="line">    while (result == NO &amp;&amp; runloop.tasks.count) &#123;</span><br><span class="line"></span><br><span class="line">        //取出任务</span><br><span class="line">        RunloopBlock unit = runloop.tasks.firstObject;</span><br><span class="line"></span><br><span class="line">        //执行任务</span><br><span class="line">        result = unit();</span><br><span class="line"></span><br><span class="line">        //删除任务</span><br><span class="line">        [runloop.tasks removeObjectAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的两个方法我们可以做到监听Runloop循环，以及每次循环需要处理的事情，这个时候我们只需要对外提供一个添加任务的方法，用数组保存起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//add task 添加任务</span><br><span class="line">- (void)addTask:(RunloopBlock)unit withId:(id)key&#123;</span><br><span class="line">    //添加任务到数组</span><br><span class="line">    [self.tasks addObject:unit];</span><br><span class="line">    [self.taskKeys addObject:key];</span><br><span class="line"></span><br><span class="line">    //为了保证加载到图片最大数是20所以要删除</span><br><span class="line">    if (self.tasks.count &gt; self.maxQueue) &#123;</span><br><span class="line">        [self.tasks removeObjectAtIndex:0];</span><br><span class="line">        [self.taskKeys removeObjectAtIndex:0];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在ZXYRunloop初始化方法设置初始化对象和基本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        //初始化对象／基本信息</span><br><span class="line">        self.maxQueue = 20;</span><br><span class="line">        self.tasks = [NSMutableArray array];</span><br><span class="line">        self.taskKeys = [NSMutableArray array];</span><br><span class="line">        self.timer = [NSTimer scheduledTimerWithTimeInterval:0.001 repeats:YES block:^(NSTimer * _Nonnull timer) &#123; &#125;];</span><br><span class="line">        //添加Runloop观察者</span><br><span class="line">        [self addRunloopObserver];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TableViewCell中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ZXYRunloop shareInstance] addTask:^BOOL&#123;</span><br><span class="line">        [ViewController addCenterImg:cell];</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; withId:indexPath];</span><br></pre></td></tr></table></figure>

<p>总结一下思想</p>
<ul>
<li>加载图片的代码保存起来，不要直接执行，用一个数组保存 block </li>
<li>监听我们的Runloop循环 CFRunloop CFRunloopObserver </li>
<li>每次Runloop循环就让它从数组里面去一个加载图片等任务出来执行</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/03/16/Runloop/" data-id="clgovw0nd000lk9d3c3pn17x4" data-title="Runloop" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/26/GitLab-CI/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          GitLab CI
        
      </div>
    </a>
  
  
    <a href="/2019/01/30/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">事件传递与响应者链</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/" rel="tag">Xcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cocoaPods/" rel="tag">cocoaPods</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/" rel="tag">flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS-AppDelegate/" rel="tag">iOS AppDelegate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" rel="tag">强化学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" rel="tag">量化交易</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/tags/cocoaPods/" style="font-size: 10px;">cocoaPods</a> <a href="/tags/flutter/" style="font-size: 10px;">flutter</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS-AppDelegate/" style="font-size: 10px;">iOS AppDelegate</a> <a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">强化学习</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">机器学习</a> <a href="/tags/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/" style="font-size: 10px;">量化交易</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/20/init/">init</a>
          </li>
        
          <li>
            <a href="/2023/01/11/%E5%AE%B9%E5%99%A8%E5%8C%96/">首页容器化</a>
          </li>
        
          <li>
            <a href="/2022/08/14/%E5%8A%A8%E6%80%81%E5%BA%93%E6%87%92%E5%8A%A0%E8%BD%BD/">动态库懒加载</a>
          </li>
        
          <li>
            <a href="/2022/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B2%BB%E7%90%86/">多线程问题专项治理</a>
          </li>
        
          <li>
            <a href="/2021/07/20/%E7%9B%B4%E6%92%AD%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/">直播性能指标监控方案</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 xushuanghui<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>