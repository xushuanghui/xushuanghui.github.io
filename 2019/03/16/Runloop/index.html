

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="xushuanghui">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：  控制线程的生命周期【线程保活】 解决NSTimer在滑动过程中停止工作的问题及衍生问题 监控应用卡顿 性能优化   一、线程保活线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且">
<meta property="og:type" content="article">
<meta property="og:title" content="Runloop">
<meta property="og:url" content="http://example.com/2019/03/16/Runloop/index.html">
<meta property="og:site_name" content="xushuanghui">
<meta property="og:description" content="概述 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：  控制线程的生命周期【线程保活】 解决NSTimer在滑动过程中停止工作的问题及衍生问题 监控应用卡顿 性能优化   一、线程保活线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/bGvNnoDlcUdYy74.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/I5ULo7fuzgTEmct.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/f8IKlHWxghdbcwS.png">
<meta property="og:image" content="https://i.loli.net/2020/12/16/8c2TWPbS35avn6t.png">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVF5ChLqicEMicHL29cjNDL6wJ7qRwaHlZSP7rVd56GTpZD74jXr4mhalibWQgDzwO1OojMYzWmYTGL1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="article:published_time" content="2019-03-16T07:23:07.000Z">
<meta property="article:modified_time" content="2023-04-13T10:34:27.645Z">
<meta property="article:author" content="xushuanghui">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png">
  
  
  
  <title>Runloop - xushuanghui</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Runloop"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-03-16 15:23" pubdate>
          2019年3月16日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          227 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Runloop</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：</p>
<ul>
<li>控制线程的生命周期【线程保活】</li>
<li>解决NSTimer在滑动过程中停止工作的问题及衍生问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
<p><img src="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png" srcset="/img/loading.gif" lazyload alt="2020-12-16-4.12.57.png"></p>
<h2 id="一、线程保活"><a href="#一、线程保活" class="headerlink" title="一、线程保活"></a>一、线程保活</h2><p>线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且让子线程一直存活着,为了避免来回多次创建毁线程的动作, 降低性能消耗.</p>
<h3 id="情景1"><a href="#情景1" class="headerlink" title="情景1"></a>情景1</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-comment">//定义继承自NSThread线程</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYThread</span> : <span class="hljs-title">NSThread</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ZXYThread</span></span><br><span class="hljs-comment">//线程销毁会被调用</span><br>- (<span class="hljs-type">void</span>)dealloc<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br><br>    <span class="hljs-keyword">self</span>.thread = [[ZXYThread alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run) object:<span class="hljs-literal">nil</span>];<br>    [<span class="hljs-keyword">self</span>.thread start];<br>&#125;<br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br><span class="hljs-comment">// 子线程需要执行的任务</span><br>- (<span class="hljs-type">void</span>)test<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)run &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s ----end----&quot;</span>, __func__);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>当执行完上面的代码后,会发现打印出如下-[子线程也就销毁了]</p>
<p>但是运行完App,当点击App时没有反应,也可以证明此线程已经销毁.如果改进让线程处于随时接受命令的状态呢?</p>
<h3 id="情景2"><a href="#情景2" class="headerlink" title="情景2"></a>情景2</h3><p>从Runloop中得知,如果Mode里没有任何的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer, Runloop会立马退出.</p>
<p>所以会想到能不能向其中加入上面中的一个是否可以如下: [run 方法中]</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 这个方法的目的：线程保活</span><br>- (<span class="hljs-type">void</span>)run &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-comment">// 往RunLoop里面添加Source\Timer\Observer</span><br>    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br><span class="hljs-comment">//    [[NSRunLoop currentRunLoop] addTimer:[[NSTimer alloc]init] forMode:NSDefaultRunLoopMode];</span><br>    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] run];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s ----end----&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过在run方法中加入上面代码,让线程一直不死,打印屏幕界面:</p>
<p><img src="https://i.loli.net/2020/12/16/bGvNnoDlcUdYy74.png" srcset="/img/loading.gif" lazyload alt="2020-12-16-4.14.23.png"></p>
<p>好像上面已经满足了要求,达到了线程不死的状态,但是能不能在销毁页面控制器的时候,也销毁定时器,并且随时停掉定时器.</p>
<span id="more"></span>

<h3 id="情景3"><a href="#情景3" class="headerlink" title="情景3"></a>情景3</h3><p><strong>知识点:</strong> </p>
<blockquote>
<p>如何停止runloop?通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>方法可停掉定时器,但是对于用<code>[[NSRunLoop currentRunLoop] run]</code>的Runloop是不会停掉的,因为通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>方法仅仅是停掉了本次的Runloop,而不是停掉所有的,但是<code>[[NSRunLoop currentRunLoop] run]</code>的run方法是一直有runloop循环,所以通过<code>[[NSRunLoop currentRunLoop] run]</code>方法是不可能被停掉runloop的</p>
<p>那应该改成什么样的? —-[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</p>
</blockquote>
<p>下面直接用代码来解释,里面已经写明了代码思路,下面是A页面-&gt;B页面-&gt;A页面</p>
<p><img src="https://i.loli.net/2020/12/16/I5ULo7fuzgTEmct.png" srcset="/img/loading.gif" lazyload alt="2020-12-16-4.14.32.png"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-comment">//继承自NSThead的子线程</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) ZXYThread *thread;<br><span class="hljs-comment">//有个暂停定时器的需求,stopped代表是否点击了暂停</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">getter</span>=isStoped) <span class="hljs-type">BOOL</span> stopped;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br><br>    <span class="hljs-comment">//NSThread使用block的方法,消除循环引用</span><br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br><br>    <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">self</span>.thread = [[ZXYThread alloc] initWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----begin----&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br><br>        <span class="hljs-comment">// 往RunLoop里面添加Source\Timer\Observer</span><br>        [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br><br>        <span class="hljs-keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;<br>            [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>        &#125;<br><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----end----&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    [<span class="hljs-keyword">self</span>.thread start];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.thread) <span class="hljs-keyword">return</span>;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br><span class="hljs-comment">// 子线程需要执行的任务</span><br>- (<span class="hljs-type">void</span>)test<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br><br>- (<span class="hljs-type">void</span>) stop &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.thread) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走）</span><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(stopThread) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br><span class="hljs-comment">// 用于停止子线程的RunLoop</span><br>- (<span class="hljs-type">void</span>)stopThread<br>&#123;<br>    <span class="hljs-comment">// 设置标记为YES</span><br>    <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">YES</span>;<br><br>    <span class="hljs-comment">// 停止RunLoop</span><br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br><br>    <span class="hljs-comment">// 清空线程</span><br>    <span class="hljs-keyword">self</span>.thread = <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br><br>    [<span class="hljs-keyword">self</span> stop];<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>如果想将上面的代码抽取出来应该怎么办呢?</p>
<h3 id="情景4"><a href="#情景4" class="headerlink" title="情景4"></a>情景4</h3><p>此处封装工具类并不是直接继承自NSThread,而是继承自NSObject[因为并不想让别人直接能调用NSThread里面的方法.]这样符合开闭原则</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (^ZXYPermenantThreadTask)(<span class="hljs-type">void</span>);<br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYPermenantThread</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 在当前子线程执行一个任务</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)executeTask:(ZXYPermenantThreadTask)task;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 结束线程</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)stop;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ZXYPermenantThread.h&quot;</span></span><br><br><span class="hljs-comment">/** ZXYThread **/</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYThread</span> : <span class="hljs-title">NSThread</span></span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ZXYThread</span></span><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">/** ZXYPermenantThread **/</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYPermenantThread</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) ZXYThread *innerThread;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">getter</span>=isStopped) <span class="hljs-type">BOOL</span> stopped;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ZXYPermenantThread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - public methods</span><br>- (<span class="hljs-keyword">instancetype</span>)init&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">NO</span>;<br>        __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>        <span class="hljs-keyword">self</span>.innerThread = [[ZXYThread alloc] initWithBlock:^&#123;<br>            [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br><br>            <span class="hljs-keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;<br>                [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>            &#125;<br>        &#125;];<br><br>        [<span class="hljs-keyword">self</span>.innerThread start];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)executeTask:(ZXYPermenantThreadTask)task&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.innerThread || !task) <span class="hljs-keyword">return</span>;<br><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(__executeTask:) onThread:<span class="hljs-keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)stop&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.innerThread) <span class="hljs-keyword">return</span>;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(__stop) onThread:<span class="hljs-keyword">self</span>.innerThread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>    [<span class="hljs-keyword">self</span> stop];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - private methods</span><br>- (<span class="hljs-type">void</span>)__stop&#123;<br>    <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>    <span class="hljs-keyword">self</span>.innerThread = <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)__executeTask:(ZXYPermenantThreadTask)task&#123;<br>    task();<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>上面是针对Runloop在实际开发中的第一个使用场景,那么我们是否在一些好的开源项目中使用过呢或者是看到过呢?</p>
<p><strong>拓展[AFNetworking也使用到了Runloop的线程保活]</strong></p>
<p>AFNetworking中的ANURLConnectionOperation是基于NSURLConnection构建,本质是希望能在后台线程接收到Delegate回调.为此AFNetworking单独创建了一个线程, 并在这个线程中开启了一个Runloop:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(<span class="hljs-type">id</span>)__unused object &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@&quot;AFNetworking&quot;</span>];<br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        [runLoop run];<br>    &#125;<br>&#125;<br><br>+ (<span class="hljs-built_in">NSThread</span> *)networkRequestThread &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *_networkRequestThread = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        _networkRequestThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="hljs-literal">nil</span>];<br>        [_networkRequestThread start];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> _networkRequestThread;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Runloop启动前必须要至少一个Timer&#x2F;Observer&#x2F;Source,所以AFNetworking在[runLoop run]</p>
<p>之前创建了NSMachPort添加进去了.通常情况下调用者需要持有这个NSMachPort并在外部线程通过这个port发送消息到loop内</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">- (void)start &#123;<br>    [<span class="hljs-built_in">self</span>.lock lock];<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">self</span> isCancelled]) &#123;<br>        [<span class="hljs-built_in">self</span> performSelector:@selector(cancelConnection) onThread:<span class="hljs-string">[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">self</span> isReady]) &#123;<br>        <span class="hljs-built_in">self</span>.state = AFOperationExecutingState;<br>        [<span class="hljs-built_in">self</span> performSelector:@selector(operationDidStart) onThread:<span class="hljs-string">[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]</span>;<br>    &#125;<br>    [<span class="hljs-built_in">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时,AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中</p>
<h2 id="二、NSTimer问题"><a href="#二、NSTimer问题" class="headerlink" title="二、NSTimer问题"></a>二、NSTimer问题</h2><p>在日常开发中,列表经常会用到NSTimer倒计时问题,或者Interview的时候被面试官问到: NSTimer准时嘛等问题?今天就展开讲述一下原因及方案,最后讲述衍生出来的问题循环引用!争取彻底解决NSTimer带来的疑问?</p>
<h3 id="问题一、-NSTimer定时器不准"><a href="#问题一、-NSTimer定时器不准" class="headerlink" title="问题一、 NSTimer定时器不准"></a>问题一、 NSTimer定时器不准</h3><p><strong>原因</strong></p>
<ul>
<li>NSTimer被添加在mainRunloop中,模式是NSDefaultRunLoopMode, mainRunloop负责所有的主线程事件,例如UI界面的操作,负责的运算使当前Runloop持续的时间超过了定时器的间隔时间,那么下一次定时就被延后,这样就造成timer的阻塞</li>
<li>模式的切换,当创建的timer被加入到NSDefaultRunLoopMode时,此时如果有滑动UIScrollView的操作时,runloop的mode会切换为TrackingRunloopMode,这时tiemr会停止回调</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>Mode方式的改变,兼顾TrackingRunloopMode</li>
<li>在子线程中创建timer,在主线程进行定时任务的操作或者在子线程中创建timer,在子线程中进行定时任务的操作,需要UI的操作时再切换到主线程进行操作</li>
<li>GCD操作: dispatch_source_create以及depatch_resume等方法</li>
</ul>
<p><strong>方案一</strong></p>
<p>主线程的Runloop使用到的主要有两种模式, NSDefaultRunLoopMode与TrackingRunloopMode模式</p>
<p>添加定时器到主线程的CommonMode中</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[[NSRunLoop mainRunLoop]</span>addTimer:timer forMode:NSRunLoopCommonModes];<br></code></pre></td></tr></table></figure>

<p><strong>方案二</strong></p>
<p>子线程创建timer,主线程执行定时或者子线程创建timer,在子线程执行定时,需要刷新再到主线程</p>
<p>子线程启动NSTimer</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">__<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        __<span class="hljs-keyword">strong</span> __<span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>        <span class="hljs-keyword">if</span> (strongSelf) &#123;<br>            strongSelf.countTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:strongSelf selector:<span class="hljs-keyword">@selector</span>(countDown) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>            <span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>            [runloop addTimer:strongSelf.countTimer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>            [runloop run];<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p>主线程更新UI</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">.1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>        [<span class="hljs-keyword">self</span>.jumpBTN setTitle:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;跳过 %lds&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-keyword">self</span>.count] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p><strong>方案三</strong></p>
<p>使用 GCD 的定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><br>    <span class="hljs-comment">//创建定时器</span><br>    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, queue);<br>    <span class="hljs-comment">//设置时间（start:几s后开始执行；interval:时间间隔）</span><br>    uint64_t start = <span class="hljs-number">2.0</span>;    <span class="hljs-comment">//2s后开始执行</span><br>    uint64_t interval = <span class="hljs-number">1.0</span>; <span class="hljs-comment">//每隔1s执行</span><br>    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class="hljs-built_in">NSEC_PER_SEC</span>), interval * <span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//设置回调</span><br>    dispatch_source_set_event_handler(timer, ^&#123;<br>       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <span class="hljs-comment">//启动定时器</span><br>    dispatch_resume(timer);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br><br>    <span class="hljs-keyword">self</span>.timer = timer;<br></code></pre></td></tr></table></figure>

<h3 id="问题二、NSTimer循环引用"><a href="#问题二、NSTimer循环引用" class="headerlink" title="问题二、NSTimer循环引用"></a>问题二、NSTimer循环引用</h3><p><strong>常识</strong></p>
<p>这三个方法直接将timer添加到了当前runloop default mode，而不需要我们自己操作，当然这样的代价是runloop只能是当前runloop，模式是default mode:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti invocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="hljs-type">id</span>)userInfo repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br></code></pre></td></tr></table></figure>

<p>下面五种创建，不会自动添加到runloop，还需调用addTimer:forMode:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti invocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="hljs-type">id</span>)userInfo repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFireDate:(<span class="hljs-built_in">NSDate</span> *)date interval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)t selector:(SEL)s userInfo:(<span class="hljs-type">id</span>)ui repeats:(<span class="hljs-type">BOOL</span>)rep;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFireDate:(<span class="hljs-built_in">NSDate</span> *)date interval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br></code></pre></td></tr></table></figure>

<p>在实际项目开发中,使用NSTimer解决定时发送任务的需求,但是还是会产生循环引用,今天讲述本项目中的解决方案.<br>循环引用（Circular Reference）是指两个对象之间相互强引用，两者无法按时释放，从而导致内存泄露.如下:</p>
<p><img src="https://i.loli.net/2020/12/16/f8IKlHWxghdbcwS.png" srcset="/img/loading.gif" lazyload alt="2020-12-16-4.14.47.png"></p>
<p>发现两者相互引用,都不能得以释放,造成了循环引用</p>
<p><strong>方案一、给self添加中间件</strong></p>
<p>引入一个对象proxy,proxy弱引用self,然后proxy传入NSTimer. self强引用NSTimer, NSTimer强引用proxy,proxy弱引用着self,这样通过弱引用解决了相互引用,就不会造成环..本项目中使用的方法是引入中间控件HCCProxy1</p>
<p><img src="https://i.loli.net/2020/12/16/8c2TWPbS35avn6t.png" srcset="/img/loading.gif" lazyload alt="2020-12-16-4.14.54.png"></p>
<p>定义一个继承自NSObject的中间代理对象HCCProxy1,ViewController不持有timer,而是持有HCCProxy1实例, 让HCCProxy1实例弱引用ViewController, timer强引用HCCProxy1实例,如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCProxy1</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">id</span> target;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HCCProxy1</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target&#123;<br>    HCCProxy1 *proxy = [[HCCProxy1 alloc] init];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br>- (<span class="hljs-type">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.target;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>在项目中使用如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:[HCCProxy1 proxyWithTarget:<span class="hljs-keyword">self</span>] selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>拓展:</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector是什么？</li>
</ul>
<p>  消息转发，简单来说就是如果当前对象没有实现这个方法，系统会到这个方法里来找实现对象。</p>
<p>本文中由于当前target是HCCProxy1，但是HCCProxy1没有实现方法(当然也不需要它实现)，让系统去找target实例的方法实现，也就是去找ViewController中的方法实现。</p>
</blockquote>
<p><strong>方案二、使用继承自NSProxy类HCCProxy的消息转发</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCProxy</span> : <span class="hljs-title">NSProxy</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">id</span> target;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HCCProxy</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target&#123;<br>    <span class="hljs-comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span><br>    HCCProxy *proxy = [HCCProxy alloc];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.target methodSignatureForSelector:sel];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation&#123;<br>    [invocation invokeWithTarget:<span class="hljs-keyword">self</span>.target];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>在项目中使用如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:[HCCProxy proxyWithTarget:<span class="hljs-keyword">self</span>] selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="三、监控卡顿"><a href="#三、监控卡顿" class="headerlink" title="三、监控卡顿"></a>三、监控卡顿</h2><p>卡顿问题主要是主线程上无法响应用户交互的问题, 如果一个App时不时给你卡一下,有时还长时间没有响应,你还会继续使用嘛?答案当然是显然的</p>
<p>对于iOS开发来说,监控卡顿就是要去找到主线程都做了哪些事情,线程的消息事件依赖于NSRunloop的,所以从NSRunloop入手,就可以知道主线程上都调用了哪些方法.可以监听NSRunloop的状态,就能够发现调用方法是否执行时间过长从而判断是否出现了卡顿.所以推荐的监控卡顿方案是: 通过监控Runloop的状态来判断是否出现卡顿</p>
<p>下面我们讲解一下Runloop的底层常识吧</p>
<h3 id="1、知识-Runloop原理"><a href="#1、知识-Runloop原理" class="headerlink" title="1、知识-Runloop原理"></a>1、知识-Runloop原理</h3><p>Runloop的目的是,当有事情要去处理时保持线程忙,当没有事件要处理的时候让线程进入休眠.下面通过CFRunloop的源码来分享下Runloop的原理</p>
<p><strong>第一步:</strong></p>
<p>通知observers: Runloop要开始进入loop了,紧接着进入loop,代码如下:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//通知 observers</span><br><span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) <br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopEntry</span>)</span>;<br><span class="hljs-comment">//进入 loop</span><br>result = <span class="hljs-constructor">__CFRunLoopRun(<span class="hljs-params">rl</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">seconds</span>, <span class="hljs-params">returnAfterSourceHandled</span>, <span class="hljs-params">previousMode</span>)</span>;<br></code></pre></td></tr></table></figure>

<p><strong>第二步</strong></p>
<p>开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block.</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 通知 Observers RunLoop 会触发 Timer 回调</span><br><span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)<br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeTimers</span>)</span>;<br><span class="hljs-comment">// 通知 Observers RunLoop 会触发 Source0 回调</span><br><span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources)<br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeSources</span>)</span>;<br><span class="hljs-comment">// 执行 block</span><br><span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">if (MACH_PORT_NULL != <span class="hljs-keyword">dispatchPort </span>) &#123;<br>    <span class="hljs-keyword">Boolean </span>hasMsg = __CFRunLoopServiceMachPort(<span class="hljs-keyword">dispatchPort, </span>&amp;msg)<br>    if (hasMsg) goto handle_msg;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第三步</strong></p>
<p>回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态.</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Boolean poll = sourceHandledThisLoop<span class="hljs-operator"> || </span>(<span class="hljs-number">0</span>ULL<span class="hljs-operator"> == </span>timeout_context-&gt;termTSR);<br><span class="hljs-keyword">if</span> (!poll<span class="hljs-operator"> &amp;&amp; </span>(currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) &#123;<br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeWaiting</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第四步</strong></p>
<p>进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒：</p>
<ul>
<li>基于 port 的 Source 事件；</li>
<li>Timer 时间到；*RunLoop 超时；</li>
<li>被调用者唤醒。</li>
</ul>
<p>等待唤醒的代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-title function_">__CFRunLoopServiceMachPort</span>(<span class="hljs-params">waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort</span>) &#123;<br>        <span class="hljs-comment">// 基于 port 的 Source 事件、调用者唤醒</span><br>        <span class="hljs-keyword">if</span> (modeQueuePort != <span class="hljs-variable constant_">MACH_PORT_NULL</span> &amp;&amp; livePort == modeQueuePort) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// Timer 时间到、RunLoop 超时</span><br>        <span class="hljs-keyword">if</span> (currentMode-&gt;_timerFired) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p><strong>第五步</strong></p>
<p>唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if (!poll <span class="hljs-symbol">&amp;&amp;</span> (<span class="hljs-name">currentMode-&gt;_observerMask</span> &amp; kCFRunLoopAfterWaiting))<br>    __CFRunLoopDoObservers(<span class="hljs-name">runloop</span>, currentMode, kCFRunLoopAfterWaiting)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>第六步</strong></p>
<p>RunLoop 被唤醒后就要开始处理消息了：</p>
<ul>
<li>如果是 Timer 时间到的话，就触发 Timer 的回调；</li>
<li>如果是 dispatch 的话，就执行 block；</li>
<li>如果是 source1 事件的话，就处理这个事件。</li>
</ul>
<p>消息执行完后，就执行加到 loop 里的 block。代码如下：<br>handle_msg:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 如果 Timer 时间到，就触发 Timer 回调</span><br><span class="hljs-keyword">if</span> (msg-is-timer) &#123;<br>    <span class="hljs-constructor">__CFRunLoopDoTimers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">mach_absolute_time</span>()</span>)<br>&#125; <br><span class="hljs-comment">// 如果 dispatch 就执行 block</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg_is_dispatch) &#123;<br>    <span class="hljs-constructor">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class="hljs-params">msg</span>)</span>;<br>&#125; <br><br><span class="hljs-comment">// Source1 事件的话，就处理这个事件</span><br><span class="hljs-keyword">else</span> &#123;<br>    CFRunLoopSourceRef source1 = <span class="hljs-constructor">__CFRunLoopModeFindSourceForMachPort(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">livePort</span>)</span>;<br>    sourceHandledThisLoop = <span class="hljs-constructor">__CFRunLoopDoSource1(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">source1</span>, <span class="hljs-params">msg</span>)</span>;<br>    <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>        mach<span class="hljs-constructor">_msg(<span class="hljs-params">reply</span>, MACH_SEND_MSG, <span class="hljs-params">reply</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>第七步</strong></p>
<p>根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (sourceHandledThisLoop<span class="hljs-operator"> &amp;&amp; </span>stopAfterHandle) &#123;<br>     <span class="hljs-comment">// 事件已处理完</span><br>    retVal = kCFRunLoopRunHandledSource;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout) &#123;<br>    <span class="hljs-comment">// 超时</span><br>    retVal = kCFRunLoopRunTimedOut;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopIsStopped(<span class="hljs-params">runloop</span>)</span>) &#123;<br>    <span class="hljs-comment">// 外部调用者强制停止</span><br>    retVal = kCFRunLoopRunStopped;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopModeIsEmpty(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>) &#123;<br>    <span class="hljs-comment">// mode 为空，RunLoop 结束</span><br>    retVal = kCFRunLoopRunFinished;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>全部的内部代码如下: </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/// 用DefaultMode启动</span><br>void <span class="hljs-constructor">CFRunLoopRun(<span class="hljs-params">void</span>)</span> &#123;<br>    <span class="hljs-constructor">CFRunLoopRunSpecific(CFRunLoopGetCurrent()</span>, kCFRunLoopDefaultMode, <span class="hljs-number">1.0e10</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CFRunLoopRunInMode(CFStringRef <span class="hljs-params">modeName</span>, CFTimeInterval <span class="hljs-params">seconds</span>, Boolean <span class="hljs-params">stopAfterHandle</span>)</span> &#123;<br>    return <span class="hljs-constructor">CFRunLoopRunSpecific(CFRunLoopGetCurrent()</span>, modeName, seconds, returnAfterSourceHandled);<br>&#125;<br><br><span class="hljs-comment">/// RunLoop的实现</span><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CFRunLoopRunSpecific(<span class="hljs-params">runloop</span>, <span class="hljs-params">modeName</span>, <span class="hljs-params">seconds</span>, <span class="hljs-params">stopAfterHandle</span>)</span> &#123;<br><br>    <span class="hljs-comment">/// 首先根据modeName找到对应mode</span><br>    CFRunLoopModeRef currentMode = <span class="hljs-constructor">__CFRunLoopFindMode(<span class="hljs-params">runloop</span>, <span class="hljs-params">modeName</span>, <span class="hljs-params">false</span>)</span>;<br>    <span class="hljs-comment">/// 如果mode里没有source/timer/observer, 直接返回。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopModeIsEmpty(<span class="hljs-params">currentMode</span>)</span>) return;<br><br>    <span class="hljs-comment">/// 1\. 通知 Observers: RunLoop 即将进入 loop。</span><br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopEntry</span>)</span>;<br><br>    <span class="hljs-comment">/// 内部函数，进入loop</span><br>    <span class="hljs-constructor">__CFRunLoopRun(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">seconds</span>, <span class="hljs-params">returnAfterSourceHandled</span>)</span> &#123;<br><br>        Boolean sourceHandledThisLoop = NO;<br>        <span class="hljs-built_in">int</span> retVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br><br>            <span class="hljs-comment">/// 2\. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br>            <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeTimers</span>)</span>;<br>            <span class="hljs-comment">/// 3\. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br>            <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeSources</span>)</span>;<br>            <span class="hljs-comment">/// 执行被加入的block</span><br>            <span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br><br>            <span class="hljs-comment">/// 4\. RunLoop 触发 Source0 (非port) 回调。</span><br>            sourceHandledThisLoop = <span class="hljs-constructor">__CFRunLoopDoSources0(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">stopAfterHandle</span>)</span>;<br>            <span class="hljs-comment">/// 执行被加入的block</span><br>            <span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br><br>            <span class="hljs-comment">/// 5\. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br>            <span class="hljs-keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;<br>                Boolean hasMsg = <span class="hljs-constructor">__CFRunLoopServiceMachPort(<span class="hljs-params">dispatchPort</span>, &amp;<span class="hljs-params">msg</span>)</span><br>                <span class="hljs-keyword">if</span> (hasMsg) goto handle_msg;<br>            &#125;<br><br>            <span class="hljs-comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br>            <span class="hljs-keyword">if</span> (!sourceHandledThisLoop) &#123;<br>                <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeWaiting</span>)</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/// 7\. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br>            <span class="hljs-comment">/// • 一个基于 port 的Source 的事件。</span><br>            <span class="hljs-comment">/// • 一个 Timer 到时间了</span><br>            <span class="hljs-comment">/// • RunLoop 自身的超时时间到了</span><br>            <span class="hljs-comment">/// • 被其他什么调用者手动唤醒</span><br>            <span class="hljs-constructor">__CFRunLoopServiceMachPort(<span class="hljs-params">waitSet</span>, &amp;<span class="hljs-params">msg</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">msg_buffer</span>)</span>, &amp;livePort) &#123;<br>                mach<span class="hljs-constructor">_msg(<span class="hljs-params">msg</span>, MACH_RCV_MSG, <span class="hljs-params">port</span>)</span>; <span class="hljs-comment">// thread wait for receive msg</span><br>            &#125;<br><br>            <span class="hljs-comment">/// 8\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br>            <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopAfterWaiting</span>)</span>;<br><br>            <span class="hljs-comment">/// 收到消息，处理消息。</span><br>            handle_msg:<br><br>            <span class="hljs-comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br>            <span class="hljs-keyword">if</span> (msg_is_timer) &#123;<br>                <span class="hljs-constructor">__CFRunLoopDoTimers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">mach_absolute_time</span>()</span>)<br>            &#125;<br><br>            <span class="hljs-comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg_is_dispatch) &#123;<br>                <span class="hljs-constructor">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class="hljs-params">msg</span>)</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                CFRunLoopSourceRef source1 = <span class="hljs-constructor">__CFRunLoopModeFindSourceForMachPort(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">livePort</span>)</span>;<br>                sourceHandledThisLoop = <span class="hljs-constructor">__CFRunLoopDoSource1(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">source1</span>, <span class="hljs-params">msg</span>)</span>;<br>                <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>                    mach<span class="hljs-constructor">_msg(<span class="hljs-params">reply</span>, MACH_SEND_MSG, <span class="hljs-params">reply</span>)</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">/// 执行加入到Loop的block</span><br>            <span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br><br>            <span class="hljs-keyword">if</span> (sourceHandledThisLoop<span class="hljs-operator"> &amp;&amp; </span>stopAfterHandle) &#123;<br>                <span class="hljs-comment">/// 进入loop时参数说处理完事件就返回。</span><br>                retVal = kCFRunLoopRunHandledSource;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout) &#123;<br>                <span class="hljs-comment">/// 超出传入参数标记的超时时间了</span><br>                retVal = kCFRunLoopRunTimedOut;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopIsStopped(<span class="hljs-params">runloop</span>)</span>) &#123;<br>                <span class="hljs-comment">/// 被外部调用者强制停止了</span><br>                retVal = kCFRunLoopRunStopped;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopModeIsEmpty(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>) &#123;<br>                <span class="hljs-comment">/// source/timer/observer一个都没有了</span><br>                retVal = kCFRunLoopRunFinished;<br>            &#125;<br><br>            <span class="hljs-comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br>        &#125; <span class="hljs-keyword">while</span> (retVal<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/// 10\. 通知 Observers: RunLoop 即将退出。</span><br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">rl</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopExit</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。<br>整个Runloop过程,可以总结如下一张图片</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVF5ChLqicEMicHL29cjNDL6wJ7qRwaHlZSP7rVd56GTpZD74jXr4mhalibWQgDzwO1OojMYzWmYTGL1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="2、如何监测卡顿"><a href="#2、如何监测卡顿" class="headerlink" title="2、如何监测卡顿"></a>2、如何监测卡顿</h3><p>要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<span class="hljs-number">0</span>,(__bridge <span class="hljs-type">void</span>*)<span class="hljs-keyword">self</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>&#125;;<br>runLoopObserver = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,kCFRunLoopAllActivities,<span class="hljs-literal">YES</span>,<span class="hljs-number">0</span>,&amp;runLoopObserverCallBack,&amp;context);<br></code></pre></td></tr></table></figure>

<p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。</p>
<p>一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。</p>
<p>开启一个子线程监控的代码如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建子线程监控<br>dispatch_async(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-regexp">//</span>子线程开启一个持续的 loop 用来进行监控<br>    <span class="hljs-keyword">while</span> (YES) &#123;<br>        long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">3</span> * NSEC_PER_SEC));<br>        <span class="hljs-keyword">if</span> (semaphoreWait != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!runLoopObserver) &#123;<br>                timeoutCount = <span class="hljs-number">0</span>;<br>                dispatchSemaphore = <span class="hljs-number">0</span>;<br>                runLoopActivity = <span class="hljs-number">0</span>;<br>                return;<br>            &#125;<br>            <span class="hljs-regexp">//</span>BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿<br>            <span class="hljs-keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;<br>                <span class="hljs-regexp">//</span>将堆栈信息上报服务器的代码放到这里<br>            &#125; <span class="hljs-regexp">//</span>end activity<br>        &#125;<span class="hljs-regexp">//</span> end semaphore wait<br>        timeoutCount = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-regexp">//</span> end <span class="hljs-keyword">while</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>下面是封装的一个工具类HCCMonitor,用于卡顿监测</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCMonitor</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance;<br>- (<span class="hljs-type">void</span>)beginMonitor; <span class="hljs-comment">//开始监视卡顿</span><br>- (<span class="hljs-type">void</span>)endMonitor;   <span class="hljs-comment">//停止监视卡顿</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HCCMonitor.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HCCCallStack.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HCCCPUMonitor.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCMonitor</span>() </span>&#123;<br>    <span class="hljs-type">int</span> timeoutCount;<br>    <span class="hljs-built_in">CFRunLoopObserverRef</span> runLoopObserver;<br>    <span class="hljs-keyword">@public</span><br>    dispatch_semaphore_t dispatchSemaphore;<br>    <span class="hljs-built_in">CFRunLoopActivity</span> runLoopActivity;<br>&#125;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSTimer</span> *cpuMonitorTimer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HCCMonitor</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Interface</span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">id</span> instance = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> dispatchOnce;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;dispatchOnce, ^&#123;<br>        instance = [[<span class="hljs-keyword">self</span> alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)beginMonitor &#123;<br>    <span class="hljs-comment">//监测 CPU 消耗</span><br>    <span class="hljs-keyword">self</span>.cpuMonitorTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">3</span><br>                                                             target:<span class="hljs-keyword">self</span><br>                                                           selector:<span class="hljs-keyword">@selector</span>(updateCPUInfo)<br>                                                           userInfo:<span class="hljs-literal">nil</span><br>                                                            repeats:<span class="hljs-literal">YES</span>];<br>    <span class="hljs-comment">//监测卡顿</span><br>    <span class="hljs-keyword">if</span> (runLoopObserver) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dispatchSemaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>); <span class="hljs-comment">//Dispatch Semaphore保证同步</span><br>    <span class="hljs-comment">//创建一个观察者</span><br>    <span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<span class="hljs-number">0</span>,(__bridge <span class="hljs-type">void</span>*)<span class="hljs-keyword">self</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    runLoopObserver = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,<br>                                              kCFRunLoopAllActivities,<br>                                              <span class="hljs-literal">YES</span>,<br>                                              <span class="hljs-number">0</span>,<br>                                              &amp;runLoopObserverCallBack,<br>                                              &amp;context);<br>    <span class="hljs-comment">//将观察者添加到主线程runloop的common模式下的观察中</span><br>    <span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);<br><br>    <span class="hljs-comment">//创建子线程监控</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-comment">//子线程开启一个持续的loop用来进行监控</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">YES</span>) &#123;<br>            <span class="hljs-type">long</span> semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">20</span>*<span class="hljs-built_in">NSEC_PER_MSEC</span>));<br>            <span class="hljs-keyword">if</span> (semaphoreWait != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!runLoopObserver) &#123;<br>                    timeoutCount = <span class="hljs-number">0</span>;<br>                    dispatchSemaphore = <span class="hljs-number">0</span>;<br>                    runLoopActivity = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">//两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿</span><br>                <span class="hljs-keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;<br>                    <span class="hljs-comment">// 将堆栈信息上报服务器的代码放到这里</span><br>                    <span class="hljs-comment">//出现三次出结果</span><br><span class="hljs-comment">//                    if (++timeoutCount &lt; 3) &#123;</span><br><span class="hljs-comment">//                        continue;</span><br><span class="hljs-comment">//                    &#125;</span><br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;monitor trigger&quot;</span>);<br>                    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="hljs-number">0</span>), ^&#123;<br><span class="hljs-comment">//                        [HCCCallStack callStackWithType:HCCCallStackTypeAll];</span><br>                    &#125;);<br>                &#125; <span class="hljs-comment">//end activity</span><br>            &#125;<span class="hljs-comment">// end semaphore wait</span><br>            timeoutCount = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-comment">// end while</span><br>    &#125;);<br><br>&#125;<br><br>- (<span class="hljs-type">void</span>)endMonitor &#123;<br>    [<span class="hljs-keyword">self</span>.cpuMonitorTimer invalidate];<br>    <span class="hljs-keyword">if</span> (!runLoopObserver) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">CFRunLoopRemoveObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);<br>    <span class="hljs-built_in">CFRelease</span>(runLoopObserver);<br>    runLoopObserver = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Private</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> runLoopObserverCallBack(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-type">void</span> *info)&#123;<br>    HCCMonitor *lagMonitor = (__bridge HCCMonitor*)info;<br>    lagMonitor-&gt;runLoopActivity = activity;<br><br>    dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore;<br>    dispatch_semaphore_signal(semaphore);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)updateCPUInfo &#123;<br>    thread_act_array_t threads;<br>    mach_msg_type_number_t threadCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> task_t thisTask = mach_task_self();<br>    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);<br>    <span class="hljs-keyword">if</span> (kr != KERN_SUCCESS) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>        thread_info_data_t threadInfo;<br>        thread_basic_info_t threadBaseInfo;<br>        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;<br>        <span class="hljs-keyword">if</span> (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;<br>            threadBaseInfo = (thread_basic_info_t)threadInfo;<br>            <span class="hljs-keyword">if</span> (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;<br>                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">if</span> (cpuUsage &gt; <span class="hljs-number">70</span>) &#123;<br>                    <span class="hljs-comment">//cup 消耗大于 70 时打印和记录堆栈</span><br>                    <span class="hljs-built_in">NSString</span> *reStr = HCCStackOfThread(threads[i]);<br>                    <span class="hljs-comment">//记录数据库中</span><br><span class="hljs-comment">//                    [[[HCCDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(id x) &#123;&#125;];</span><br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CPU useage overload thread stack：\n%@&quot;</span>,reStr);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h2 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a>四、性能优化</h2><p>当tableview的cell有多个ImageView，并且是大图的话，会不会在滑动的时候导致卡顿，答案是显然意见的。</p>
<p>通过上面讲述Runloop的原理，我们可以使用Runloop每次循环添加一张图片。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 为什么要优化：</span><br><span class="hljs-comment">    Runloop会在一次循环中绘制屏幕上所有的点，如果加载的图片过大，过多，就会造成需要绘制很多的</span><br><span class="hljs-comment">的点，导致一次循环的时间过长，从而导致UI卡顿。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h3 id="监听Runloop"><a href="#监听Runloop" class="headerlink" title="监听Runloop"></a>监听Runloop</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//添加runloop监听者</span><br>- (<span class="hljs-type">void</span>)addRunloopObserver&#123;<br><br>    <span class="hljs-comment">//    获取 当前的Runloop ref - 指针</span><br>    <span class="hljs-built_in">CFRunLoopRef</span> current =  <span class="hljs-built_in">CFRunLoopGetCurrent</span>();<br><br>    <span class="hljs-comment">//定义一个RunloopObserver</span><br>    <span class="hljs-built_in">CFRunLoopObserverRef</span> defaultModeObserver;<br><br>    <span class="hljs-comment">//上下文</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     typedef struct &#123;</span><br><span class="hljs-comment">        CFIndex version; //版本号 long</span><br><span class="hljs-comment">        void * info;    //这里我们要填写对象（self或者传进来的对象）</span><br><span class="hljs-comment">        const void *(*retain)(const void *info);        //填写&amp;CFRetain</span><br><span class="hljs-comment">        void (*release)(const void *info);           //填写&amp;CGFRelease</span><br><span class="hljs-comment">        CFStringRef (*copyDescription)(const void *info); //NULL</span><br><span class="hljs-comment">     &#125; CFRunLoopObserverContext;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<br>        <span class="hljs-number">0</span>,<br>        (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>),<br>        &amp;<span class="hljs-built_in">CFRetain</span>,<br>        &amp;<span class="hljs-built_in">CFRelease</span>,<br>        <span class="hljs-literal">NULL</span><br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     1 NULL空指针 nil空对象 这里填写NULL</span><br><span class="hljs-comment">     2 模式</span><br><span class="hljs-comment">        kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="hljs-comment">        kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="hljs-comment">        kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="hljs-comment">        kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="hljs-comment">        kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="hljs-comment">        kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="hljs-comment">        kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="hljs-comment">     3 是否重复 - YES</span><br><span class="hljs-comment">     4 nil 或者 NSIntegerMax - 999</span><br><span class="hljs-comment">     5 回调</span><br><span class="hljs-comment">     6 上下文</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//    创建观察者</span><br>    defaultModeObserver = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(<span class="hljs-literal">NULL</span>,<br>                                                  kCFRunLoopBeforeWaiting, <span class="hljs-literal">YES</span>,<br>                                                  <span class="hljs-built_in">NSIntegerMax</span> - <span class="hljs-number">999</span>,<br>                                                  &amp;Callback,<br>                                                  &amp;context);<br><br>    <span class="hljs-comment">//添加当前runloop的观察着</span><br>    <span class="hljs-built_in">CFRunLoopAddObserver</span>(current, defaultModeObserver, kCFRunLoopDefaultMode);<br><br>    <span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">CFRelease</span>(defaultModeObserver);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> Callback(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-type">void</span> *info)&#123;<br><br>    <span class="hljs-comment">//通过info桥接为当前的对象</span><br>    ZXYRunloop * runloop = (__bridge ZXYunloop *)info;<br><br>    <span class="hljs-comment">//如果没有任务，就直接返回</span><br>    <span class="hljs-keyword">if</span> (runloop.tasks.count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">BOOL</span> result = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">while</span> (result == <span class="hljs-literal">NO</span> &amp;&amp; runloop.tasks.count) &#123;<br><br>        <span class="hljs-comment">//取出任务</span><br>        RunloopBlock unit = runloop.tasks.firstObject;<br><br>        <span class="hljs-comment">//执行任务</span><br>        result = unit();<br><br>        <span class="hljs-comment">//删除任务</span><br>        [runloop.tasks removeObjectAtIndex:<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过上面的两个方法我们可以做到监听Runloop循环，以及每次循环需要处理的事情，这个时候我们只需要对外提供一个添加任务的方法，用数组保存起来。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//add task 添加任务</span><br>- (<span class="hljs-type">void</span>)addTask:(RunloopBlock)unit withId:(<span class="hljs-type">id</span>)key&#123;<br>    <span class="hljs-comment">//添加任务到数组</span><br>    [<span class="hljs-keyword">self</span>.tasks addObject:unit];<br>    [<span class="hljs-keyword">self</span>.taskKeys addObject:key];<br><br>    <span class="hljs-comment">//为了保证加载到图片最大数是20所以要删除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.tasks.count &gt; <span class="hljs-keyword">self</span>.maxQueue) &#123;<br>        [<span class="hljs-keyword">self</span>.tasks removeObjectAtIndex:<span class="hljs-number">0</span>];<br>        [<span class="hljs-keyword">self</span>.taskKeys removeObjectAtIndex:<span class="hljs-number">0</span>];<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在ZXYRunloop初始化方法设置初始化对象和基本信息</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (instancetype)<span class="hljs-keyword">init</span>&#123;<br>    <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> [<span class="hljs-keyword">super</span> <span class="hljs-keyword">init</span>];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">//初始化对象／基本信息</span><br>        <span class="hljs-keyword">self</span>.maxQueue <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">self</span>.tasks <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableArray</span> array];<br>        <span class="hljs-keyword">self</span>.taskKeys <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableArray</span> array];<br>        <span class="hljs-keyword">self</span>.timer <span class="hljs-operator">=</span> [<span class="hljs-type">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">0.001</span> repeats:<span class="hljs-type">YES</span> block:<span class="hljs-operator">^</span>(<span class="hljs-type">NSTimer</span> <span class="hljs-operator">*</span> _Nonnull timer) &#123; &#125;];<br>        <span class="hljs-comment">//添加Runloop观察者</span><br>        [<span class="hljs-keyword">self</span> addRunloopObserver];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在TableViewCell中使用：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[[ZXYRunloop shareInstance]</span> addTask:^BOOL&#123;<br>        <span class="hljs-selector-attr">[ViewController addCenterImg:cell]</span>;<br>        return YES;<br>    &#125; withId:indexPath];<br></code></pre></td></tr></table></figure>

<p>总结一下思想</p>
<ul>
<li>加载图片的代码保存起来，不要直接执行，用一个数组保存 block </li>
<li>监听我们的Runloop循环 CFRunloop CFRunloopObserver </li>
<li>每次Runloop循环就让它从数组里面去一个加载图片等任务出来执行</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Runloop</div>
      <div>http://example.com/2019/03/16/Runloop/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>xushuanghui</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年3月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/03/26/GitLab-CI/" title="GitLab CI">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GitLab CI</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/01/30/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/" title="事件传递与响应者链">
                        <span class="hidden-mobile">事件传递与响应者链</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
