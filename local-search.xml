<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>首页容器化</title>
    <link href="/2023/01/11/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    <url>/2023/01/11/%E5%AE%B9%E5%99%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1、首页容器类Controller问题"><a href="#1、首页容器类Controller问题" class="headerlink" title="1、首页容器类Controller问题"></a>1、首页容器类Controller问题</h3><ul><li><p>首页承担了短视频推荐、关注、直播等场景，基础功能，登录、性能监控，预加载等细节的业务逻辑差异较多，目前多业务代码耦合在一起，增加新功能时需要考虑其他业务方，容易引入问题，开发和测试效率低。导致 ViewController 越来越膨胀</p></li><li><p>一个版本经常会有多个业务在VC中进行修改导致冲突的情况，此时就需要多方进行 review，保证改动不出问题。</p></li></ul><h3 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h3><p>1、VC生命周期：ViewDidload、ViewWillAppear、ViewWilldisAppear，业务：cell管理、直播、推荐、关注等</p><p>2、TableView管理和代理方法：cellForRow:  willDisplayCell等，</p><p>3、网络请求、其他</p><h3 id="业务迭代效率低"><a href="#业务迭代效率低" class="headerlink" title="业务迭代效率低"></a>业务迭代效率低</h3><p>一个版本经常会有多个业务在容器中进行修改导致冲突的情况。</p><h3 id="2、目标"><a href="#2、目标" class="headerlink" title="2、目标"></a>2、目标</h3><ul><li><p>架构分层，明确每层职责，容器和业务解耦，多业务之间解耦，做到容器和业务各自闭环；</p></li><li><p>业务组件可插拔，不同场景支持灵活的组合和扩展业务组件；</p></li><li><p>搭建监控体系，实现稳定性、性能、问题定位，建立看板，实时了解各项指标；</p></li><li><p>防劣化，容器和业务分仓隔离，收敛维护人员；</p><span id="more"></span></li></ul><h3 id="3、方案"><a href="#3、方案" class="headerlink" title="3、方案"></a>3、方案</h3><p>ControlerKit 工具实现了生命周期方法的分发，并且通过 Context 进行状态管理，实现了各个业务间的通信和状态维护</p><p>4、<strong>基础容器</strong></p><p> 基础容器，采用组件化框架，支持基础组件和业务组件的动态组合和扩展，由业务无关、统一的列表形态组成，通过数据驱动页面展现。同时对外暴露生命周期事件，方便组件进行监听。其中基础容器由平台方进行统一维护，并提供了完善的监控体系，方便进行问题的定位和追查</p><p>![image-20220811172413700](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220811172413700.png)</p><p>4.1<strong>基础组件</strong></p><p> 容器的基础组件部分主要包括播放控制、播放策略优化、列表预加载以及页面管理等。为多业务共用，具备可复用、可扩展等优势。</p><p>4.2 <strong>业务组件</strong></p><p>业务组件是和业务强相关的组件，业务方可以根据自身的需要进行灵活定制，组件本身可插拔，由各业务方进行维护</p><p>4.3<strong>应用场景</strong></p><p>业务方基于  容器，组合业务组件和基础组件构建的页面，在构造过程中可以基于配置文件实现容器的定制，比如推荐和关注。</p><h4 id="4-4-容器化工具"><a href="#4-4-容器化工具" class="headerlink" title="4.4 容器化工具"></a>4.4 容器化工具</h4><p>![image-20230314172427279](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314172427279.png) </p><p><strong>ContainerViewController</strong></p><p>ContainerViewController 是容器 ViewController，实现了 ContainerProtocol，保存了上下文环境，负责了各个生命周期方法的分发。</p><p><strong>ContainerProtocol</strong></p><p>声明了容器对外提供的属性和方法，方便各个 SubController 进行访问。</p><p><strong>ControllerProtocol</strong></p><p>声明了基础的声明周期和共有的方法。</p><p><strong>Controller</strong></p><p>Controller 是将 ViewController 中的代码拆分出来的子模块，可以接收分发出来的 viewDidLoad、viewWillAppear 等生命周期及自定义方法调用，还可以向 ViewController 中添加子 View。</p><p><strong>ControllerManager</strong></p><p>ControllerManager 负责 Controller 的注册、管理、方法分发。通过 classNameArray 返回 Controller 的字符串类名数组即可，可以支持 Controller 在其他仓库的能力</p><p>Manager 需要声明分发的 Controller 协议，只需要声明，不需要实现，Manager 内部会通过消息转发机制统一分发。</p><p><strong>各角色之间的关系</strong></p><p>ContainerViewController 实现了 ContainerProtocol，并持有 ControllerManager，各个子 Controller 注册到 ControllerManager 中，各个 Controller 可以通过 ContainerProtocol 访问容器的能力，ControllerManager 通过 ControllerProtocol 里面声明的方法进行分发。</p><p>比如：ContainerViewController 初始化后调用 viewDidLoad 时，会通过 ControllerManager 依次分发到实现该方法的 controller 中，各个 Controller 在自己的 viewDidLoad 方法中实现自己的逻辑即可。</p><p><strong>Controller 优先级</strong></p><ul><li>方法分发优先级按照数组提供的顺序，因此更基础的 Controller 应排在前面</li></ul><h4 id="5、防劣化建设"><a href="#5、防劣化建设" class="headerlink" title="5、防劣化建设"></a>5、防劣化建设</h4><p>首先进行框架和业务分仓：</p><ul><li>代码隔离，修改权限收敛;</li><li>业务方修改容器代码，review 通过后才能合入</li></ul><h3 id="存量功能拆分-监控"><a href="#存量功能拆分-监控" class="headerlink" title="存量功能拆分 - 监控"></a>存量功能拆分 - 监控</h3><p> 监控功能在 TableVC 中处理了很多业务，而且这些逻辑也其他业务存在着耦合。</p><ul><li>网络请求监控和数据处理</li><li>页面滚动</li><li>播放处理</li><li><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220813153021500.png" alt="image-20220813153021500" style="zoom:50%;" /></li></ul><h4 id="采用新方案进行拆分"><a href="#采用新方案进行拆分" class="headerlink" title="采用新方案进行拆分"></a>采用新方案进行拆分</h4><p>首先创建 MonitorController，增加业务相关的属性、生命周期方法中实现对应的逻辑，之后抽取单独的业务 controller 在生命周期方法中处理熟人相关逻辑。同时注册到 controllerManager 中，并设置 AB、原有代码判断 AB。上线验证，全量后删除容器老代码。之后业务自闭环，再进行迭代时直接在 MonitorController 内容修改即可。</p><p>![image-20220813105752765](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220813105752765.png)</p><p>容器不依赖具体子组件，因此容器不能调指定子组件的方法容器通过管理器分发方法到所有子组件中，实现即被调用，未实现跳过容器分发的方法都应该是抽象的，不是具体某个功能方法</p><p>![image-20230413153626508](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230413153626508.png)</p><p>容器通过容器协议提供子组件使用能力，子组件持有容器协议弱引用，因此可以直接调用容器协议提供的能力是有限的、抽象的，不能是具体某个功能的某个方法</p><p>![image-20230413160824553](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230413160824553.png)</p><p>子组件之间不希望有耦合不能直接调用其他子组件特殊情况，通过Context对象解决<br>Context是页面内上下文对象，4个特性:基础对象，可以直接加属性共享局部生效<br>K-V结构、可绑定K-Handler，KV存储时，调用Hander，类似通知</p><p>![image-20230413161029573](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230413161029573.png)</p><p>整体是MVVM结构<br>ViewModel负责数据逻辑处理，对视频Model的增、删、改、查、去重、过滤等DataController负责刷新、加载更多网络请求调用ViewModel数据变化驱动ViewController渲染UI</p><p>![image-20230314175254300](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314175254300.png)</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413151202282.png" alt="image-20230413151202282" style="zoom:50%;" /><p>明确职责、明确owner合理的设计、标准、流程工具、系统辅助</p><p>明确容器、业务职责容器由平台专人负责，并有保底投入时间各功能由业务方负责容器提供有限能力，如能力无法满足，和容器维护同学沟通，判断是否需要完善容</p><h3 id="03-设计方案-品质建设-线上-容灾"><a href="#03-设计方案-品质建设-线上-容灾" class="headerlink" title="03 设计方案 - 品质建设 - 线上 - 容灾"></a>03 设计方案 - 品质建设 - 线上 - 容灾</h3><p>Obiective-C调用未实现方法会崩溃重构时，接口很多，可能遗漏方法实现，导致不必要的崩溃利用Obiective-C语言消息转发可以实现这特性</p><p>![image-20230314180714745](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314180714745.png)</p><p>实施方案-启动阶段</p><ul><li>好的开始，是成功的一半，否则，可能没开始就结束了。</li></ul><p>获得支持</p><ul><li><p>who? leader、产品、测试、协作开发 Why? 问题的严重性、趋势，适当的夸张修辞手法</p><p>what? 人力</p></li></ul><p>乐观规划</p><ul><li>When? 时间，乐观估时</li></ul><h3 id="重构方式，不影响开发进度"><a href="#重构方式，不影响开发进度" class="headerlink" title="重构方式，不影响开发进度"></a>重构方式，不影响开发进度</h3><p>方案目标:重构质量，功能使用体验一致，如果出问题，可迅速还原代码重构过程中。</p><p>可正常迭代基本思路:<br><strong>实现一个全新(子)功能，通过ABTest动态切换两个功能、通过协议统一新旧功能使用。</strong></p><p>方式ABTest数据打平后，删除旧(子)功能ABTest: 切换开关、灰度放量能力、数据指标</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413151000180.png" alt="image-20230413151000180" style="zoom:50%;" /><p>一期: 抽象协议，使用方面向协议编程，不依赖具体实现类</p><p>二期: 基于协议，实现新功能，ABTest控制获取新旧功能实例</p><p>三期: 删掉旧功能、ABTest，保留协议、新功能，完成替换工作图形长度代表工总量</p><p>![image-20230413151043072](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230413151043072.png)</p><p>预先上车，先合入代码，开关控制功能生效合入后，新页面可以迭代了，业务同学，开发、测试2套功能同步需求并测试、真正的上车</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20230413163017894.png" alt="image-20230413163017894" style="zoom:50%;" /><p>收益&#x2F;投RO<br>产品数据、质量数据: ABTest、产品核心指标显著正向<br>效率相关 (不容易度量) : 调研问卷，两套页面共存期间可对照比较调研问卷显示开发效率和质量提升均在20%以上</p><p>![image-20230413162913625](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230413162913625.png)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态库懒加载</title>
    <link href="/2022/08/14/%E5%8A%A8%E6%80%81%E5%BA%93%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/08/14/%E5%8A%A8%E6%80%81%E5%BA%93%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、动态库懒加载"><a href="#1、动态库懒加载" class="headerlink" title="1、动态库懒加载"></a>1、动态库懒加载</h3><p>我们知道，pre-main 过程中，有dylib的加载步骤，而动态库加载是需要耗时的，苹果建议我们自定义的动态库不要超过 6 个，因此，尽量减少启动过程中的动态库加载有助于启动耗时的优化。减少启动过程中的动态库加载主要有以下两个方案：</p><ul><li>一个是动态库转静态库；</li><li>一个是多个动态库进行合并；</li></ul><h4 id="1-1、动态库懒加载方案"><a href="#1-1、动态库懒加载方案" class="headerlink" title="1.1、动态库懒加载方案"></a>1.1、动态库懒加载方案</h4><p>所谓动态库懒加载是指，在启动的过程中并不加载该动态库，而是在业务真正使用到该动态库中的内容时才进行加载，从而减少启动耗时。在 Cocoapods 1.2 之前存在配置动态库懒加载的入口，升级到 1.8 之后没有了动态库懒加载的配置入口，我们需要在pod install之后生成的配置文件中进行配置。使用 Cocoapods 管理的项目，在pod install之后，会生成Pods-xxx-frameworks.sh和Pods-xxx.adhoc&#x2F;debug&#x2F;release.xcconfig这两个文件，其中Pods-xxx-frameworks.sh文件脚本负责架构剔除和重签名等功能，而Pods-xxx.adhoc&#x2F;debug&#x2F;release.xcconfig文件则负责静态库和动态库的链接配置，我们自定义的动态库想要进行懒加载，只需要修改xxx.xcconfig配置文件，将需要懒加载的动态库从配置文件中移除，这样保证懒加载的动态库参与签名和拷贝，但是不参与链接。</p><h4 id="1-2、动态库懒加载后的调用方式"><a href="#1-2、动态库懒加载后的调用方式" class="headerlink" title="1.2、动态库懒加载后的调用方式"></a>1.2、动态库懒加载后的调用方式</h4><p>由于采用动态库懒加载后动态库在编译时没有参与链接，原有的代码调用方式会报找不到对应动态库符号的错误，因此，原有动态库的调用方式需要修改成Runtime动态调用的形式</p><p>正常动态库都是会被主二进制直接或者间接链接的，那么这些动态库会在启动的时候加载。<strong>如果只打包进 App，不参与链接，那么启动的时候就不会自动加载，在运行时需要用到动态库里面的内容的时候，再手动懒加载</strong>。</p><p>懒加载动态库需要在编译期和运行时都进行改造，编译期的架构：</p><p><img src="https://static001.infoq.cn/resource/image/53/a2/53277be65a8882bfb437aef8fba065a2.png" alt="img"></p><span id="more"></span><p>像 A.framework 等动态库是懒加载的，因为并没有参与主二进制的直接 or 间接链接。动态库之间一定会有一些共同的依赖，把这些依赖打包成 Shared.framework 解决公共依赖的问题。</p><p>运行时通过<code>-[NSBundle load]</code>来加载，本质上调用的是底层的 <code>dlopen</code>。那么什么时候触发动态库手动加载呢？</p><p>动态库可以分成两种：业务和功能。<strong>业务就是 UI 的入口，可以把动态库加载的逻辑收敛到路由内部，这样外部其实并不知道动态库是懒加载的，也能更好地容错</strong>。功能库（比如上图的 QR.framework）会有些不一样，因为没有 UI 等入口，需要功能库自己维护 Wrapper：</p><ul><li><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210506165131007.png" alt="image-20210506165131007" style="zoom: 33%;" /></li><li>App 对 Wrapper 直接依赖，这样外部并不知道这个动态库是懒加载的</li><li>Wrapper 内部封装了动态调用逻辑，动态调用指的是通过 dlsym 等方式调用</li></ul><p>动态库懒加载除了启动加载的代码减少，还能长期防止业务增加代码引起启动劣化，因为业务的初始化在第一次访问的时候完成的。</p><p>这个方案还有其他优点，比如动态库化后本地编译时间会大幅度降低，对其他性能指标也有好处，缺点是会牺牲一定程度的包大小，但可以用段压缩等方式优化懒加载的动态库来打平这部分损耗。</p><p>启动阶段</p><ul><li>![image-20230227114633430](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227114633430.png)</li></ul><p>![image-20230227122559375](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227122559375.png)</p><p>![image-20230227122716726](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227122716726.png![image-20230227123220049](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227123220049.png)</p><p>在运行时按需加载：</p><p>dlopen：传入动态库的路径，加载成功会返回动态库在内存中的句柄。</p><p>dlerror：获取失败信息。</p><p>懒加载的动态库不能直接通过类或方法调用动态库中的逻辑。</p><p>因为： 1、没有依赖关系，2、不知道动态库是否加载，相关的类是否在内存中。</p><p>所以：需要将动态库对外提供的能力进行逻辑出口，使用特定的协议和实现，在组件化框架在调用接口的时候尝试去加载动态库。组件化框架则需要通过NSClassFromString方法的返回值来判断类和动态库是否已加载。</p><h2 id="防劣化"><a href="#防劣化" class="headerlink" title="防劣化"></a>防劣化</h2><p>![image-20230227120616813](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227120616813.png)</p><p>1、开发阶段-断言：调用dlopen时机早于启动完成，提示修改</p><p>2、MR阶段-流水线检查：push代码，diff修改，静态文本分析，检查风险点，code review</p><p>上线前阶段：埋点、监控，报警</p><p>各个机型平均优化35%左右的pre main耗时收益，如600ms可优化200ms.</p><p>![image-20230227122416059](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227122416059.png)</p><h2 id="预获取动态库注册信息"><a href="#预获取动态库注册信息" class="headerlink" title="预获取动态库注册信息"></a>预获取动态库注册信息</h2><p>![image-20230227141938355](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227141938355.png)</p><h3 id="iOS-App-的一种规范启动项执行流程方案"><a href="#iOS-App-的一种规范启动项执行流程方案" class="headerlink" title="iOS App 的一种规范启动项执行流程方案"></a>iOS App 的一种规范启动项执行流程方案</h3><p>Protocol-class、url-class&#x2F;block、String-Class</p><p>他们都有一些相同点，都是又一种映射关系。 根据Protocol、URL或者String来找到具体的实现类Class、Block。</p><p>达到代码解耦，跨语言调用的目的。业务代码一般在启动阶段就完成了注册关系的绑定。</p><p>1、启动注册：需要依赖所有的实现类，就没办法达到解耦的目的。而且业务也需要依赖启动状态是完成的状态才可以，真正进行调用</p><p>2、+load注册：虽然可以代码隔离，但会影响pre main阶段的耗时增加。 </p><h3 id="3、data段注册：使用更广泛的是data段注册方式"><a href="#3、data段注册：使用更广泛的是data段注册方式" class="headerlink" title="3、data段注册：使用更广泛的是data段注册方式"></a>3、data段注册：使用更广泛的是data段注册方式</h3><p>![image-20230227151812259](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227151812259.png)</p><p>编译期写入：我们可以将attribute,used,section的这种方法把指定的数据写入data段中</p><p>运行期读取：首先我们要拿到当前已经加载的所有可执行文件的数量，进行逐个遍历拿到每个可执行文件的header。去掉用getsectiondata()方法，获取指定data段，指定section中的数据。根据写入类容的内存布局，我们就可以成功解析出所有我们需要的注册信息。这种注册方式，既可以实现代码隔离，又可以选择时机，也不会像+load那样真加pre main阶段耗时。</p><h2 id="矛盾点、难点"><a href="#矛盾点、难点" class="headerlink" title="矛盾点、难点"></a>矛盾点、难点</h2><p>![image-20230227153538993](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227153538993.png)</p><p>1、<strong>循环依赖的现象</strong>：调用动态库逻辑时，需要先读取注册信息，读取注册信息又依赖动态库已经加载。而动态库加载需要动态库名称、动态库路径。动态库名称路径又是与注册信息绑定在一起的。</p><h2 id="解决方案：预获取动态库注册信息"><a href="#解决方案：预获取动态库注册信息" class="headerlink" title="解决方案：预获取动态库注册信息"></a>解决方案：预获取动态库注册信息</h2><p>![image-20230227161133988](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227161133988.png)</p><p>动态库也是macho order结构：header、load commands、data。系统lyld根据文件中的数据，解析之后来进行加载。</p><p>1、直接解析动态库文件，提前获取到我们在编译期写入的注册信息。</p><p>2、注册信息与动态库路径、名称一并存储，这样调用具体逻辑时按需加载动态库</p><p>启动时候，读取已加载的动态库信息，再读取未加载的动态库信息。</p><p>调用动态库时候，从注册信息里边找到动态库名称或者路径，来加载动态库。加载完成之后就会触发已加载动态库的读取逻辑，覆盖原本的映射信息，再完成最终的逻辑调用。 </p><h2 id="动态库改静态库"><a href="#动态库改静态库" class="headerlink" title="动态库改静态库"></a>动态库改静态库</h2><p>苹果官方有提到尽可能减少启动阶段加载动态库数量。 减少启动时间。</p><p>把启动动态库的代码，都集成到主执行文件当中。 </p><p>非启动的动态库，继续保持懒加载。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>懒加载的动态库无法在xcode中配置成依赖主执行文件。在编译的时候，会找不到位于base动态库的链接符号。</p><p>![image-20230227163110268](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227163110268.png)</p><p>![image-20230227163506930](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227163506930.png)</p><p>这个配置可以忽略，编译器哪些找不到符号的错误，在加载的时候，再去内存中查找所需要的符号。</p><p>![image-20230227164420621](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227164420621.png)</p><p>主执行文件导出符号问题</p><p>动改静pre main收益10%左右：</p><p>![image-20230227164352653](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227164352653.png)</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>1、智能预加载：根据业务逻辑，用户习惯。在不影响启动性能的前提下，预加载动态库。</p><p>2、prewarm</p><p>![image-20230227165230082](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227165230082.png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、动态库懒加载：</p><p>把启动不需要的业务，以动态库的形式进行懒加载，可以减少启动pre main阶段的耗时。</p><p>2、如何实现懒加载：</p><ul><li>去除启动依赖，避免被系统拉起</li><li>在运行阶段，通过dlopen按需加载</li><li>防止劣化，防止启动阶段调用dlopen的措施</li></ul><p>3、 两个难点方案</p><ul><li>与获取动态库注册信息，通过直接解析动态库文件。解决的懒加载动态库调用的循环依赖问题。</li></ul><p>4、后续展望</p><ul><li>代码持续减少</li><li>智能预加载</li><li>ios15的pre warm方案</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程问题专项治理</title>
    <link href="/2022/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B2%BB%E7%90%86/"/>
    <url>/2022/03/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1、目的"><a href="#1、目的" class="headerlink" title="1、目的"></a>1、目的</h2><p>多线程专项治理目的就是降低crash，手机发烫，耗电等问题。</p><h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><h4 id="2-1-滥用使用全局队列，并且使用了队列的默认优先级"><a href="#2-1-滥用使用全局队列，并且使用了队列的默认优先级" class="headerlink" title="2.1 滥用使用全局队列，并且使用了队列的默认优先级"></a>2.1 滥用使用全局队列，并且使用了队列的默认优先级</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>       <span class="hljs-comment">//TODO </span><br>&#125;);<br></code></pre></td></tr></table></figure><p>导致大量的全局队列默认优先级，导致了一人干活，全家围观，还增加了造成线程死锁风险，从而引发crash</p><h4 id="2-2-大量不必要的线程切换"><a href="#2-2-大量不必要的线程切换" class="headerlink" title="2.2 大量不必要的线程切换"></a>2.2 大量不必要的线程切换</h4><h4 id="2-3-在高并发场景，没有控制并发量，而使用了全局队列创建了大量线程"><a href="#2-3-在高并发场景，没有控制并发量，而使用了全局队列创建了大量线程" class="headerlink" title="2.3  在高并发场景，没有控制并发量，而使用了全局队列创建了大量线程"></a>2.3  在高并发场景，没有控制并发量，而使用了全局队列创建了大量线程</h4><span id="more"></span><p><em>实时获取位置信息 异步</em></p><p>多个业务请求需要依赖getAddress异步返回的数据，所以会导致，多个getAddress并发，然而方法内部并未控制并发，而且还采用了全局队列默认优先级，当业并发大的时候，这里会偶现死锁。</p><p>&#x2F;&#x2F;实时获取位置信息 异步</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)getAddress<br>&#123;<br>  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    __block <span class="hljs-built_in">CLLocation</span> *location;<br>    __block <span class="hljs-built_in">NSDictionary</span> *regeoInfo;<br>       <span class="hljs-comment">//业务处理</span><br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-业务使用线程的不合理"><a href="#2-4-业务使用线程的不合理" class="headerlink" title="2.4 业务使用线程的不合理"></a>2.4 业务使用线程的不合理</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-built_in">NSMutableArray</span>&lt;<span class="hljs-built_in">NSDictionary</span> *&gt; *imageArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br>   <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSDictionary</span> *photoDict <span class="hljs-keyword">in</span> readyUploadImageArray) &#123;<br>     <span class="hljs-comment">// 上传照片</span><br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>业务使用线程不合理，业务要求是所有需要上传的图片，并发上传。实际上全局队列默认优先级分配一个线程后，多个任务挤在一个线程，并未达到业务预期的目的。</p><h3 id="2-5-线程死锁引起的crash"><a href="#2-5-线程死锁引起的crash" class="headerlink" title="2.5 线程死锁引起的crash"></a>2.5 线程死锁引起的crash</h3><p>当大面积出现<strong>psynch_cvwait，semwait_signal，psynch_mutexwait，psynch_mutex_trylock，dispatch_sync_f_slow等信息时，可以初步判定为线程死锁。比如：</strong></p><p><strong>当然优先级反转也会导致死锁，具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。导致陷入死锁 。</strong></p><h3 id="2-6-子线程刷新UI引起的crash"><a href="#2-6-子线程刷新UI引起的crash" class="headerlink" title="2.6 子线程刷新UI引起的crash"></a>2.6 子线程刷新UI引起的crash</h3><p>子线程刷新UI的问题，有比较具体的提示信息，还是比较容易发现的。</p><h3 id="2-7-线程安全引发的crash"><a href="#2-7-线程安全引发的crash" class="headerlink" title="2.7 线程安全引发的crash"></a>2.7 线程安全引发的crash</h3><p>由于多线程读写问题的crash比较隐秘，发现难，定位难，所以，当出现<strong>pthread_kill，_objc_release，malloc: error for object 0x7912d6d0: pointer being freed was not allocated等信息时，可以初步判定为多线程读写问题</strong></p><h2 id="3、方案"><a href="#3、方案" class="headerlink" title="3、方案"></a>3、方案</h2><p>主要从队列的管理和分配，高并发业务的梳理和重构，线程使用的合理性评估与改造，线程相关crash的排查和修复，长效机制的建立几个方面。</p><h3 id="3-1-采取新的队列管理和优先级分配制度"><a href="#3-1-采取新的队列管理和优先级分配制度" class="headerlink" title="3.1 采取新的队列管理和优先级分配制度"></a>3.1 采取新的队列管理和优先级分配制度</h3><p>根据业务特点，我们决定为不同的优先级，创建与CPU核数相等的串行队列，通过优先级的合理使用和串行队列的调度，充分利用时间片和多核的效率</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br>NS_ASSUME_NONNULL_BEGIN<br> @interface HSAQueuePool : NSObject<br><span class="hljs-comment">//与用户交互的任务，这些任务通常跟UI级别的刷新相关，比如动画，cell高度，frame等UI的计算</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">HSAQueueForQoSUserInteractive</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//由用户发起的并且需要立即得到结果的任务，比如读取数据（配置，用户信息等）来加载UI，会在几秒或者更短的时间内完成</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">HSAQueueForQoSUserInitiated</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//一些耗时的任务，比如复杂的组合的网络请求，图片下载，上传</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">HSAQueueForQoSUtility</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//对用户不可见，可以长时间在后台运行，比如，拉取配置，地理位置上报，日志上报等</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">HSAQueueForQoSBackground</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">//默认，不推荐作为首选使用</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">dispatch_queue_t</span> <span class="hljs-title">HSAQueueForQoSDefault</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br> @end<br>NS_ASSUME_NONNULL_END<br></code></pre></td></tr></table></figure><p>业务使用改动小，只需在原有基础上根据业务特点，补充合理的优先级即可。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_async</span>(HLLQueueForQoSUserInitiated(), ^&#123;<br>    <span class="hljs-comment">//垃圾机型，读取data，可能会导致卡顿,所以加了个线程。</span><br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:[<span class="hljs-built_in">NSURL</span> URLWithString:urlString]];<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="3-2-梳理线程并发较大的业务进行重构"><a href="#3-2-梳理线程并发较大的业务进行重构" class="headerlink" title="3.2 梳理线程并发较大的业务进行重构"></a>3.2 梳理线程并发较大的业务进行重构</h3><p>当大量的业务并发，调用getAddress时，getAddress方法内部采用全局队列(默认的优先级)生成大量线程去处理数据，从而造成死锁或者线程资源耗尽，crash。</p><ol><li>梳理业务，适当降低并发甚至规避并发。</li><li>当业务并发调用getAddress时，如果有该业务数据缓存，则直接返回。</li></ol><h3 id="3-3-线程使用的合理性评估与改造，减低线程使用，线程切换"><a href="#3-3-线程使用的合理性评估与改造，减低线程使用，线程切换" class="headerlink" title="3.3 线程使用的合理性评估与改造，减低线程使用，线程切换"></a>3.3 线程使用的合理性评估与改造，减低线程使用，线程切换</h3><ol><li>不可预估完成时间的任务，比如图片上传下载，普通接口请求</li><li>计算量比较大的，比如加解密，数据计算和处理</li><li>有可能卡顿主线程的任务，比如UI的计算与渲染</li><li>如无必要，不要随意开启线程。</li></ol><h3 id="3-4-死锁问题的重点攻坚"><a href="#3-4-死锁问题的重点攻坚" class="headerlink" title="3.4 死锁问题的重点攻坚"></a>3.4 死锁问题的重点攻坚</h3><p><strong>线程的生命周期</strong>：<strong>新建</strong>、<strong>就绪</strong>、<strong>运行</strong>、<strong>阻塞</strong>、<strong>死亡</strong></p><p><strong>由于死锁问题比较隐蔽，通常很难发现从而去排查，我们只能通过在bugly和内部的crash系统上，分析堆栈信息</strong></p><p>当发现线程大面积的堆栈出现了<strong>psynch_cvwait，semwait_signal，psynch_mutexwait，psynch_mutex_trylock，dispatch_sync_f_slow</strong>等信息时，就可以大胆怀疑线程非正常原因阻塞，而导致的死锁</p><p>排查：</p><p>1.锁用的是否合理</p><p>2.线程的数量是否远超平时的线程数量</p><p>3.是否使用了NSRecursiveLock，此递归锁不支持多线程递归，因为会造成优先级反转</p><p>4.排查业务，线程长时间的阻塞，导致任务无法正常执行，也会造成死锁</p><p>5.<strong>SCNetworkReachabilityGetFlags</strong>，此方法只能在子线程调用，否则会造成主线程同步阻塞</p><ul><li><h3 id="3-5-子线程刷新UI的重点排查与治理"><a href="#3-5-子线程刷新UI的重点排查与治理" class="headerlink" title="3.5 子线程刷新UI的重点排查与治理"></a>3.5 子线程刷新UI的重点排查与治理</h3><p>为什么子线程刷UI，只是偶现crash呢？因为在苹果现有框架下，刷新UI是一种线程不安全的操作，所以必须放在主线程。放在子线程，恰好竞争同一资源时，才会crash。</p><p><strong>统一检查处理</strong>：</p><ol><li>h5交互的回调</li><li>二方库，三方库的代理和回调</li><li>通知</li><li>kvo相关</li><li>接口回调</li></ol><p>因为通知和kvo的触发和处理都在同一线程，如果子线程触发，那么就有可能子线程刷新UI</p><h3 id="3-6-线程安全问题的实质，就是多线程写的问题"><a href="#3-6-线程安全问题的实质，就是多线程写的问题" class="headerlink" title="3.6 线程安全问题的实质，就是多线程写的问题"></a>3.6 线程安全问题的实质，就是多线程写的问题</h3><p><strong>所以在涉及到多线程读写问题时，对所有的写进行串行或者加锁操作</strong></p><p>锁和串行队列的区别，锁中间的执行操作相当于是串行队列。锁的特点是，锁定范围越小越好，但是锁会造成死锁。gcd串行队列，则不会有死锁的问题</p><h2 id="4、建立线程数量监控预警体系"><a href="#4、建立线程数量监控预警体系" class="headerlink" title="4、建立线程数量监控预警体系"></a>4、建立线程数量监控预警体系</h2><p>pthread库中提供了一个用于监控线程创建、运行、结束、销毁的内省函数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">pthread_introspection_hook_t</span>)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> event, <span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><p>在启动时，可以选择启动监控，开始监控线程数量。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">enum &#123;<br>    PTHREAD_INTROSPECTION_THREAD_CREATE = <span class="hljs-number">1</span>, <span class="hljs-regexp">//</span>创建线程<br><br>    PTHREAD_INTROSPECTION_THREAD_START, <span class="hljs-regexp">//</span> 线程开始运行<br><br>    PTHREAD_INTROSPECTION_THREAD_TERMINATE,  <span class="hljs-regexp">//</span>线程运行终止<br><br>    PTHREAD_INTROSPECTION_THREAD_DESTROY, <span class="hljs-regexp">//</span>销毁线程<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过线程状态改变，来记录线程数量。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_introspection_hook_t</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> event</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//创建线程，则线程数量和线程增长数都加1</span><br>    <span class="hljs-keyword">if</span> (event == PTHREAD_INTROSPECTION_THREAD_CREATE) &#123;&#125;<br>    <span class="hljs-comment">//销毁线程，则线程数量和线程增长数都减1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event == PTHREAD_INTROSPECTION_THREAD_DESTROY)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在iOS开发中，我们常将耗时任务提交给GCD的并发队列，但是并发队列并不会去管理最大并发数，无限制提交任务给并发队列，会给性能带来问题。</p></li><li><p>YYKit组件中的YYDispatchQueuePool 也能控制并发队列的并发数；其思路是为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。</p></li><li><p>DispatchQueue是使用信号量让并发队列中的任务并发数得到抑制；YYDispatchQueuePool是让一定数量的串行队列代替并发队列，避开了并发队列不好控制并发数的问题。</p></li></ul><p>​    <strong>降低crash和性能损耗，从复盘数据来看，crash修复情况和性能优化均符合预期</strong></p><ul><li>涉及到的crash数量大约在500左右，粗略计算降低了crash率万分之8</li><li>线程的平均数量从之前的51.3，降低到现在的41.6，线程损耗大约是原来的81%，性能节省了大约18.7%</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>直播性能指标监控方案</title>
    <link href="/2021/07/20/%E7%9B%B4%E6%92%AD%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/"/>
    <url>/2021/07/20/%E7%9B%B4%E6%92%AD%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数据收集"><a href="#一、数据收集" class="headerlink" title="一、数据收集"></a>一、数据收集</h2><p>完整的直播环节：采集、预处理、编码、推流、（传输、转码、分发）、拉流、解码、播放</p><ol><li>主播和观众端各自每10秒向服务器打点。</li><li>服务器接收到打点信息，为前端监控页面实时统计客户端直播播放情况。</li></ol><h3 id="1、主播端"><a href="#1、主播端" class="headerlink" title="1、主播端"></a>1、主播端</h3><ul><li>摄像头（分辨率、帧率、机型）–&gt; 视频预处理（cpu占用、内存占用）–&gt; 编码（视频质量、帧率）–&gt; 码率自适应（码率、丢帧数、卡顿数）–&gt; 地理位置、服务器的IP</li></ul><h3 id="2、播放端"><a href="#2、播放端" class="headerlink" title="2、播放端"></a>2、播放端</h3><ul><li><p>cdn边缘节点（节点运营商、地理位置、ping值）–&gt; 发送端至接收端延迟 –&gt; 接收缓冲（开播buffer长度、卡顿次数、卡顿时长）–&gt; 视频解码（帧率）–&gt; 播放（首帧时间）</p></li><li><p>播放失败的时候，上报错误信息和原因</p><span id="more"></span></li></ul><h2 id="二、直播性能指标建立"><a href="#二、直播性能指标建立" class="headerlink" title="二、直播性能指标建立"></a>二、直播性能指标建立</h2><ul><li>帧率：正常来说每秒15帧以上的视频流才能保证观看的流畅度，常规推流如果 FPS 在10帧以下，观众就会明显的感到画面卡顿</li></ul><h3 id="1、技术指标："><a href="#1、技术指标：" class="headerlink" title="1、技术指标："></a>1、技术指标：</h3><ul><li>房间故障，包括卡顿、丢帧、音视频不同步等。</li><li>分地域统计数据端到端延迟平均情况。</li><li>统计实时整体卡顿率（出现卡顿的在线用户数&#x2F;在线总用户数*100%，通过此指标可以衡量当前卡顿影响的人群范围）。</li><li>统计人均卡顿次数（在线卡顿总次数&#x2F;在线用户数，通过此指标可以从卡顿频次上衡量整体的卡顿严重程度）。</li></ul><h3 id="2、用户体验指标："><a href="#2、用户体验指标：" class="headerlink" title="2、用户体验指标："></a>2、用户体验指标：</h3><ul><li>次均观看时长</li><li>在线人数</li><li>看完播率</li><li>用户评论卡顿数（用户在评论区打出，“卡”等相关意义字符）</li></ul><h2 id="三、视频直播卡顿原因、优化"><a href="#三、视频直播卡顿原因、优化" class="headerlink" title="三、视频直播卡顿原因、优化"></a>三、视频直播卡顿原因、优化</h2><p>卡顿的原因主要有三种：</p><ul><li><p><strong>原因1：上传阻塞</strong></p></li><li><p><strong>原因2：推流帧率太低</strong></p></li><li><p><strong>原因3：下行不佳</strong></p><p>80%以上的直播间卡顿问题，均是由于主播端上传阻塞所致。</p></li></ul><h3 id="1-上传阻塞的评判"><a href="#1-上传阻塞的评判" class="headerlink" title="1. 上传阻塞的评判"></a>1. 上传阻塞的评判</h3><ul><li><p><strong>1.1：BITRATE 与 NET_SPEED 的关系</strong><br>BITRATE( &#x3D; VIDEO_BITRATE + AUDIO_BITRATE ) 指的是编码器每秒产生了多少音视频数据要推出去，NET_SPEED 指的是每秒钟实际推出了多少数据，所以如果 BITRATE &#x3D;&#x3D; NET_SPEED 的情况是常态，则推流质量会非常良好；而如果 BITRATE &gt;&#x3D; NET_SPEED 这种情况的持续时间比较长，推流质量就很难有什么保障。</p></li><li><p><strong>1.2：CACHE_SIZE 和 DROP_CNT 的数值</strong><br>BITRATE &gt;&#x3D; NET_SPEED 的情况一旦出现，编码器产生的音视频数据就会在主播的手机上积压起来，积压的严重程度以 CACHE_SIZE 这个状态值展示出来，如果 CACHE_SIZE 超过警戒线，SDK 会主动丢弃一些音视频数据，从而触发 DROP_CNT 的增长。下图所示就是一个典型的上行阻塞，途中 CACHE_SIZE 始终在<strong>红色警戒线</strong>以上，说明上行网络不足以满足数据的传输需求，也就是上行阻塞严重</p></li></ul><h3 id="2-上传阻塞优化方案"><a href="#2-上传阻塞优化方案" class="headerlink" title="2. 上传阻塞优化方案"></a>2. 上传阻塞优化方案</h3><ul><li><p><strong>2.1 主动提示主播</strong></p></li><li><p><strong>2.2 合理的编码设置</strong></p><p>分辨率：540 * 960，码率：1200kbps</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3-1-帧率太低的评判"><a href="#3-1-帧率太低的评判" class="headerlink" title="3.1 帧率太低的评判"></a>3.1 帧率太低的评判</h3><p>通过直播 LivePushListener 的 <strong>VIDEO_FPS</strong> 的状态数据，我们可以获得当前推流的视频帧率。正常来说每秒15帧以上的视频流才能保证观看的流畅度，常规推流如果 FPS 在10帧以下，观众就会明显的感到画面卡顿</p><h3 id="3-针对性优化方案"><a href="#3-针对性优化方案" class="headerlink" title="3. 针对性优化方案"></a>3. 针对性优化方案</h3><ul><li><strong>3.1 观察 CPU_USAGE 的大小</strong></li></ul><p>通过直播 SDK 的 LivePushListener 的 <strong>CPU_USAGE</strong> 的状态数据，我们可以获得<strong>当前推流 SDK 的 CPU 占用情况</strong>和<strong>当前系统的 CPU 占用情况</strong>。如果当前系统的整体 CPU 使用率超过80%，那么视频的采集和编码都会受到影响，无法正常发挥作用；如果 CPU 使用率达到100%，那么主播端本身就已经很卡，观众端要有流畅的观看体验显然是不可能的</p><ul><li><strong>2.3 不盲目追高分辨率</strong><br>过高的视频分辨率并不一定能带来清晰的画质：首先，较高的分辨率要配合较高的码率才能发挥效果，低码率高分辨的清晰度很多时候比不上高码率低分辨率。其次，像1280 x 720这样的分辨率在平均5寸左右的手机屏幕上并不能看出优势，要想跟960 x 540的分辨率拉开差距，只有在 PC 上全屏观看才能有明显的感官差异。但较高的分辨率会显著提升 SDK 的 CPU 使用率，因此常规情况下推荐使用 直播 SDK 中 LivePusher 的 <a href="https://cloud.tencent.com/document/product/454/7885#7.-.E8.AE.BE.E5.AE.9A.E7.94.BB.E9.9D.A2.E6.B8.85.E6.99.B0.E5.BA.A6">setVideoQuality</a> 设置<strong>高清</strong>档即可，盲目追高分辨率有可能达不到预期的目标。</li><li><strong>2.4 适当使用硬件加速</strong><br>现在的智能手机都支持硬件编码来降低视频编码对 CPU 的依赖，如果您发现您的 App 的 CPU 使用率过高，可以开启硬件编码来降低 CPU 使用率</li></ul><h3 id="4、优化播放端"><a href="#4、优化播放端" class="headerlink" title="4、优化播放端"></a>4、优化播放端</h3><h4 id="4-1-卡顿与延迟"><a href="#4-1-卡顿与延迟" class="headerlink" title="4.1 卡顿与延迟"></a>4.1 卡顿与延迟</h4><p>​如果想要让观看端的视频卡顿尽量少，就要尽可能地让 App 缓存足够多的视频数据，以保证它能平安度过这些“饥饿期”，但是 App 缓存太多的音视频数据会引入一个新的问题，即<strong>高延迟</strong>。<strong>延迟和流畅是一架天平的两端</strong>。</p><p>​setAutoAdjustCache自动模式。在该模式下播放器会根据当前网络情况，对延迟进行自动调节（默认情况下播放器会在1秒 - 5秒这个区间内自动调节延迟大小</p><h4 id="4-2造成直播视频卡顿的原因主要有设备、视频流、网络这三方面的问题。"><a href="#4-2造成直播视频卡顿的原因主要有设备、视频流、网络这三方面的问题。" class="headerlink" title="4.2造成直播视频卡顿的原因主要有设备、视频流、网络这三方面的问题。"></a>4.2<strong>造成直播视频卡顿的原因主要有设备、视频流、网络这三方面的问题。</strong></h4><p><strong>设备</strong>：</p><p>高清视频往往会给硬件带来解码压力</p><ul><li>降低视频码率，选择流畅或者标清画质进行视频播放；</li><li>增大播放器缓冲区，缓解因网络或解码不稳定引起的卡顿。</li></ul><p><strong>视频流参数配置问题</strong></p><ul><li>设置合理的码率，帧率，分辨率，关键帧间隔，音视频编码格式等参数；</li><li>尽量遵循标准的视频编码方案，流媒体传输协议，对视频流进行采集，编码，解码，播放等操作。</li></ul><p><strong>上传网络</strong></p><p>当主播端网络较差时，会导致推流端上行不稳定，这个时候可以通过 <a href="https://link.zhihu.com/?target=http://www.speedtest.net/">speedtest</a> 进行测速，判断主播端的网络速度</p><p><strong>下行网络</strong></p><ul><li><p>用户通过 <a href="https://link.zhihu.com/?target=http://www.speedtest.net/">speedtest</a> 进行测速，判断终端的网络速度；</p></li><li><p>用户 ping 播放域名，查看解析到的服务器节点，判断自身IP 到服务器之间是否有延迟过大或者丢包的情况出现；</p></li><li><p>联系 CDN 厂商排查线路是否有不稳定的现象，也可以通过播放器打点上报，统计所有客户端的整体卡顿率情况，分地区做一些线路和资源的调整和优化。</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220830173952538.png" alt="image-20220830173952538" style="zoom:67%;" /></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>视频相关优化</title>
    <link href="/2021/05/14/%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"/>
    <url>/2021/05/14/%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="一、常见播放问题"><a href="#一、常见播放问题" class="headerlink" title="一、常见播放问题"></a>一、常见播放问题</h2><ul><li>列表加载慢</li><li>视频起播慢</li><li>视频播放失败</li><li>播放过程中卡顿</li><li>视频画面模糊</li><li>串音、有声无画、有画无声、声话不同步</li></ul><h4 id="1、收集问题"><a href="#1、收集问题" class="headerlink" title="1、收集问题"></a>1、收集问题</h4><ul><li>主动发现、收集，解决用户在播放过程中遇到的问题</li><li>推进从发布到播放的全链路优化，不断迭代播放策略</li></ul><span id="more"></span><p>![image-20230314155256604](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314155256604.png)</p><p>![image-20230314160938516](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314160938516.png)</p><p>![image-20230314161338006](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314161338006.png)</p><h3 id="二、首刷缓存方案"><a href="#二、首刷缓存方案" class="headerlink" title="二、首刷缓存方案"></a>二、首刷缓存方案</h3><p>![image-20230314162200347](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314162200347.png)</p><ul><li><p>数据获取：受网络、服务响应 （数据传输、推荐算法）因素影响，是造成耗时的主要因素</p></li><li><p>渲染过程：受机型配置等客观因素影响，不在优化的范畴。</p></li><li><p>为了缩短数据获取的时间，将数据获取方式优化为从本地磁盘读取（空间换时间思路)</p></li><li><p>启动读取缓存视频的同时正常请求新的视频列表</p></li><li><p>缓存视频关键点：需要保障画风符合用户喜好</p></li><li><p>缓存机制关键点：需要兼容广告等其他业务，可以灵活控制</p></li></ul><h3 id="三、视频分辨率选档策略"><a href="#三、视频分辨率选档策略" class="headerlink" title="三、视频分辨率选档策略"></a>三、视频分辨率选档策略</h3><p>如何在保证流畅度的前提下，提供用户最佳清晰度的视频（平衡卡顿与画质之间的关系）</p><p>![image-20230314162623076](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314162623076.png)</p><p>![image-20230314162843398](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314162843398.png)</p><p>![image-20230314163020117](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314163020117.png)</p><h3 id="四、画质提升"><a href="#四、画质提升" class="headerlink" title="四、画质提升"></a>四、画质提升</h3><p>![image-20230314163524427](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314163524427.png)</p><p>![image-20230314163734063](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314163734063.png)</p><h3 id="五、播放质量"><a href="#五、播放质量" class="headerlink" title="五、播放质量"></a>五、播放质量</h3><p>![image-20230314164122343](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314164122343.png)</p><p>![image-20230314164248908](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314164248908.png)</p><p>![image-20230314164517181](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314164517181.png)</p><p>![image-20230314164956646](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314164956646.png)</p><h3 id="六、新方向"><a href="#六、新方向" class="headerlink" title="六、新方向"></a>六、新方向</h3><p>![image-20230314165527206](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314165527206.png)</p><p>![image-20230314165731471](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314165731471.png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>![image-20230314165826344](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230314165826344.png) </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webview白屏问题记录</title>
    <link href="/2021/04/17/webview%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/04/17/webview%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>5.<strong>webview白屏问题</strong></p><p>一. URL网址无效或含有中文字符（入门级错误）<br>二、HTTP请求问题，设置URL Scheme 白名单<br>三. HTTPS 请求，未实现证书认证代理导致页面不加载的问题<br>didReceiveAuthenticationChallenge创建凭证，申请访问<br>四. iOS 8.0 - iOS 8.2 偶尔白屏问题</p><p><strong>白屏：遍历快照缩放后图片的像素点，对纯白像素占比大于99%的页面，认定其为白屏问题页。重新刷新</strong><br>六.  硬件内存不足、进程崩溃   <br>在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。在 WKWebView 中加载下面的测试链接可以稳定重现白屏现</p><p>这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。参考解决方案：</p><h3 id="1、借助-WKNavigtionDelegate"><a href="#1、借助-WKNavigtionDelegate" class="headerlink" title="1、借助 WKNavigtionDelegate"></a>1、借助 WKNavigtionDelegate</h3><p>   iOS 9以后 WKNavigtionDelegate 新增了一个回调函数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView <span class="hljs-built_in">API_AVAILABLE</span>(<span class="hljs-built_in">macosx</span>(<span class="hljs-number">10.11</span>), <span class="hljs-built_in">ios</span>(<span class="hljs-number">9.0</span>))<br></code></pre></td></tr></table></figure><p>​    当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p><p>2、检测 webView.title 是否为空</p><p><strong>3、某种资源加载失败了，也许是wk的某种机制把加载过的资源释放了</strong></p><p>于是尝试在本地html中加入资源加载的监听，只要发生错误，就调用location.reload();重载当前文档</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制重排</title>
    <link href="/2021/04/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/"/>
    <url>/2021/04/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><p>优化前</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/29/1725eb8e7708dcfc~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>优化后</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/29/1725eb91f4f83a64~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>启动优化</p><h3 id="1、二进制重排实践"><a href="#1、二进制重排实践" class="headerlink" title="1、二进制重排实践"></a>1、二进制重排实践</h3><p>二进制重排的关键是获取启动过程中的符号，目前业界常用方案有：</p><ul><li>基于静态扫描+运行时 trace 的方案来获取启动时的符号，从而生成 order file 文件实现二进制重排；</li><li>基于 Clang 静态插桩的方式来获取启动过程中的所有函数符号；</li></ul><p>第一种方案存在对于initialize、block、以及 C++ 函数hook 不到的问题，第二种基于 Clang 静态插桩的方案则可以解决前种方案的不足获取到所有符号。因此，我们选择了基于 Clang 静态插桩的方案来获取启动符号.</p><h4 id="1-1、虚拟内存与-Page-Fault"><a href="#1-1、虚拟内存与-Page-Fault" class="headerlink" title="1.1、虚拟内存与 Page Fault"></a>1.1、虚拟内存与 Page Fault</h4><p>早期计算机中，并没有设计虚拟内存，程序都是直接从磁盘按序完整地加载进物理内存中，这种方式由于使用的是真实物理内存地址且程序是有序加载进去的，那么通过计算地址偏移就可以访问到其他程序的内存，存在安全隐患，另外由于是完整加载，而用户实际使用时只会用到少部分功能，这样也会造成内存的极大浪费。为了解决这些问题，现在的操作系统在物理内存的基础上引入了虚拟内存的概念。虚拟内存引入后，每个进程可以认为自己拥有从0x000000~0xffffff这一大片连续的内存空间，只不过这个内存地址是虚拟的，要访问实际物理内存地址，需要通过操作系统维护的一张映射表映射之后才可以真正访问到，而映射表是以页（Page）为单位进行管理的。<img src="https://img.toutiao.io/c/ee7a6c14a5cf367c4c1bce96efd184a6" alt="img"><br>当进程要访问的一个虚拟内存页在经过映射表映射之后发现对应的物理内存页不存在时，会触发一次缺页中断Page Fault，此时会发生 I&#x2F;O 操作，将磁盘中的数据读入到物理内存页中，读取的过程中苹果还会对读入的内存页进行验签处理，因此如果频繁发生Page Fault的话，Page Fault产生的耗时也不可小觑。Page Fault的数量可以通过 Instruments 自带的 System Trace 工具来查看，其中File Backed Page In就是Page Fault的次数。</p><span id="more"></span><p><img src="https://img.toutiao.io/c/1b05e2ea36008e04ac6ba1b2423cb3b7" alt="img"></p><h4 id="2、二进制重排优化原理"><a href="#2、二进制重排优化原理" class="headerlink" title=".2、二进制重排优化原理"></a>.2、二进制重排优化原理</h4><p>APP 启动过程中，会加载大量的类、执行大量的方法，当频繁触发Page Fault的话，对启动耗时会产生不小的影响，因此尽可能减少Page Fault的数量可以优化启动耗时。当启动过程中需要调用的两个方法method1和method2分布在不同的内存页时，此时操作系统需要触发两次缺页中断Page Fault，来加载这两页到内存，如果通过一定的技术手段将这两个方法排列在同一个内存页中，那此时系统只需要触发一次缺页中断即可，如果能够减少一定数量的缺页中断次数，那也就能够减少整体启动耗时。<img src="https://img.toutiao.io/c/ff9a2758e343f3541552f76bc5ec25b9" alt="img"></p><blockquote><p>因此，二进制重排的一个核心问题就是如何将不同的方法尽可能地排列在同一个内存页中。</p></blockquote><p>生成一个二进制的 Mach-O 文件，需要经过编译、链接的过程，Xcode 使用 ld 作为链接器，ld 链接器的配置中有一个名为Order File的参数，它可以配置一个 order 文件路径。<img src="https://img.toutiao.io/c/5996f96f51f2a5600d75279611255d18" alt="img"><br>一个 order 文件内存储的是符号列表，当我们配置了 order 文件之后，ld 在工作的时候就会根据 order 文件中的符号按照顺序进行排列生成二进制文件。因此，如果我们将启动过程中调用的函数符号都找到，并配置到 order 文件中，那生成的二进制文件在启动时所调用的方法都会尽量排在相同且相邻的内存页上，从而减少启动过程中发生Page Fault的次数，减少因Page Fault而产生的耗时。因此，现在的关键是找到启动过程中调用的函数符号。通过 hook objc_msgSend 能够拿到 OC 方法的调用，但是对于load方法、C++ 构造函数还需要通过扫描 Mach-O 文件来获取，还有一种方案是基于 Clang 编译期插桩来获取符号，Clang 插桩可以一次获取 OC、Swift、C、block 函数符号，因此，我们采用的就是基于 Clang 插桩来实现符号收集。</p><h4 id="1-3、Clang-插桩收集启动过程中的函数符号"><a href="#1-3、Clang-插桩收集启动过程中的函数符号" class="headerlink" title="1.3、Clang 插桩收集启动过程中的函数符号"></a>1.3、Clang 插桩收集启动过程中的函数符号</h4><p>基于 Clang 插桩获取符号有两种实现方式：</p><ul><li>一种是自己编写一个 Clang 插件，在 Clang 插件中我们去分析抽象语法树不同的节点，在相应的节点中插入自定义的代码用于符号收集，这种自定义 Clang 插件的方式优点是可根据自己需求进行灵活处理，缺点是通用性较差，</li><li>一种是利用 SanitizerCoverage 工具进行符号收集。</li></ul><p>SanitizerCoverage 是 LLVM 内置的一个代码覆盖率检测工具，在编译时，它能够根据我们的编译配置，将一系列以__sanitizer_cov_trace_pc_为前缀的函数插入到我们自定义的函数内，比如，我们在Clang的自定义配置 Other C Flags中新增-fsanitize-coverage&#x3D;trace-pc-guard标志时，编译器将会为每个自定义的函数中插入__sanitizer_cov_trace_pc_guard回调函数。</p><blockquote><p>Clang 静态插桩收集符号的原理就是，利用编译期在每一个函数内部插入回调函数__sanitizer_cov_trace_pc_guard，我们通过实现该函数，在运行期间就能够拿到被插入该函数的原函数地址，通过函数地址解析出函数符号，从而达到收集启动过程中函数符号的目的。</p></blockquote><p>因此，为了 Clang 前端能够利用 SanitizerCoverage 插入插桩函数，我们首先需要在Other C Flags 中添加-fsanitize-coverage&#x3D;trace-pc-guard配置，这样在编译后，我们的自定义函数中都会被插入__sanitizer_cov_trace_pc_guard函数，然后我们需要实现该回调函数，并在回调函数内部收集原函数符号：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//插桩的初始化方法，首次会进入到这里面</span><br><span class="hljs-type">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="hljs-type">uint32_t</span> *start, <span class="hljs-type">uint32_t</span> *stop) &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">uint64_t</span> N; <br>  <span class="hljs-keyword">if</span> (start == stop || *start) <span class="hljs-keyword">return</span>; <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> *x = start; x &lt; stop; x++)<br>    *x = ++N; <br>&#125;<br><span class="hljs-comment">//每个原函数内部被插入的回调方法</span><br><span class="hljs-type">void</span> __sanitizer_cov_trace_pc_guard(<span class="hljs-type">uint32_t</span> *guard) &#123;<br>  <span class="hljs-keyword">if</span> (!*guard) <span class="hljs-keyword">return</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>函数__sanitizer_cov_trace_pc_guard是在编译期由 Clang 插入到原函数内部的，因此__sanitizer_cov_trace_pc_guard函数算是原函数内部的一个嵌套子函数，而操作系统在执行 bl 跳转指令的时候，会先保存下一条指令地址到lr寄存器中，当__sanitizer_cov_trace_pc_guard函数执行完即执行ret指令后，需要继续回到原函数中继续执行，操作系统会去读取 LR 寄存器中的值拿到原函数的下一条待执行指令地址，这个地址可以通过下面代码来获取：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void *PC <span class="hljs-operator">=</span> __builtin_return_address(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>也就是说，在__sanitizer_cov_trace_pc_guard函数中我们可以通过 __builtin_return_address(0) 拿到原函数某条指令的地址，那我们只要再通过 dladdr() 函数就可以获取到原函数的信息，从而拿到该函数符号。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl">void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;<br>    <span class="hljs-keyword">if</span> (!*guard) <span class="hljs-keyword">return</span>; <br><br>    void *PC = __builtin_return_address(<span class="hljs-number">0</span>);<br>    Dl_info info;<br>    dladdr(PC, &amp;info);<br><br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;fname=%s \nfbase=%p \nsname=%s\nsaddr=%p \n&quot;</span>,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);<br><br>    char PcDescr[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;guard: %p %x PC %s\n&quot;</span>, guard, *guard, PcDescr);<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际的使用过程中，需要解决以下几个主要问题：</p><ol><li>多线程问题，由于__sanitizer_cov_trace_pc_guard函数是各个方法内插入的回调函数，而原函数可能处于不同的线程中，从而造成__sanitizer_cov_trace_pc_guard函数调用的多线程问题，解决这个问题可以使用原子队列 OSAtomicEnqueue 来处理，使用原子队列之后需要在 Other C Flags 配置中修改原来的配置为如下形式：</li></ol><blockquote><p>-fsanitize-coverage&#x3D;func,trace-pc-guard</p></blockquote><ol><li>如果要支持 Swift 符号收集，由于 Swift 的编译前端与 OC 不同，需要在编译配置的Other Swift Flags下，新增下面配置：</li></ol><blockquote><p>-sanitize-coverage&#x3D;func<br>-sanitize&#x3D;undefined</p></blockquote><ol><li>使用 Cocoapods 管理的项目，存在多 target 的情况下，需要在每个 target 下都要进行上面的Other C Flags配置。</li></ol><p>收集到启动过程中的函数符号之后，将这些符号写入到 order 文件中，并将该 order 文件的地址在 Xcode 的Order File参数下进行配置即可。</p><h3 id="具体实施总结"><a href="#具体实施总结" class="headerlink" title="具体实施总结"></a>具体实施总结</h3><h3 id="步骤一：添加-Build-Setting-设置"><a href="#步骤一：添加-Build-Setting-设置" class="headerlink" title="步骤一：添加 Build Setting 设置"></a>步骤一：添加 Build Setting 设置</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">T<span class="hljs-function"><span class="hljs-title">arget</span> -&gt;</span> B<span class="hljs-function"><span class="hljs-title">uild</span> Setting -&gt;</span> C<span class="hljs-function"><span class="hljs-title">ustom</span> Complier Flags -&gt;</span><br></code></pre></td></tr></table></figure><p><code>Other C Flags</code> 添加</p><ul><li><code>-fsanitize-coverage=func,trace-pc-guard</code></li></ul><p><code>Other Swift Flags</code> 添加</p><ul><li><code>-sanitize-coverage=func</code></li><li><code>-sanitize=undefined</code></li></ul><h3 id="步骤二：添加代码"><a href="#步骤二：添加代码" class="headerlink" title="步骤二：添加代码"></a>步骤二：添加代码</h3><p>添加到启动最早的那个 <code>ViewController</code> 即可。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;dlfcn.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;libkern/OSAtomic.h&gt;</span></span><br>复制代码<br><span class="hljs-type">void</span> __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) &#123;<br>     <span class="hljs-keyword">static</span> uint64_t N;  <span class="hljs-comment">// Counter for the guards.</span><br>     <span class="hljs-keyword">if</span> (start == stop || *start) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Initialize only once.</span><br>     printf(<span class="hljs-string">&quot;INIT: %p %p\n&quot;</span>, start, stop);<br>     <span class="hljs-keyword">for</span> (uint32_t *x = start; x &lt; stop; x++)<br>       *x = ++N;  <span class="hljs-comment">// Guards should start from 1.</span><br>&#125;<br><br><br><span class="hljs-comment">//初始化原子队列</span><br><span class="hljs-keyword">static</span> OSQueueHead list = OS_ATOMIC_QUEUE_INIT;<br><span class="hljs-comment">//定义节点结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">void</span> *pc;   <span class="hljs-comment">//存下获取到的PC</span><br>    <span class="hljs-type">void</span> *next; <span class="hljs-comment">//指向下一个节点</span><br>&#125; Node;<br><br><br><span class="hljs-type">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;<br>     <span class="hljs-type">void</span> *PC = __builtin_return_address(<span class="hljs-number">0</span>);<br>     Node *node = malloc(<span class="hljs-keyword">sizeof</span>(Node));<br>     *node = (Node)&#123;PC, <span class="hljs-literal">NULL</span>&#125;;<br>     <span class="hljs-comment">// offsetof() 计算出列尾，OSAtomicEnqueue() 把 node 加入 list 尾巴</span><br>     OSAtomicEnqueue(&amp;list, node, offsetof(Node, next));<br>&#125;<br><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>     <span class="hljs-built_in">NSMutableArray</span> *arr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>     <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>         <span class="hljs-comment">//有进就有出，这个方法和 OSAtomicEnqueue() 类比使用</span><br>         Node *node = OSAtomicDequeue(&amp;list, offsetof(Node, next));<br>         <span class="hljs-comment">//退出机制</span><br>         <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>         <span class="hljs-comment">//获取函数信息</span><br>         Dl_info info;<br>         dladdr(node-&gt;pc, &amp;info);<br>         <span class="hljs-built_in">NSString</span> *sname = [<span class="hljs-built_in">NSString</span> stringWithCString:info.dli_sname encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>         printf(<span class="hljs-string">&quot;%s \n&quot;</span>, info.dli_sname);<br>         <span class="hljs-comment">//处理c函数及block前缀</span><br>         <span class="hljs-type">BOOL</span> isObjc = [sname hasPrefix:<span class="hljs-string">@&quot;+[&quot;</span>] || [sname hasPrefix:<span class="hljs-string">@&quot;-[&quot;</span>];<br>         <span class="hljs-comment">//c函数及block需要在开头添加下划线</span><br>         sname = isObjc ? sname: [<span class="hljs-string">@&quot;_&quot;</span> stringByAppendingString:sname];<br>         <br>         <span class="hljs-comment">//去重</span><br>         <span class="hljs-keyword">if</span> (![arr containsObject:sname]) &#123;<br>             <span class="hljs-comment">//因为入栈的时候是从上至下，取出的时候方向是从下至上，那么就需要倒序，直接插在数组头部即可</span><br>             [arr insertObject:sname atIndex:<span class="hljs-number">0</span>];<br>         &#125;<br>     &#125;<br>       <br>     <span class="hljs-comment">//去掉 touchesBegan 方法 启动的时候不会用到这个</span><br>     [arr removeObject:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%s&quot;</span>,__FUNCTION__]];<br>     <span class="hljs-comment">//数组合成字符串</span><br>     <span class="hljs-built_in">NSString</span> * funcStr = [arr  componentsJoinedByString:<span class="hljs-string">@&quot;\n&quot;</span>];<br>     <span class="hljs-comment">//写入文件</span><br>     <span class="hljs-built_in">NSString</span> * filePath = [<span class="hljs-built_in">NSTemporaryDirectory</span>() stringByAppendingPathComponent:<span class="hljs-string">@&quot;link.order&quot;</span>];<br>     <span class="hljs-built_in">NSData</span> * fileContents = [funcStr dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, filePath);<br>     [[<span class="hljs-built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:fileContents attributes:<span class="hljs-literal">nil</span>];<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><h3 id="步骤三：取出-order-file"><a href="#步骤三：取出-order-file" class="headerlink" title="步骤三：取出 order file"></a>步骤三：取出 order file</h3><ul><li>在步骤二的代码<code>NSLog(@&quot;%@&quot;, filePath);</code> 断点</li><li>如果页面无法触发点击，<code>viewDidLoad</code>里面调用<code>touchesBegan:withEvent:</code>也可以</li><li>运行代码后记录 <code>link.order</code> 的路径</li><li><code>Finder</code> 前往路径取出 <code>order file</code></li></ul><h3 id="步骤四：设置-order-file"><a href="#步骤四：设置-order-file" class="headerlink" title="步骤四：设置 order file"></a>步骤四：设置 order file</h3><ul><li>把 <code>link.order</code> 的路径放到工程根目录</li><li><code>Target -&gt; Build Setting -&gt; Linking -&gt; Order File</code> 设置路径</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/29/1725ec47fac2115a~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="步骤五：编译代码"><a href="#步骤五：编译代码" class="headerlink" title="步骤五：编译代码"></a>步骤五：编译代码</h3><ul><li>把步骤一 <code>order file</code> 的设置还原</li><li>把步骤二添加代码删除</li><li><code>clean</code> 以后编译代码</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>离线化</title>
    <link href="/2021/03/10/%E7%A6%BB%E7%BA%BF%E5%8C%96/"/>
    <url>/2021/03/10/%E7%A6%BB%E7%BA%BF%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1、方案比较"><a href="#1、方案比较" class="headerlink" title="1、方案比较"></a>1、方案比较</h3><p>H5离线包的基本原理是将html、js、css、图片等静态资源打包成压缩包，然后下载到客户端并解压，H5加载时直接从本地读取静态资源文件，减少网络请求，提高速度.</p><table><thead><tr><th>方案名</th><th>优点</th><th>缺点</th><th>备注</th></tr></thead><tbody><tr><td>加载本地路径</td><td>简单可靠，无需hook和调用私有API</td><td>有跨域问题，影响cookie和localstorage，H5需做少量改动</td><td></td></tr><tr><td>请求拦截</td><td>不修改加载URL，没有跨域问题，且支持网页部分资源离线化，灵活性和兼容性好</td><td>iOS端目前提供的NSURLProtocol和WKURLSchemehandler拦截方案，需要hook和调用私有API，来注册拦截。post请求体丢失</td><td></td></tr><tr><td>本地Web Server</td><td>兼容性好</td><td>对客户端耗电和CPU性能有影响</td><td></td></tr><tr><td>Service Worker</td><td>前端兼容性好</td><td>iOS端WKWebView不提供官方支持，实现技术难度大</td><td></td></tr></tbody></table><p>腾讯开源了离线包方案VasSonic（[github.com&#x2F;Tencent&#x2F;Vas…]</p><span id="more"></span><p><code>NSURLProtocol</code> 默认会拦截所有经过 URL Loading System 的请求,<code>WKWebView</code> 独立于应用进程运行，发出去的请求默认是不会经过 URL Loading System</p><p><code>WKURLSchemeHandler</code> 是 iOS 11 引入的新特性，负责自定义请求的数据管理，如果需要支持 scheme 为 http 或 https请求的数据管理则需要 hook <code>WKWebView</code> 的 <code>handlesURLScheme</code>: 方法，然后返回NO即可</p><h3 id="2、请求拦截"><a href="#2、请求拦截" class="headerlink" title="2、请求拦截"></a>2、请求拦截</h3><ul><li>关于私有API，对需要拦截的协议进行注册</li><li><strong>对拦截的 WKWebView</strong> 请求做处理，不仅接管请求还要将请求结果通过NSURLProtocolClient返还给__WKWebView__，</li></ul><p>因为WKBrowsingContextController和registerSchemeForCustomProtocol应该是私有的所以使用时候需要对字符串做下处理，用加密的方式或者其他就可以了，实测可以过审核的。</p><pre><code class="hljs">//注册自己的protocol[NSURLProtocol registerClass:[CustomProtocol class]];//创建WKWebviewWKWebViewConfiguration * config = [[WKWebViewConfiguration alloc] init];WKWebView * wkWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height) configuration:config];[wkWebView loadRequest:webViewReq];[self.view addSubview:wkWebView];//注册schemeClass cls = NSClassFromString(@&quot;WKBrowsingContextController&quot;);SEL sel = NSSelectorFromString(@&quot;registerSchemeForCustomProtocol:&quot;);if ([cls respondsToSelector:sel]) &#123;    // 通过http和https的请求，同理可通过其他的Scheme 但是要满足ULR Loading System    [cls performSelector:sel withObject:@&quot;http&quot;];    [cls performSelector:sel withObject:@&quot;https&quot;];&#125;</code></pre><ul><li><p>&#x2F;&#x2F; 所有的请求都会先进入到这里，如果希望拦截下来自己处理，那么就返回YES，否则就返回NO</p><p> + (BOOL)canInitWithRequest:(NSMutableURLRequest *)request {</p></li><li><p>关于post请求<br> 大家会发现拦截不了post请求(拦截到的post请求body体为空)，这个其实和WKWebview没有关系，这个是苹果为了提高效率加快流畅度所以在NSURLProtocol拦截之后索性就不复制body体内的东西，因为body的大小没有限制，开发者可能会把很大的数据放进去那就不好办了。我们可以采取httpbodystream的方式拿到body，这个在<a href="https://www.jianshu.com/p/cd4c1bf1fd5f">文章</a></p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark 处理POST请求相关POST  用HTTPBodyStream来处理BODY体</span><br>- (<span class="hljs-built_in">NSMutableURLRequest</span> *)handlePostRequestBodyWithRequest:(<span class="hljs-built_in">NSMutableURLRequest</span> *)request &#123;<br>    <span class="hljs-built_in">NSMutableURLRequest</span> * req = [request mutableCopy];<br>    <span class="hljs-keyword">if</span> ([request.HTTPMethod isEqualToString:<span class="hljs-string">@&quot;POST&quot;</span>]) &#123;<br>        <span class="hljs-keyword">if</span> (!request.HTTPBody) &#123;<br>            uint8_t d[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">NSInputStream</span> *stream = request.HTTPBodyStream;<br>            <span class="hljs-built_in">NSMutableData</span> *data = [[<span class="hljs-built_in">NSMutableData</span> alloc] init];<br>            [stream open];<br>            <span class="hljs-keyword">while</span> ([stream hasBytesAvailable]) &#123;<br>                <span class="hljs-built_in">NSInteger</span> len = [stream read:d maxLength:<span class="hljs-number">1024</span>];<br>                <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span> &amp;&amp; stream.streamError == <span class="hljs-literal">nil</span>) &#123;<br>                    [data appendBytes:(<span class="hljs-type">void</span> *)d length:len];<br>                &#125;<br>            &#125;<br>            req.HTTPBody = [data <span class="hljs-keyword">copy</span>];<br>            [stream close];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> req;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-更新"><a href="#2-1-更新" class="headerlink" title="2.1 更新"></a>2.1 更新</h4><p>H5离线包和线上H5类似也能进行更新和升级，有三个更新时机：</p><p>1）webview容器打开时更新。开启离线包功能的H5页面每次打开时，会去检查对应的离线包是否有更新。如果有更新，则下载离线包到本地，绝大部分场景是下次打开时生效。</p><p>2）启动查询离线包更新。对于实时性要求比较高的页面，可配置在启动时更新离线包。</p><p>3）长连接推送实时更新。更新实时性要求极高的场景使用。</p><h3 id="2-2-架构改进"><a href="#2-2-架构改进" class="headerlink" title="2.2 架构改进"></a>2.2 架构改进</h3><p>之前webview容器采用的是两层结构，每个业务方从基础WebVC派生出自己的业务WebVC容器。</p><p>现在中间插入一层独立的离线化webView，继承至基础webview。再派生业务层webview。</p><h3 id="2-3-查询并行化"><a href="#2-3-查询并行化" class="headerlink" title="2.3 查询并行化"></a>2.3 查询并行化</h3><p>目前已有多个H5页面采用离线包，为了提高查询效率，多个业务离线包检查的请求采取并行请求的方式。由于HTTP2支持多路复用，所以查询时共用一个NSURLSession对象，多次查询操作自动复用一个TCP连接，减少建立连接次数</p><h3 id="2-4-下载任务去重"><a href="#2-4-下载任务去重" class="headerlink" title="2.4 下载任务去重"></a>2.4 下载任务去重</h3><p>下载过程也是并行进行，可同时下载多个离线包。由于查询操作有多个触发时机，存在重复下载的情况。为了节省流量，采用下载URL作为key，不重复下载正在下载或已下载的文件</p><h3 id="2-5-启动预下载"><a href="#2-5-启动预下载" class="headerlink" title="2.5 启动预下载"></a>2.5 启动预下载</h3><p>大部分离线包查询和下载的时机为打开H5页面时，由于离线包查询、下载、解压总体耗时超过1秒，导致首次打开无法命中离线包。所以离线包支持配置部分离线包在启动时检查和下载离线包，提升首次打开H5页面离线包命中率。配置json格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;predownloadlist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-comment">//选填。需要启动就下载的离线包列表清单</span><br>    <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;test-offline&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-6-解压异步化和串行化"><a href="#2-6-解压异步化和串行化" class="headerlink" title="2.6 解压异步化和串行化"></a>2.6 <strong>解压异步化和串行化</strong></h3><p>解压过程是CPU和IO密集型操作，放在子线程中处理，有多个文件需要解压时，采用串行队列的方式，一次只解压一个文件，避免同时解压多个文件影响客户端性能。</p><h3 id="2-7-降级策略"><a href="#2-7-降级策略" class="headerlink" title="2.7 降级策略"></a>2.7 <strong>降级策略</strong></h3><p>客户端自动降级。本地没有离线包时，客户端会自动将启用离线包的H5页面降级为线上H5页面。</p><p>远程配置降级。可以设置局部降级，即临时将某个使用离线包的H5页面降级为线上，也可设置全局降级，关闭所有页面的离线包功能。配置json为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;switch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//总开关，1开启，0关闭</span><br>    <span class="hljs-attr">&quot;disablelist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-comment">//选填，配置禁用某个离线包</span><br>     <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;act-test&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>服务端接口降级。 服务端提供的离线包查询接口可设置将某个页面降级为线上H5，亦可配置客户端更新离线包后强制刷新</p><h3 id="2-8-性能监控"><a href="#2-8-性能监控" class="headerlink" title="2.8 性能监控"></a>2.8 性能监控</h3><p>对webview的加载成功率，错误码、耗时进行了统计上报，通过监控面板查看。</p><h3 id="2-9-离线包和URL映射配置化"><a href="#2-9-离线包和URL映射配置化" class="headerlink" title="2.9 离线包和URL映射配置化"></a>2.9 离线包和URL映射配置化</h3><p>客户端webview通过URL是否有offweb参数判断该页面走线上请求还是加载本地离线包。URL来源广泛，有客户端硬编码、运营系统下发、JS action调用多种来源，手动修改URL效率太低，因此通过远程配置，自动给指定URL添加离线包参数并命中对应的H5离线包。</p><p>配置json格式如下：主要通过host，path配置匹配规则。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;rules&quot;</span> <span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span> <span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;test1.zzz.cn&quot;</span> <span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;test2.zzz.cn&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;path&quot;</span> <span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;/testapp&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;offweb&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test-offline1&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span> <span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;test3.xxx.cn&quot;</span> <span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;test4.xxx.cn&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;path&quot;</span> <span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;test/offweb&quot;</span> <span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;test/abc&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;offweb&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test-offline2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-10-解压操作可靠性设计"><a href="#2-10-解压操作可靠性设计" class="headerlink" title="2.10 解压操作可靠性设计"></a>2.10 解压操作可靠性设计</h3><p>文件解压耗时较长（大约30ms），如果程序异常退出可能会出现解压操作完成一半的情况，影响后续离线包功能。所以文件解压操作采取先解压，然后重命名，保证最后得到的文件完整性。同时当离线包正在使用时，一般情况下采取先解压，下次生效的策略，极端情况下立刻生效，但会导致页面强刷，影响用户体验，使用较少。离线包存放时使用tmp、new、cur三个文件夹，不采用版本号命名，简化离线包缓存管理逻辑</p><h3 id="加载速度提升"><a href="#加载速度提升" class="headerlink" title="加载速度提升"></a>加载速度提升</h3><p>改造完成的H5页面，平均加载速度从2s提升至1s</p><h3 id="加载成功率提升"><a href="#加载成功率提升" class="headerlink" title="加载成功率提升"></a>加载成功率提升</h3><p>页面主框架（不考虑动态数据）加载成功率从96%提升到100%。</p><h2 id="3-下载解压"><a href="#3-下载解压" class="headerlink" title="3 下载解压"></a>3 下载解压</h2><p>异步串行队列中解压，防止多个任务对cpu负载太大，影响页面展示</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//开始下载当前离线包</span><br>[downloadManager download:curOfflineModel.updatePackageUrl progress:^(<span class="hljs-built_in">NSInteger</span> thisTimeWrittenSize, <span class="hljs-built_in">NSInteger</span> totlalReceivedSize, <span class="hljs-built_in">NSInteger</span> TotalExpectedSize) &#123;<br><br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：离线包大小 %ld 已下载数进度：%.2f&quot;</span>,TotalExpectedSize,totlalReceivedSize*<span class="hljs-number">1.0</span>/TotalExpectedSize*<span class="hljs-number">1.0</span>);<br>  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>  [WMHUDUntil showMessageToWindow:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;已下载数进度：%.2f%%&quot;</span>,totlalReceivedSize*<span class="hljs-number">1.0</span>/TotalExpectedSize*<span class="hljs-number">1.0</span> * <span class="hljs-number">100</span>]];<br>                        &#125;);<br>                         <br>  <span class="hljs-keyword">if</span> (totlalReceivedSize*<span class="hljs-number">1.0</span>/TotalExpectedSize*<span class="hljs-number">1.0</span>==<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：下载完成=====！！！&quot;</span>);<br>  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>            [WMHUDUntil showMessageToWindow:<span class="hljs-string">@&quot;下载完成=====！！！&quot;</span>];<br>  &#125;);<br>                            <br>    <span class="hljs-comment">//子线程进行解压</span><br>     <span class="hljs-built_in">dispatch_queue_t</span> zipQueue = <br>     dispatch_queue_create(<span class="hljs-string">&quot;zipQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_async</span>(zipQueue, ^&#123;<br>    [<span class="hljs-keyword">self</span> mergeZipAndUnZipFileIsPatch:curOfflineModel.isPatch];<br>      &#125;);<br>    &#125;<br>  &#125; state:^(WMDownloadState state, <span class="hljs-built_in">NSString</span> * _Nullable filePath, <span class="hljs-built_in">NSError</span> * _Nullable error) &#123;<br>                     <br>&#125;];<br></code></pre></td></tr></table></figure><h3 id="4-1-合并"><a href="#4-1-合并" class="headerlink" title="4.1 合并"></a>4.1 合并</h3><p>按照我们的需求内容我们下载的内容分为差分包或全量包，和服务约定本地有版本并且与最新版本3个以内下载差分包否者下载全量包。</p><p>既然下载的差分包的话就需要与之前的离线包合并，我们这边使用的bsdiff工具。这个工具需要三端统一使用，保证规则一致。</p><h6 id="bsdiff简单介绍"><a href="#bsdiff简单介绍" class="headerlink" title="bsdiff简单介绍"></a>bsdiff简单介绍</h6><p>bsdiff是一种二级制差分工具，由b sdiff与bspatch组成， 将oldfile与newfile做二进制数据差分（bsdiff操作），得到更新的部分（patch文件），再与oldfile进行合成（bspatch操作）。</p><h3 id="5-1-解压"><a href="#5-1-解压" class="headerlink" title="5.1 解压"></a>5.1 解压</h3><p>解压工具也是直接使用目前github上最为常用的<a href="https://links.jianshu.com/go?to=%5Bhttps://github.com/ZipArchive/ZipArchive%5D(https://github.com/ZipArchive/ZipArchive)">SSZipArchive</a>使用起来也是非常的简单</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：----- 解压开始 ------&quot;</span>);<br>[SSZipArchive unzipFileAtPath:fromPath toDestination:destinationPath progressHandler:^(<span class="hljs-built_in">NSString</span> * _Nonnull entry, unz_file_info zipInfo, <span class="hljs-type">long</span> entryNumber, <span class="hljs-type">long</span> total) &#123;<br>    <br>&#125; completionHandler:^(<span class="hljs-built_in">NSString</span> * _Nonnull path, <span class="hljs-type">BOOL</span> succeeded, <span class="hljs-built_in">NSError</span> * _Nullable error) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：path = %@,succeeded = %d&quot;</span>,path,succeeded);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：----- 解压完成 ------&quot;</span>);<br>    <span class="hljs-keyword">if</span> (succeeded) &#123;<br>        <span class="hljs-built_in">NSArray</span> *pathArray = [<span class="hljs-keyword">self</span> getContentsOfDirectoryAtPath:destinationPath];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：解压成功 %@&quot;</span>,pathArray);<br>        [WMOfflineH5Cache setDiskOfflineModel:curOfflineModel];<br>        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>            [WMHUDUntil showMessageToWindow:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;解压成功  \n 本地文件 %@&quot;</span>,pathArray]];<br>        &#125;);            <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        [<span class="hljs-keyword">self</span> renameWithPath:fromPath];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;🎋离线：解压失败 error = %@&quot;</span>,error);<br>        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>            [WMHUDUntil showMessageToWindow:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;解压失败&quot;</span>]];<br>        &#125;);            <br>    &#125;<br>&#125;];<br></code></pre></td></tr></table></figure><p>跨域源于浏览器的同源策略，指的是两个请求接口URL的协议(protocol)、域名(host)和端口(port)一致</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>打包问题记录</title>
    <link href="/2021/03/07/%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/03/07/%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="通过jenkins打包ipa包报错：Command-CodeSign-failed-with-a-nonzero-exit-code（errSecInternalComponent）"><a href="#通过jenkins打包ipa包报错：Command-CodeSign-failed-with-a-nonzero-exit-code（errSecInternalComponent）" class="headerlink" title="通过jenkins打包ipa包报错：Command CodeSign failed with a nonzero exit code（errSecInternalComponent）"></a>通过jenkins打包ipa包报错：Command CodeSign failed with a nonzero exit code（errSecInternalComponent）</h1><p><strong>描述 ：</strong></p><p>在打包机通过 xcode打包不报错</p><p>在打包机直接运行打包shell不报错</p><p>但是通过jenkin打包就会出现下面的错误 ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">KitExtension.appex<br><span class="hljs-regexp">/Users/</span><span class="hljs-number">5</span>i5j<span class="hljs-regexp">/Library/</span>Developer<span class="hljs-regexp">/Xcode/</span>DerivedData<span class="hljs-regexp">/cbs_new5iwork-ebjitbdetyopmbadzpizhbztfpyw/</span>Build<span class="hljs-regexp">/Intermediates.noindex/</span>ArchiveIntermediates<span class="hljs-regexp">/cbs_new5iwork/</span>IntermediateBuildFilesPath<span class="hljs-regexp">/UninstalledProducts/i</span>phoneos/CallKitExtension.appex: errSecInternalComponent<br>Command CodeSign failed with a nonzero <span class="hljs-keyword">exit</span> code<br></code></pre></td></tr></table></figure><p>出现这个问题的主要原因是是Jenkins，以ssh方式到slave机上，默认是没有账户的，但是访问钥匙串要求必须有用户身份</p><p>（回忆了一下自己通过Xcode打包的过程中，的确是要求输入过登录密码，之后才打包成功的。没想到通过xcode打包成功之后，再使用shell脚本直接打包，也还需要输入登录密码才能打包成功）</p><p><strong>解决办法</strong></p><p>添加一步输入密码解锁钥匙串，可以给Jenkins一个用户身份。 build步骤前添加一步解锁钥匙串。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">security unlock-keychain -p <span class="hljs-string">&quot;login pwd&quot;</span> ~<span class="hljs-regexp">/Library/</span>Keychains/login.keychain<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>弱网优化</title>
    <link href="/2020/12/28/%E5%BC%B1%E7%BD%91%E4%BC%98%E5%8C%96/"/>
    <url>/2020/12/28/%E5%BC%B1%E7%BD%91%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>1、DNS优化 【核心解决安全问题】</p><p>DNS（Domain Name System），它的作用是根据域名查出IP地址</p><p><strong>核心问题</strong></p><ul><li><p>1）由于DNS劫持或故障造成的服务不可用</p></li><li><p>2）由于DNS调度不准确导致的性能退化</p></li><li><p>防止DNS的劫持，Eg：OS劫持率由0.12%降低到0.0002%，Android劫持率由0.25%降低到0.05%</p></li><li><p>降低网络时延，在调度不准确的情况下，会增大网络的时延，降低用户的体验</p></li></ul><p>2、<strong>连接优化</strong></p><ul><li>降低延迟</li><li>提升成功率</li></ul><p>3、<strong>弱网优化</strong> </p><ul><li><p>问题点1：移动网络环境如此复杂，我们如何确定当下就是弱网环境</p><p>问题点2: 确定为弱网环境下，我们如何提升弱网下的成功率，降低弱网下的时延，进而提升用户的网络体验</p><span id="more"></span><p><strong>线下进行测试获取阈值：</strong>获取一些符合我们预期的阈值，这个时候我们需要借助一些网络测试工具，比如苹果的Network Link Conditioner，Facebook的ATC（Augmented Traffic Control），来获取到线下不同网络情况的阈值，一般我们会测试App冷启动的场景，网络切换的场景，DNS故障场景，弱网场景（一般都是配置上下行的带宽，丢包率，延迟，DNS延迟参数，或者更为简单的是使用工具默认的一些弱网配置）</p><p>*<em>解决方案</em>***：</p><p>主动网络探测：就是触发某些条件后，主动的进行网络探测，并按照一定的条件检测出是否弱网状态</p><p>大概逻辑步骤</p><p>①　网络请求成功时，如何进入弱网状态？检查weakhttprtt的阀值（eg：95分位）大于这个值就会进入弱网检测，为了防止频繁触发探测加了时间间隔维度（eg：10分钟）</p><p>②　网络请求成功时，如何退出弱网状态？检查goodhttprtt的阀值（一般这个值会取整体网络的95分位或者更大分位的值），小于这个值证明要切换回正常网络状态，为了防止频繁触发探测加了时间间隔的限制30秒，还加入了次数的限制，连续成功次数%次数阈值（4次）等于0。但这看起来还是频次有点高，所以我们引入了阶梯递增机制，随着次数的增长，成60秒几何倍数增长。</p><p>线下模拟测试得出：只要小于这个阀值，检测结果必然是正常状态，如果大于或者等于这个阀值，不能证明一定不是正常网络，所以需发起网络探测（成功回调里，加上时间间隔30秒，还加入阶梯次数限制）</p><p>③　网络请求失败时，如何判断进入弱网状态？首先会判断连 续失败次数。连续失败次数&#x2F;次数阈值（2次）等于1并且连续失败次数%次数阈值（2次）等于0</p><p>探测基础能力层，主要提供弱网检测的手段，一是dns query，一是ping</p><p>一个网络请求，分为<em>DNS-&gt;TLS-&gt;TCP-&gt;数据传输</em> 四个阶段。想判定网络连通性主要在DNS和TCP阶段，所以dns query和ping就是用来检测这两个阶段的连通性手段。dns query向百度核心域名mbd.baidu.com发起dns查询，查询的DNS服务器为系统配置的DNS服务器(iOS通过res_ninit函数构建一个__res_state的结构体，Android通过systemproperty获取net.dns1和net.dns2的值，便可获取系统配置的DNS服务器)，DNS查询的超时时间为<strong>3s</strong>。ping的次数为<strong>两次</strong>，每次超时时间是默认的<strong>1s</strong>。</p><p>被动网络采集：每一次网络请求的所有细节都进行记录，并按照一定的条件将信息进行上报，上层根据条件判断是否是弱网状态。</p><p><strong>优化收益：</strong></p><p>1.弱网开启QUIC后，网络连接成功率提升，平均耗时降低</p><p>2.弱网开启QUIC预连接后，QUIC协议的pv从XX涨到XX</p><p>3.弱网开启复合连接后，bad状态下耗时降低XX%，offline状态下耗时降低XX%</p></li></ul><h3 id="四、弱网优化之性能优化"><a href="#四、弱网优化之性能优化" class="headerlink" title="四、弱网优化之性能优化"></a>四、<strong>弱网优化之性能优化</strong></h3><p>1.网络状态设置：无网络提示</p><p>2.设定不同网络状态下的超时时间</p><p>3.多子模块请求的“延迟性”</p><p>对一次请求所有接口数据页面，可以进行分段“延迟”请求</p><p>优先模块：数据量少，业务上优先显示</p><p>延迟模块：数据量大，延迟加载处理等</p><p>4.固定模块加入缓存机制、或增量更新机制</p><p>有些页面数据进行数据缓存处理，一定有效时间内再次请求可直接从缓存读取，可避免空白页影响体验</p><p>5、前后端采用gzip方式请求和响应,数据压缩和解压, 请求header添加：”content-encoding” 为 “gzip”</p><p>QUIC:Quick UDP Internet Connections</p><p><strong>QUIC 与现有 TCP + TLS + HTTP&#x2F;2 方案相比，有以下几点主要特征：</strong></p><p>QUIC 协议的主要目的，是为了整合 TCP 协议的可靠性和 UDP 协议的速度和效率。</p><ul><li>1）利用缓存，显著减少连接建立时间；</li></ul><p>2）改善拥塞控制，拥塞控制从内核空间到用户空间；</p><ul><li>3）没有 head of line 阻塞的多路复用；</li><li>4）前向纠错，减少重传；</li><li>5）连接平滑迁移，网络状态的变更不会影响连接断线。</li></ul><p><strong>QUIC 协议非常复杂，因为它做了太多事情：</strong></p><ul><li>为了实现传输的可靠性，它基本上实现并且改进了整个 TCP 协议的功能，包括序列号，重传，拥塞控制，流量控制等；</li><li>为了实现传输的安全性，它又彻底重构了 TLS 协议，包括证书压缩，握手消息，0RTT 等。虽然后续可能会采用 TLS1.3 协议，但是事实上是 QUIC 推动了 TLS1.3 的发展；</li><li>为了实现传输的并发性，它又实现了 HTTP2 的大部分特性，包括多路复用，流量控制等。</li></ul><h2 id="五、TLS的连接优化"><a href="#五、TLS的连接优化" class="headerlink" title="五、TLS的连接优化"></a>五、TLS的连接优化</h2><p>连接优化的收益主要体现在<strong>网络时延</strong>和<strong>网络成功率</strong>上</p><p>![image-20220802170956904](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220802170956904.png)</p><p><strong>1）Session Identifier：</strong><br>Session Identifier中文为会话标识符，更像我们熟知的session的概念。是 TLS 握手中生成的 Session ID。服务端会将Session ID保存起来，客户端也会存储Session ID，在后续的ClientHello中带上它，服务端如果能找到匹配的信息，就可以完成一次快速握手。</p><p><strong>2）Session Ticket：</strong><br>Session Identifier存在一些弊端，比如客户端多次请求如果没有落在同一台机器上就无法找到匹配的信息，但Session Ticket可以。Session Ticket更像我们熟知的cookie的概念，Session Ticket用只有服务端知道的安全密钥加密过的会话信息，保存在客户端上。客户端在ClientHello时带上了Session Ticket，服务器如果能成功解密就可以完成快速握手。</p><h3 id="2、False-Start"><a href="#2、False-Start" class="headerlink" title="2、False Start"></a>2、False Start</h3><p>不管是Session Identifier还是Session Ticket都存在时效性问题，不是永久生效</p><p>![image-20220802171249443](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220802171249443.png)</p><p>上图很清晰的说明在TLS第一步握手成功后，客户端在发送Change Cipher Spec Finished的同时开始数据传输，服务端在TLS握手完成时直接返回应用数据。应用数据的发送实际上并未等到握手全部完成，所以称之为抢跑。</p><p><strong>从结果看省去了1个RTT的时间。False Start有两个前提条件：</strong></p><ul><li>一是要通过应用层协议协商ALPN（Application Layer Protocol Negotiation）握手；</li><li>二是要支持前向安全的加密算法。</li></ul><h3 id="3、预连接"><a href="#3、预连接" class="headerlink" title="3、预连接"></a>3、预连接</h3><p><strong>预连接：</strong>预先创建好的连接。它解决的场景是在App使用阶段可以无耗时的获取连接。下面用四个问答来解释预连接。</p><p>*<strong>问题一：预连接是否能解决所有网络请求的提前连接建立？*</strong></p><p><strong>答：</strong>答案是否定的，预连接需要业务方进行核心业务的评估，针对核心的域名进行预连接的建立。</p><p>*<strong>问题二：预连接既然针对的是特定的域名，那么是如何配置的呢？*</strong></p><p><strong>答：</strong>采用域名+连接数的方式进行配置，比如<a href="https://a.baidu.com/">https://a.api.com</a>|2，表示给a.api.com这个域名配置两条预连接，这里要说明下，在HTTP&#x2F;1.x协议下，网络库的实现都会对于单域名有最大连接数的限制，不同网络库的个数限制不一样，有5个也有6个，但对于HTTP&#x2F;2协议，这个连接数就只能是1个</p><p>*<strong>预连接是如何建立的？*</strong></p><p><strong>答：</strong>在网络库初始化的时候，会根据使用者的配置延迟5s进行预连接的建立，主要是考虑网络库在冷启动下对于启动性能的影响，为了保证网络库的整体性能，预连接的总个数限制在20个。</p><p>*<strong>问题四：预连接是如何保持的？*</strong></p><p><strong>答：</strong>在网络库初始化的时候，除了进行预连接的建立，还会创建一个预连接的定时器，这个定时器会每隔31s重新建立连接</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>纯网络层面的优化如使用QUIC协议、请求预建链和精简字段等</p><p>有三重奏来对数据进行分析的，一，线下数据的采集和分析，得出正向收益，二，灰度数据的采集和分析，得出正向收益，三，线上数据的采集和分析，得出正向收益。</p><p>对于客户端同学，我们在PC上要学会使用tcpdump和Wireshark等工具，适当使用Fiddler和Charles等工具，很多时候电脑和手机的网络环境不见得一致，所以要在手机上使用iNetTools，Ping&amp;DNS或终端工具。学会使用工具后，要学着创造不同的网络环境，有很多工具能帮助你完成这点，比如苹果的Network Link Conditioner，FaceBook的ATC（Augmented Traffic Control）等。具备以上两个场景后，你的第一条储备就发挥了作用，你要能看懂握手过程，传输过程，异常断开过程等。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h3><p><strong>1）httprtt：</strong><br>httprtt（http Round-Trip Time）又名TTFB（Time to first byte），指从客户端请求的第一个字节开始发送到接收到http header的第一个字节的时间差。httprtt的时间如果过长，一方面是客户端本身接入网络质量的问题，另一方面是服务的延时比较大。</p><p><strong>2）tcprtt：</strong><br>tcprtt（tcp Round-Trip Time）指客户端tcp信道第一个字节发送到接收第一个字节的时间差。因为HTTP协议底层是基于TCP的，所以在复用同一条tcp连接的前提下，httprtt的时间是包含tcprtt的时间的。大部分情况下httprtt已经可以说明问题的原因。</p><p><strong>3）throughput：</strong><br>throughput，中文名字吞吐量，它是用来衡量单位时间内成功传送数据的数量，是可以比较客观的衡量网络质量的指标。吞吐量 &#x3D;（获bits结束大小 - 获bits开始大小）&#x2F;（获bits结束时间 - 获bits开始时间），这里有个细节需要注意，posix socket的read函数返回值是bytes，所以要乘以8得到bits。通常在httprtt比较小的情况下，网络依然很慢，这个时候就可以使用吞吐量来确定网络的质量。</p><p><strong>4）signal strength：</strong><br>signal strength，这里指的是无线信号强度，在Android上可以通过PhoneStateListener的onSignalStrengthsChanged方法获取到信号强弱，但要注意只能在Android M以上的版本才生效。iOS上暂时没有靠谱的实现。</p><p><strong>5）bandwidth-delay product：</strong><br>bandwidth-delay product，中文名带宽时延乘积，指的是一个数据链路的能力（throughput）与来回通信延迟（rtt）的乘积。带宽时延乘积的结果是比特不是位，这个比特值反应出当前网络管道的最大容量。TCP中有一个窗口大小的概念，会限制发送和接收数据的大小，所以TCP窗口大小的调节是直接受带宽时延乘积的影响，根据带宽时延乘积的值去设置套接字的setsockopt方法，设置的option是SO_RCVBUF（接收缓冲区大小）和SO_SNDBUF（发送缓冲区大小</p><h3 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h3><p>接口层提供的状态是对标主动采集的网络状态的，所以也包括 GOOD、BAD、UNKNOWN、OFFLINE</p><ol><li><strong>GOOD</strong></li></ol><p>3G网、4G网、5G网，任一条件满足即标记为GOOD状态。</p><p>通过阈值标记3G和广义的4G，httprtt大于等于273ms，tcprtt大于等于204ms，即标记为3G状态。</p><p>小于这两个值则被标记为4G、5G网。</p><ol><li><strong>BAD</strong></li></ol><p>2G网、httprtt大于1.31s，任一条件满足则标记为BAD状态。阈值需要在网上查询资料，根据业务线调整。</p><ol><li><strong>UNKNOWN</strong></li></ol><p>非法的httprtt、tcprtt、吞吐量，任一条件满足则标记为UNKNOWN状态。比如初始化的时候，有的值会标为-1</p><ol><li><strong>OFFLINE</strong></li></ol><p>依赖平台能力进行判断，Android可以利用 <code>ConnectivityManager</code>得到 <code>NetworkInfo</code>，判断网络信息（没有连接wifi、或者wifi无网络等）</p><h3 id="相同url，但资源更新验证"><a href="#相同url，但资源更新验证" class="headerlink" title="相同url，但资源更新验证"></a><strong>相同url，但资源更新验证</strong></h3><h4 id="Http、Https缓存机制中提供了验证机制，利用Last-Modified-或者Entity-Tag（ET）来验证当前已缓存的资源是否与服务端最新资源相同"><a href="#Http、Https缓存机制中提供了验证机制，利用Last-Modified-或者Entity-Tag（ET）来验证当前已缓存的资源是否与服务端最新资源相同" class="headerlink" title="Http、Https缓存机制中提供了验证机制，利用Last-Modified 或者Entity Tag（ET）来验证当前已缓存的资源是否与服务端最新资源相同"></a>Http、Https缓存机制中提供了验证机制，利用Last-Modified 或者Entity Tag（ET）来验证当前已缓存的资源是否与服务端最新资源相同</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>检测私有API</title>
    <link href="/2020/10/21/%E6%A3%80%E6%B5%8B%E7%A7%81%E6%9C%89API/"/>
    <url>/2020/10/21/%E6%A3%80%E6%B5%8B%E7%A7%81%E6%9C%89API/</url>
    
    <content type="html"><![CDATA[<h1 id="preg"><a href="#preg" class="headerlink" title="preg"></a>preg</h1><ol><li>cd到工程根目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 工程根目录<br></code></pre></td></tr></table></figure><ol><li>遍历查找关键字</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">grep 关键字 -r .<br>以上面的邮件举例的话：”grep com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.springboard</span><span class="hljs-selector-class">.complete</span> -r .“<br></code></pre></td></tr></table></figure><p>此命令会查找根目录以及多级目录以下的所有文件，包括.framework和.a库，找到匹配结果的话，会打印出来。<br> -r参数表示会遍历多级目录下的文件。<br> 注意:-r和.之间有个空格</p><h1 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h1><p>首先需要找到app对应的一个Unix可执行文件，可以从两个途径获取这个文件。</p><h4 id="工程中获取"><a href="#工程中获取" class="headerlink" title="工程中获取"></a>工程中获取</h4><ol><li>在Xcode文件树中搜索“.app”</li><li>找到对应文件，右键“Show in Finder”</li><li>选中.app文件，右键“显示包内容”</li><li>下拉可找到一个跟app名字一致的Unix执行文件</li></ol><h4 id="ipa文件中获取"><a href="#ipa文件中获取" class="headerlink" title="ipa文件中获取"></a>ipa文件中获取</h4><ol><li>将.ipa改变成.zip后缀</li><li>解压文件，进入文件夹，进入Payload子文件，找到.app文件</li><li>选中.app文件，右键“显示包内容”</li><li>下拉可找到一个跟app名字一致的Unix执行文件</li></ol><h4 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">strings - -a -arch armv7 Unix可执行文件 | grep 关键字<br></code></pre></td></tr></table></figure><p>-a、-arch、armv7这几个参数作用未知，此处只是做一个简单记录，以后有空再做学习。</p><h1 id="otool"><a href="#otool" class="headerlink" title="otool"></a>otool</h1><p>跟strings一样，需要先找到Unix可执行文件，然后运行指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">otool -L Unix可执行文件<br></code></pre></td></tr></table></figure><p>会打印出工程中用到的系统库，我尝试的结果是只有系统库，可以在打印结果中检查是否引入了私有库。</p><h1 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h1><p>跟strings一样，需要先找到Unix可执行文件，然后运行指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">nm Unix可执行文件 | grep 关键字<br></code></pre></td></tr></table></figure><p>会打印关键字对应的方法调用的位置等，未仔细研究，暂且做记录。</p><h1 id="检查私有API的开源库"><a href="#检查私有API的开源库" class="headerlink" title="检查私有API的开源库"></a>检查私有API的开源库</h1><p>查资料过程中，发现一个开源库iOS-private-api-checker，可以用来检查app是否使用了私有API，并定位调用位置。</p><p>进入开源库的GitHub界面，显示“Deprecated”状态，最终测试结果，不能检测出私有API的问题，不知道是否我的配置有问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在查找“定位调用私有API位置的方法”的过程，发现大多数文章的作者通过grep的方式就可以定位到问题所在。我之所以查找了其他工具的使用方法，是因为我用grep的方式没有查找到问题，最终花了很多时间来查找问题，结果是让人很无奈。<br> 原因竟然是提交审核的包跟我查找问题的包不是同一份代码，最后用提交审核对应的工程马上就定位到问题了，工作中很多时候，一个异常查找很久没有定位到问题的时候，需要跳出来，考虑一下是否是源头出了问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oc接入flutter</title>
    <link href="/2020/10/05/iOS%E6%8E%A5%E5%85%A5flutter/"/>
    <url>/2020/10/05/iOS%E6%8E%A5%E5%85%A5flutter/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><h3 id="1、Swift"><a href="#1、Swift" class="headerlink" title="1、Swift"></a>1、<strong>Swift</strong></h3><ul><li>优秀的文档</li><li>免费和开源</li><li>代码可读性好</li><li>构建速度速度快</li></ul><h3 id="2、Flutter"><a href="#2、Flutter" class="headerlink" title="2、Flutter"></a>2、Flutter</h3><ul><li>完美的文档</li><li>跨平台：单一代码库为多个平台开发应用程序的优势，减少开发、测试工作量</li><li>速度快</li><li>图形引擎</li><li>加速开发的各种工具</li><li>热重载</li><li>插件和代码重用性：Flutter 还提供了各种各样的插件，以实现更快、更容易的开发</li><li>Flutter 动画</li><li>上市速度</li></ul><span id="more"></span><h3 id="1-flutter-module-创建与配置"><a href="#1-flutter-module-创建与配置" class="headerlink" title="1. flutter module 创建与配置"></a>1. flutter module 创建与配置</h3><h4 id="1-1-下载-flutter-基础包"><a href="#1-1-下载-flutter-基础包" class="headerlink" title="1.1 下载 flutter 基础包"></a>1.1 下载 flutter 基础包</h4><p>从 github 下载代码 <code>git clone -b beta https//github.com/flutter/flutter.git</code></p><p>但是 github 可能会很慢，可以从码云上下 <code>git clone https://gitee.com/mirrors/Flutter.git</code></p><h4 id="1-2-配置-flutter-环境变量"><a href="#1-2-配置-flutter-环境变量" class="headerlink" title="1.2 配置 flutter 环境变量"></a>1.2 配置 flutter 环境变量</h4><p>如果使用的 bash</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一步：<br>cd ~           <span class="hljs-regexp">//</span> 在终端进入用户目录，一般打开终端默认就是<br><br>第二步：<br>open .bash_profile    <span class="hljs-regexp">//</span> 打开 bash 配置文件<br><span class="hljs-regexp">//</span> 另 如果 .bash_profile文件不存在需先创建再打开，具体如下：<br><span class="hljs-regexp">//</span> touch .bash_profile<br><span class="hljs-regexp">//</span> open .bash_profile<br><br>第三步：<br><span class="hljs-comment"># for flutter</span><br>export PUB_HOSTED_URL=https:<span class="hljs-regexp">//</span>pub.flutter-io.cn<br>export FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-regexp">//</span>storage.flutter-io.cn<br>export PATH=<span class="hljs-regexp">/Users/</span>hubery<span class="hljs-regexp">/dev_supports/</span>flutter/bin:<span class="hljs-variable">$PATH</span><br><br>第四步：<br>source .bash_profile      <span class="hljs-regexp">//</span> 执行文件 使命令生效<br></code></pre></td></tr></table></figure><p>如果使用的 zsh</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一步：<br>cd ~           <span class="hljs-regexp">//</span> 在终端进入用户目录，一般打开终端默认就是<br><br>第二步：<br>open .zshrc    <span class="hljs-regexp">//</span> 打开 zsh 配置文件<br><br>第三步：<br><span class="hljs-comment"># for flutter</span><br>export PUB_HOSTED_URL=https:<span class="hljs-regexp">//</span>pub.flutter-io.cn<br>export FLUTTER_STORAGE_BASE_URL=https:<span class="hljs-regexp">//</span>storage.flutter-io.cn<br>export PATH=<span class="hljs-regexp">/Users/</span>hubery<span class="hljs-regexp">/dev_supports/</span>flutter/bin:<span class="hljs-variable">$PATH</span><br><br>第四步：<br>source .zshrc      <span class="hljs-regexp">//</span> 执行文件 使命令生效<br></code></pre></td></tr></table></figure><blockquote><p>其中 <code>/Users/hubery/dev_supports/flutter</code> 为 1.1 中下载下来的 flutter 路径</p></blockquote><p>然后在终端中输入 <code>flutter</code> 验证环境变量是否配置成功，出现如下类似信息时表示配置是OK的</p><h4 id="1-3-flutter-module-创建"><a href="#1-3-flutter-module-创建" class="headerlink" title="1.3 flutter module 创建"></a>1.3 flutter module 创建</h4><p>可以使用 Android Studio 创建 flutter module</p><p>或者在目标目录下使用命令创建 <code>flutter create -t module flutter_demo_module_ios</code></p><p>创建的过程需要梯子从外网获取 flutter 相关资源。 这里推荐使用 Android Studio，操作方便，flutter 相关的插件支持的也挺好</p><h4 id="1-4-Android-Studio-上-flutter-项目配置"><a href="#1-4-Android-Studio-上-flutter-项目配置" class="headerlink" title="1.4 Android Studio 上 flutter 项目配置"></a>1.4 Android Studio 上 flutter 项目配置</h4><ul><li><p>使用 Android Studio 打开刚才创建的 module, 在 Project 栏可以看到项目目录结构</p><p>Android Studio –&gt; Preferences –&gt; Plugins –&gt; Marketplace 搜索 <code>Dart</code> 和 <code>Flutter</code> 插件并下载</p></li><li><p>配置 <code>Dart SDK path</code>, 设置入口为： Android Studio –&gt; Preferences –&gt; Languages &amp; Frameworks –&gt; Dart</p><p>配置完成后，Android Studio 工具栏就可以看到选择 devices 的选项啦，如果没出现可以重启 Android Studio</p></li></ul><!--more--><h4 id="1-5-检查-flutter-运行环境是否可用"><a href="#1-5-检查-flutter-运行环境是否可用" class="headerlink" title="1.5 检查 flutter 运行环境是否可用"></a>1.5 检查 flutter 运行环境是否可用</h4><p>执行命令 <code>flutter doctor</code></p><h4 id="1-6-如果flutter中插件安装，可在-pubspec-yaml-文件中添加需要的插件"><a href="#1-6-如果flutter中插件安装，可在-pubspec-yaml-文件中添加需要的插件" class="headerlink" title="1.6 如果flutter中插件安装，可在 pubspec.yaml 文件中添加需要的插件"></a>1.6 如果flutter中插件安装，可在 pubspec.yaml 文件中添加需要的插件</h4><ul><li>安装: <code>flutter pub get</code></li><li>更新: <code>flutter pub upgrade</code></li></ul><h4 id="1-7-执行编译"><a href="#1-7-执行编译" class="headerlink" title="1.7 执行编译"></a>1.7 执行编译</h4><ul><li>debug: <code>flutter build ios --debug --no-codesign</code></li><li>release: <code>flutter build ios --release --no-codesign</code></li></ul><h3 id="2-iOS-引入-flutter-module"><a href="#2-iOS-引入-flutter-module" class="headerlink" title="2. iOS 引入 flutter module"></a>2. iOS 引入 flutter module</h3><h4 id="2-1-创建-iOS-项目-amp-Pod-Init"><a href="#2-1-创建-iOS-项目-amp-Pod-Init" class="headerlink" title="2.1 创建 iOS 项目 &amp; Pod Init"></a>2.1 创建 iOS 项目 &amp; Pod Init</h4><p>如何创建 iOS项目以及 CocoaPods 的使用，此处就省略不表了 。。。</p><p>如需了解 CocoaPods，请戳传送门：<a href="https://www.jianshu.com/p/6d51362b7e64">CocoaPods 攻略</a></p><h4 id="2-2-使用-Cocoapods-引入-flutter-module"><a href="#2-2-使用-Cocoapods-引入-flutter-module" class="headerlink" title="2.2 使用 Cocoapods 引入 flutter module"></a>2.2 使用 Cocoapods 引入 flutter module</h4><ul><li><p>先执行编译该 <code>flutter_demo_module_ios</code> 项目, 终端执行 <code>flutter build ios --debug --no-codesign</code></p></li><li><p>iOS 项目中 Podfile 文件中添加如下命令:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># Flutter</span><br>flutter_application_path = <span class="hljs-string">&#x27;../flutter_demo_module_ios/&#x27;</span><br><span class="hljs-built_in">load</span> File.join(flutter_application_path, <span class="hljs-string">&#x27;.ios&#x27;</span>, <span class="hljs-string">&#x27;Flutter&#x27;</span>, <span class="hljs-string">&#x27;podhelper.rb&#x27;</span>)<br>  <br>  <br>target <span class="hljs-string">&#x27;FlutterDemoIOSApp&#x27;</span> <span class="hljs-built_in">do</span><br>  <span class="hljs-comment"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span><br>  use_frameworks!<br>  <br>  <span class="hljs-comment"># Flutter</span><br>  install_all_flutter_pods(flutter_application_path)<br>  <br>  <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>然后执行 <code>pod install</code> 即可引入，在 pod 可以看到新增3个flutter相关的 framework</p></li></ul><h3 id="3-iOS-调用-flutter-页面"><a href="#3-iOS-调用-flutter-页面" class="headerlink" title="3. iOS 调用 flutter 页面"></a>3. iOS 调用 flutter 页面</h3><h4 id="3-1-多引擎调用"><a href="#3-1-多引擎调用" class="headerlink" title="3.1 多引擎调用"></a>3.1 多引擎调用</h4><p>多引擎调用就是每打开一个页面就实例化一个 <code>FlutterViewController</code></p><p>iOS 中的实现:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@objc<br>    <span class="hljs-keyword">private</span> func on<span class="hljs-constructor">OpenPageA()</span> &#123;<br>        <span class="hljs-keyword">let</span> flutterVC = <span class="hljs-constructor">FlutterViewController()</span><br>        flutterVC.set<span class="hljs-constructor">InitialRoute(<span class="hljs-string">&quot;one&quot;</span>)</span><br>        self.navigationController?.push<span class="hljs-constructor">ViewController(<span class="hljs-params">flutterVC</span>, <span class="hljs-params">animated</span>: <span class="hljs-params">true</span>)</span><br>    &#125;<br>    <br>    @objc<br>    <span class="hljs-keyword">private</span> func on<span class="hljs-constructor">OpenPageB()</span> &#123;<br>        <span class="hljs-keyword">let</span> flutterVC = <span class="hljs-constructor">FlutterViewController()</span><br>        flutterVC.set<span class="hljs-constructor">InitialRoute(<span class="hljs-string">&quot;two&quot;</span>)</span><br>        self.navigationController?.push<span class="hljs-constructor">ViewController(<span class="hljs-params">flutterVC</span>, <span class="hljs-params">animated</span>: <span class="hljs-params">true</span>)</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>flutter 中的实现:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ui&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/services.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_demo_module_ios/pages/first_page.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_demo_module_ios/pages/second_page.dart&#x27;</span>;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>() =&gt; <span class="hljs-title function_">runApp</span>(<span class="hljs-title class_">MyApp</span>(<span class="hljs-attr">pageIndex</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">defaultRouteName</span>));<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> &#123;<br>  final <span class="hljs-title class_">String</span> pageIndex;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>(&#123;<span class="hljs-title class_">Key</span> key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">pageIndex</span>&#125;) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>(<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      <span class="hljs-attr">theme</span>: <span class="hljs-title class_">ThemeData</span>(<br>        <span class="hljs-attr">primarySwatch</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span>,<br>      ),<br>      <span class="hljs-attr">home</span>: <span class="hljs-title function_">rootPage</span>(pageIndex),<br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">rootPage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> pageIndex</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (pageIndex) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;one&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">FirstPage</span>();<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;two&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">SecondPage</span>();<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在实例化 <code>FlutterViewController</code> 时为 flutter 指定对应的页面，flutter 根据传入的 key 创建对应的页面</p><p>起初 flutter 官方提供的是多引擎调用方式，简单来说是每打开一个页面创建一个 <code>FlutterViewController</code>, 每个 <code>FlutterViewController</code> 会对应一个 <code>FlutterEngine</code>, 而在页面退出时内存却没有完全释放，这就导致每打开一次页面内存会逐步增长</p><h4 id="3-2-单引擎调用"><a href="#3-2-单引擎调用" class="headerlink" title="3.2 单引擎调用"></a>3.2 单引擎调用</h4><p>所谓的单引擎就是全局只使用一个 <code>FlutterEngine</code>，再绑定唯一的 <code>FlutterViewController</code>，这样多引擎的内存问题也就基本得到了解决，这也是目前官方比较推荐方式。</p><p>由于全局只有 <code>FlutterViewController</code> ，那么在打开 flutter 页面前，需要通过消息通知 flutter 替换当前的 main page</p><p>iOS 中的实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 在 AppDelegate 中创建全局 FlutterEngine，并启动</span><br><span class="hljs-comment">// 之所以在APP启动时就启动，是因为 FlutterEngine 启动时会有短暂的延迟，放在打开页面之前启动会明显感觉到卡顿</span><br><br><span class="hljs-keyword">var</span> window: <span class="hljs-type">UIWindow</span>?<br><span class="hljs-keyword">var</span> flutterEngine: <span class="hljs-type">FlutterEngine</span>?<br>    <br><br> <span class="hljs-keyword">func</span> <span class="hljs-title function_">application</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">application</span>: <span class="hljs-type">UIApplication</span>, <span class="hljs-params">didFinishLaunchingWithOptions</span> <span class="hljs-params">launchOptions</span>: [<span class="hljs-type">UIApplication</span>.<span class="hljs-params">LaunchOptionsKey</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) &#123;<br>            <span class="hljs-comment">// SceneDelegate 中处理</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            window <span class="hljs-operator">=</span> <span class="hljs-type">UIWindow</span>(frame: <span class="hljs-type">UIScreen</span>.main.bounds)<br>            window<span class="hljs-operator">?</span>.backgroundColor <span class="hljs-operator">=</span> .white<br>            <span class="hljs-keyword">let</span> nav <span class="hljs-operator">=</span> <span class="hljs-type">UINavigationController</span>(rootViewController: <span class="hljs-type">ViewController</span>())<br>            window<span class="hljs-operator">?</span>.rootViewController <span class="hljs-operator">=</span> nav<br>            window<span class="hljs-operator">?</span>.makeKeyAndVisible()<br>        &#125;<br><br>        <br>        <span class="hljs-keyword">self</span>.flutterEngine <span class="hljs-operator">=</span> <span class="hljs-type">FlutterEngine</span>(name: <span class="hljs-string">&quot;flutter-demo&quot;</span>, project: <span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">self</span>.flutterEngine<span class="hljs-operator">?</span>.run()<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> flutterVC: <span class="hljs-type">FlutterViewController</span>!<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> msgChannel: <span class="hljs-type">FlutterBasicMessageChannel</span>!<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        <br>        <span class="hljs-keyword">self</span>.view.addSubview(button(frame: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">60</span>, y: <span class="hljs-number">150</span>, width: <span class="hljs-number">260</span>, height: <span class="hljs-number">40</span>), title: <span class="hljs-string">&quot;Page A&quot;</span>, selector: <span class="hljs-keyword">#selector</span>(onOpenPageA)))<br>        <span class="hljs-keyword">self</span>.view.addSubview(button(frame: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">60</span>, y: <span class="hljs-number">250</span>, width: <span class="hljs-number">260</span>, height: <span class="hljs-number">40</span>), title: <span class="hljs-string">&quot;Page B&quot;</span>, selector: <span class="hljs-keyword">#selector</span>(onOpenPageB)))<br>        <br>        <span class="hljs-keyword">let</span> flutterEngine <span class="hljs-operator">=</span> (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as?</span> <span class="hljs-type">AppDelegate</span>)<span class="hljs-operator">?</span>.flutterEngine<br>        <span class="hljs-keyword">self</span>.flutterVC <span class="hljs-operator">=</span> <span class="hljs-type">FlutterViewController</span>(engine: flutterEngine<span class="hljs-operator">!</span>, nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">self</span>.msgChannel <span class="hljs-operator">=</span> <span class="hljs-type">FlutterBasicMessageChannel</span>(name: <span class="hljs-string">&quot;message-channel&quot;</span>, binaryMessenger: flutterVC <span class="hljs-keyword">as!</span> <span class="hljs-type">FlutterBinaryMessenger</span>)<br>        <br>        <span class="hljs-keyword">self</span>.msgChannel.setMessageHandler(&#123; (message, reply) <span class="hljs-keyword">in</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;message: <span class="hljs-subst">\(String(describing: message))</span>&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;reply: <span class="hljs-subst">\(String(describing: reply))</span>&quot;</span>)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">button</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>, <span class="hljs-params">title</span>: <span class="hljs-type">String</span>, <span class="hljs-params">selector</span>: <span class="hljs-type">Selector</span>) -&gt; <span class="hljs-type">UIButton</span> &#123;<br>        <span class="hljs-keyword">let</span> btn <span class="hljs-operator">=</span> <span class="hljs-type">UIButton</span>()<br>        btn.frame <span class="hljs-operator">=</span> frame<br>        btn.backgroundColor <span class="hljs-operator">=</span> .red<br>        btn.setTitle(title, for: .normal)<br>        btn.setTitleColor(.white, for: .normal)<br>        btn.addTarget(<span class="hljs-keyword">self</span>, action: selector, for: .touchUpInside)<br>        <span class="hljs-keyword">return</span> btn<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">onOpenPageA</span>() &#123;<br>        <span class="hljs-keyword">self</span>.pushFlutterPage(pageName: <span class="hljs-string">&quot;one&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">onOpenPageB</span>() &#123;<br>        <span class="hljs-keyword">self</span>.pushFlutterPage(pageName: <span class="hljs-string">&quot;two&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pushFlutterPage</span>(<span class="hljs-params">pageName</span>: <span class="hljs-type">String</span>) &#123;<br>    <br>        <span class="hljs-comment">// 创建信息通道，name 需与 flutter 中保持一致</span><br>        <span class="hljs-keyword">let</span> methodChannel <span class="hljs-operator">=</span> <span class="hljs-type">FlutterMethodChannel</span>(name: <span class="hljs-string">&quot;method-channel&quot;</span>, binaryMessenger: flutterVC <span class="hljs-keyword">as!</span> <span class="hljs-type">FlutterBinaryMessenger</span>)<br>        <span class="hljs-comment">// 通知 flutter 将要展示的页面</span><br>        methodChannel.invokeMethod(pageName, arguments: <span class="hljs-literal">nil</span>)<br>        <span class="hljs-keyword">self</span>.navigationController<span class="hljs-operator">?</span>.pushViewController(flutterVC, animated: <span class="hljs-literal">true</span>)<br>        <br>        <span class="hljs-comment">// 监听 flutter 页面内的消息</span><br>        methodChannel.setMethodCallHandler &#123; (call, result) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">let</span> action <span class="hljs-operator">=</span> call.method<br>            <span class="hljs-keyword">switch</span> action &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;back&quot;</span>:<br>                <span class="hljs-keyword">self</span>.flutterVC.navigationController<span class="hljs-operator">?</span>.popViewController(animated: <span class="hljs-literal">true</span>)<br>                <br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;changeBackgroundColor&quot;</span>:<br>                <span class="hljs-keyword">let</span> colors: [<span class="hljs-type">UIColor</span>] <span class="hljs-operator">=</span> [.black, .gray, .yellow, .orange, .brown]<br>                <span class="hljs-keyword">let</span> idx <span class="hljs-operator">=</span> arc4random()<span class="hljs-operator">%</span><span class="hljs-number">4</span><br>                <span class="hljs-keyword">self</span>.view.backgroundColor <span class="hljs-operator">=</span> colors[<span class="hljs-type">Int</span>(idx)]<br>                <br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">touchesBegan</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">touches</span>: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">UITouch</span>&gt;, <span class="hljs-params">with</span> <span class="hljs-params">event</span>: <span class="hljs-type">UIEvent</span>?) &#123;<br>        <span class="hljs-comment">// 向 flutter 发送信息</span><br>        <span class="hljs-keyword">self</span>.msgChannel<span class="hljs-operator">?</span>.sendMessage(<span class="hljs-type">NSDate</span>().description)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>flutter 中的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> &#x27;dart:ui&#x27;;<br><span class="hljs-keyword">import</span> &#x27;<span class="hljs-keyword">package</span>:flutter/material.dart&#x27;;<br><span class="hljs-keyword">import</span> &#x27;<span class="hljs-keyword">package</span>:flutter/services.dart&#x27;;<br><span class="hljs-keyword">import</span> &#x27;<span class="hljs-keyword">package</span>:flutter_demo_module_ios/pages/first_page.dart&#x27;;<br><span class="hljs-keyword">import</span> &#x27;<span class="hljs-keyword">package</span>:flutter_demo_module_ios/pages/second_page.dart&#x27;;<br><br>void main() =&gt; runApp(<span class="hljs-type">MyApp</span>());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  _MyApp createState() =&gt; _MyApp();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State&lt;MyApp&gt;</span> </span>&#123;<br>  <span class="hljs-type">String</span> pageIndex = &#x27;one&#x27;;<br>  <br>  <span class="hljs-comment">// 注册消息通道</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">MethodChannel</span> _oneChannel = <span class="hljs-type">MethodChannel</span>(&#x27;method-channel&#x27;);<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">BasicMessageChannel</span> _msgChannel = <span class="hljs-type">BasicMessageChannel</span>(&#x27;message-channel&#x27;, <span class="hljs-type">StandardMessageCodec</span>());<br><br>  <span class="hljs-meta">@override</span><br>  void initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>    <span class="hljs-comment">// 监听消息</span><br>    _oneChannel.setMethodCallHandler((call) &#123;<br>      setState(() &#123;<br>        pageIndex = call.method;<br>      &#125;);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br><br>    _msgChannel.setMessageHandler((message) &#123;<br>      print(&#x27;收到 native 信息: $message&#x27;);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">MaterialApp</span>(<br>      title: &#x27;<span class="hljs-type">Just</span> a demo&#x27;,<br>      theme: <span class="hljs-type">ThemeData</span>(<br>        primarySwatch: <span class="hljs-type">Colors</span>.blue,<br>      ),<br>      home: rootPage(pageIndex),<br>    );<br>  &#125;<br>  <br>  rootPage(<span class="hljs-type">String</span> pageIndex) &#123;<br>    switch (pageIndex) &#123;<br>      <span class="hljs-keyword">case</span> &#x27;one&#x27;:<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">FirstPage</span>();<br>      <span class="hljs-keyword">case</span> &#x27;two&#x27;:<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">SecondPage</span>();<br>    &#125;<br>  &#125;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Scaffold</span>(<br>      appBar: <span class="hljs-type">AppBar</span>(title: <span class="hljs-type">Text</span>(&#x27;<span class="hljs-type">First</span> <span class="hljs-type">Page</span> <span class="hljs-number">01</span>&#x27;)),<br>      body: <span class="hljs-type">Center</span>(<br>        child: <span class="hljs-type">RaisedButton</span>(<br>          onPressed: ()&#123;<br>            <span class="hljs-comment">// 点击事件, 返回上个页面</span><br>            <span class="hljs-type">MethodChannel</span>(&#x27;method-channel&#x27;).invokeMapMethod(&#x27;back&#x27;);<br>          &#125;,<br>          child: <span class="hljs-type">Text</span>(&#x27;<span class="hljs-type">Back</span>&#x27;),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">Scaffold</span>(<br>      appBar: <span class="hljs-type">AppBar</span>(title: <span class="hljs-type">Text</span>(&#x27;<span class="hljs-type">Second</span> <span class="hljs-type">Page</span> <span class="hljs-number">02</span>&#x27;)),<br>      body: <span class="hljs-type">Center</span>(<br>        child: <span class="hljs-type">RaisedButton</span>(<br>          onPressed: ()&#123;<br>            <span class="hljs-comment">// 点击事件, 修改上个页面的背景色</span><br>            <span class="hljs-type">MethodChannel</span>(&#x27;method-channel&#x27;).invokeMapMethod(&#x27;changeBackgroundColor&#x27;);<br>          &#125;,<br>          child: <span class="hljs-type">Text</span>(&#x27;<span class="hljs-type">ChangeBackgroundColor</span>&#x27;),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-使用-FlutterBoost"><a href="#3-3-使用-FlutterBoost" class="headerlink" title="3.3 使用 FlutterBoost"></a>3.3 使用 FlutterBoost</h4><blockquote><p>官方描述</p><p>FlutterBoost 是一个Flutter插件，它可以轻松地为现有原生应用程序提供Flutter混合集成方案。FlutterBoost的理念是将Flutter像Webview那样来使用。在现有应用程序中同时管理Native页面和Flutter页面并非易事。 FlutterBoost 帮你处理页面的映射和跳转，你只需关心页面的名字和参数即可（通常可以是URL）</p></blockquote><p>FlutterBoost 的使用比较简单，但需要 native 与 flutter 都使用该插件，同时 flutter 内部页面的打开与关闭最好也使用该插件提供的方法</p><p><a href="https://github.com/alibaba/flutter_boost/blob/master/INTEGRATION.md">FlutterBoost 集成文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>swift protocol小结</title>
    <link href="/2020/08/24/swift-protocol%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/08/24/swift-protocol%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体和枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型遵循这个协议。</p><p>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这些遵循协议的类型就能够使用这些功能。</p><span id="more"></span><p>协议可以继承多个协议实现菱形继承、struct使用协议来实现多肽</p><p>1.Swift中类、结构体、枚举都可以遵守协议</p><p>2.遵守多个协议使用逗号(,)分隔</p><p>3.有父类的，父类写在前面，协议在后面用逗号(,)分隔</p><p>4.协议中可以添加属性</p><ul><li><p>属性可以是实例属性和类型属性</p></li><li><p>属性需要使用var修饰，不能属于let</p></li><li><p>类型属性只能使用static修饰，不能使用class</p></li><li><p>我们需要声明属性必须是可读的或者可读可写的</p></li></ul><p>5.协议中可以添加方法</p><ul><li><p>可以是实例方法或类方法</p></li><li><p>像普通方法一样放在协议定义中，但不需要大括号和方法体</p></li><li><p>协议中不支持为协议中的方法提供默认参数</p></li><li><p>协议中的类方法也只能使用static关键字作为前缀，不能使用class</p></li><li><p>可以使用mutating提供异变方法，以使用该方法时修改实体的属性等。</p></li><li><p>可以定义构造方法，但是使用的时候需要使用required关键字</p><p>使用required修饰符可以保证：所有的遵循该协议的子类，同样能为构造器规定提供一个显式的实现或继承实现</p></li></ul><p>将mutating关键字作为函数的前缀，写在func之前，表示可以在该方法中修改它所属的实例及其实例属性的值。</p><p>6.如果定义由类专属协议，则需要继承自AnyObject</p><p>7.协议可以作为类型</p><ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ul><p>8.协议的底层存储结构是：24字节的ValueBuffer+ metadata(8字节，也就是vwt) + pwt(8字节)</p><ul><li>前24字节，官方说法是ValueBuffer，主要用于存储遵循了协议的实体的属性值</li><li>如果超过ValueBuffer最大容量就会开辟内存进行存储，此24字节拿出8字节存储指向该内存区域的指针</li><li>目前对于类，发现其存储的都是指针</li><li>存储metadata是为了查找遵守协议的实体中实现协议的方法</li><li>pwt就是protocol witness table协议目击表，存储协议中的方法</li></ul><p>面向对象是以对象的视角观察整体结构，万物皆为对象。</p><p>面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。</p><p>面向协议能够解决面向对象的菱形继承，横切关注点和动态派发的安全性等问题。</p><p>参考喵神的面向协议编程与 Cocoa 的邂逅 (上)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存泄漏</title>
    <link href="/2020/06/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2020/06/15/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>我们在编写日常业务代码时，或多或少都会引入一些导致内存泄漏的代码，而这种行为又很难被监控，这就导致应用内存泄漏的口子越开越大，直接影响到线上应用的稳定性。虽然 Xcode 的 Instrucment 提供了 Leaks 和 Allocations 工具让我们能精准地定位内存泄漏问题，但是这种方式相对比较繁琐，需要开发人员频繁地去操作应用界面，以触发泄漏场景，所以 Leaks 和 Allocations 更加适合定期组织的大排查，作为监测手段，则显得笨重。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于内存泄漏的监测，业内已经有了两款成熟的开源工具，分别是 PLeakSniffer 和 MLeaksFinder。PLeakSniffer 使用 Ping-Pong 方式监测对象是否存活，在进入页面时，创建控制器关联的一系列对象代理，根据这些代理在控制器销毁时能否响应 Ping 判断代理对应的对象是否泄漏。MLeaksFinder 则是在控制器销毁时，延迟 3s 后再向监测对象发送消息，根据监测对象能否响应消息判断其是否泄漏。这两个方案基本能覆盖大部分对象泄漏或者延迟释放了的场景，考虑到性能损耗以及内存占用因素，我偏向于第二种方案。</p><p>下面说下在实际试用这两款工具后，我遇到的部分问题。</p><p>首先是 MLeaksFinder ：</p><ul><li>没有处理集合对象</li><li>没有处理对象持有的属性</li><li>每个对象都触发 3s 延迟机制，没有缓存后统一处理</li><li>检测结果输出分散</li></ul><p>然后是 PLeakSniffer ：</p><ul><li>没有处理集合对象</li><li>处理对象持有属性时，系统类过滤不全面</li><li>处理对象持有属性时，通过 KVC 访问属性导致一些懒加载的触发</li><li>无法处理未添加到视图栈中的泄漏视图</li><li>检测结果输出分散</li></ul><span id="more"></span><p>对于检测到泄漏对象的交互处理，两者都提供了终端 log 输出和 alert 提示功能，MLeaksFinder 甚至可以直接通过断言中断应用。这种提示在开发阶段尚可接受，但是在提测阶段，强交互会给测试人员造成困扰。至于为什么在提测阶段还要集成泄漏监测工具，主要有两个原因：</p><ul><li>应用功能过多的情况下，开发人员无法兼顾到老页面，一些老页面的泄漏场景可以通过测试人员在测试时触发，收集之后再统一处理</li><li>在组件化开发环境下，开发人员可能并没有集成泄漏监测工具，这种情况下，需要在提测阶段统一收集没有解决的泄漏问题</li></ul><p>所以我目前对于监测输出的诉求有两点：</p><ul><li>开发时，通过终端日志提示开发者出现了内存泄漏</li><li>提测时，收集内存泄漏的信息并上传至效能后台，周会时统一分配处理</li></ul><p>下面就针对这些调研和需求，打造一个符合自身业务场景的泄漏监测轮子。</p><h2 id="监测入口"><a href="#监测入口" class="headerlink" title="监测入口"></a>监测入口</h2><p>和 MLeaksFinder 一样，我选择延迟 3s 的机制来判断对象是否泄漏，但是实现的细节略有差别。</p><p>首先，监测入口变更为 <code>viewDidDisappear:</code> 方法，我们只需在控制器被父控制器中移除或者被 Dismissed 时，触发监测动作即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)LeaksMonitor_viewDidDisappear:(<span class="hljs-type">BOOL</span>)animated &#123;<br>    [<span class="hljs-keyword">self</span> LeaksMonitor_viewDidDisappear:animated];<br>    <br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> isMovingFromParentViewController] &amp;&amp; ![<span class="hljs-keyword">self</span> isBeingDismissed]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    [[TDFLeaksMonitor shared] detectLeaksForObject:<span class="hljs-keyword">self</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们的应用中，还有一种监测入口出现在变更根控制器时，由于直接设置根控制器不会触发 viewDidDisappear 方法，所以需要另外设置 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)LeaksMonitor_setRootViewController:(<span class="hljs-built_in">UIViewController</span> *)rootViewController &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.rootViewController &amp;&amp; ![<span class="hljs-keyword">self</span>.rootViewController isEqual:rootViewController]) &#123;<br>        [[TDFLeaksMonitor shared] detectLeaksForObject:<span class="hljs-keyword">self</span>.rootViewController];<br>    &#125;<br>    <br>    [<span class="hljs-keyword">self</span> LeaksMonitor_setRootViewController:rootViewController];<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，为了能够统一处理控制器及其持有对象，我们可以像 PLeakSniffer 一样，给每个对象包装一层代理 ：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">TDFLeakObjectProxy </span>: NSObject<br><span class="hljs-comment">// 持有 target 的对象弱引用</span><br><span class="hljs-variable">@property</span> (weak, nonatomic) id host;<br><span class="hljs-comment">// 被 host 持有的对象弱引用</span><br><span class="hljs-variable">@property</span> (weak, nonatomic, readonly) id target;<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p>只要 host 释放了而 target 没释放，则视 target 已泄漏，如果 host 未释放，则不检测 target。然后使用一个 collector 去收集这些对象对应的 proxy ，在收集完之后统一监测 collector 中的所有 proxy ，这样就可以在一个控制器监测完成后，统一上传监测出的泄漏点了 ：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- (<span class="hljs-keyword">void</span>)detectLeaksForObject:(id &lt;TDFLeakObjectProxyCollectable&gt;)<span class="hljs-built_in">object</span> &#123;<br>    <span class="hljs-comment">// 收集控制器关联的所有 proxy</span><br>    <span class="hljs-comment">// 收集之后再统一处理，避免对每一个对象都进行 3s 检测</span><br>    TDFLeakObjectProxyCollector *collector = [[TDFLeakObjectProxyCollector alloc] <span class="hljs-keyword">init</span>];<br>    TDFLeakContext *context = [[TDFLeakContext alloc] <span class="hljs-keyword">init</span>];<br>    context.host = <span class="hljs-built_in">object</span>;<br>    <br>    (<span class="hljs-keyword">void</span>)[<span class="hljs-built_in">object</span> LeaksMonitor_collectProxiesForCollector:collector withContext:context];<br>    <br>    <span class="hljs-comment">// 检测 3s 之后，collector 中的所有 proxy 是否正常</span><br>    [<span class="hljs-meta">self detectProxyCollector:collector</span>];<br>&#125;<br></code></pre></td></tr></table></figure><!--more--><h2 id="收集对象信息"><a href="#收集对象信息" class="headerlink" title="收集对象信息"></a>收集对象信息</h2><p>因为要对不同的类做特异化处理，所以这里我们先定义一个协议，通过这个协议中的 collect 方法去收集不同类实例化对象的 proxy ：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@protocol</span> TDFLeakObjectProxyCollectable &lt;NSObject&gt;<br>/**<br> 收集对象及其名下的所有成员变量对应的 proxy<br><br> <span class="hljs-keyword">@param</span> collector 收集器，存储 proxy<br> <span class="hljs-keyword">@param</span> ctx 上下文<br> */<br>- (void)LeaksMonitor_<span class="hljs-attribute">collectProxiesForCollector</span>:( TDFLeakObjectProxyCollector * _Nonnull )collector <span class="hljs-attribute">withContext</span>:( TDFLeakContext * _Nullable )ctx;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这里的关键点在于如何让 NSObject 实现此协议，主要有四个步骤 ：</p><ul><li>过滤系统类调用</li><li>向 collector 添加封装的 proxy</li><li>循环遍历对象对应的非系统类 &#x2F; 父类属性，找出 copy &#x2F; strong 类型属性，并获取其对应的成员变量值</li><li>向收集的所有成员变量对象发送 collect 方法</li></ul><p>NSObject 实现 collect 协议方法后，其子类就可以通过这个方法递归地收集名下需要监测的属性信息。比如对于集合类型 NSArray ，实现协议方法如下，表示收集自身和每个集合元素的信息，不过由于 NSArray 是系统类，所以其实例化对象并不会被收集进 collector ，如果要收集系统类的属性信息，只能通过让系统类实现协议并重载 collect 方法，手动向属性值发送 collect 消息实现，UIViewController 的 <code>childViewControllers</code>、<code>presentedViewController</code>、<code>view</code> 属性也同理 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)LeaksMonitor_collectProxiesForCollector:(TDFLeakObjectProxyCollector *)collector withContext:(TDFLeakContext *)ctx &#123;<br>    [<span class="hljs-variable language_">super</span> LeaksMonitor_collectProxiesForCollector:collector withContext:ctx];<br>    <br>    [<span class="hljs-keyword">self</span> enumerateObjectsUsingBlock:^(<span class="hljs-type">id</span>  _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-type">BOOL</span> * _Nonnull stop) &#123;<br>        <span class="hljs-keyword">if</span> ([obj conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">TDFLeakObjectProxyCollectable</span>)]) </span>&#123;<br>            [obj LeaksMonitor_collectProxiesForCollector:collector withContext:LM_CTX_D(ctx, <span class="hljs-string">@&quot;contains&quot;</span>)];<br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，直接调用属性的 getter 方法获取属性值，可能会触发属性懒加载，导致出现意料之外的问题 (比如调用 UIViewController 的 view 会触发 viewDidLoad)，所以要通过 <code>object_getIvar</code> 去获取属性对应的成员变量值。当然，这种处理方式会导致无法收集某些没有对应成员变量值的属性，比如关联对象、控制器的 view 等属性，权衡利弊之后，我还是选择忽略这种属性的监测。</p><p>除了收集必要的对象信息之外，我还记录了监测对象的引用路径信息，也就是上面 <code>LM_CTX_D</code> 宏做的事情。有些情况下，对象的引用路径能帮助我们发现，路径上的哪些操作导致了对象的泄漏，特别是在网页上浏览泄漏信息时，如果只有泄漏对象类和引用泄漏对象类两个信息，脱离了对象泄漏时的上下文环境，会增加修复的难度。有了引用路径信息后，输出的泄漏信息如下 ：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">[<br>  O : TDFV<span class="hljs-function"><span class="hljs-title">iewController</span>.view-&gt;</span>UIV<span class="hljs-function"><span class="hljs-title">iew</span>.subviews-&gt;</span>__NSA<span class="hljs-function"><span class="hljs-title">rrayM</span>(<span class="hljs-built_in">contains</span>)-&gt;</span>A.<span class="hljs-function"><span class="hljs-title">subviews</span>-&gt;</span>__NSA<span class="hljs-function"><span class="hljs-title">rrayM</span>(<span class="hljs-built_in">contains</span>)-&gt;</span>O<br>  TDFV<span class="hljs-function"><span class="hljs-title">iewController</span> : TDFViewController.childViewControllers-&gt;</span>TDFViewController<br>  __NSCFT<span class="hljs-function"><span class="hljs-title">imer</span> : TDFViewController.timer-&gt;</span>__NSCFTimer<br>]<br></code></pre></td></tr></table></figure><h2 id="过滤系统类"><a href="#过滤系统类" class="headerlink" title="过滤系统类"></a>过滤系统类</h2><p>系统类信息并不是我们应该关心的，过滤掉并不会影响到最终的监测结果。目前我尝试了两种方式来确定一个类是否为系统类：</p><ul><li>通过类所在 NSBundle 的路径</li><li>通过类所在地址</li></ul><p>先说第一种，这种方式逻辑较为简单，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">BOOL</span> LMIsSystemClass(Class cls) &#123;<br>    <span class="hljs-built_in">NSBundle</span> *bundle = [<span class="hljs-built_in">NSBundle</span> bundleForClass:cls];<br>    <span class="hljs-keyword">if</span> ([bundle isEqual:[<span class="hljs-built_in">NSBundle</span> mainBundle]]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *embededDirPath;<br>    <span class="hljs-keyword">if</span> (!embededDirPath) &#123;<br>        embededDirPath = [[<span class="hljs-built_in">NSBundle</span> mainBundle].bundleURL URLByAppendingPathComponent:<span class="hljs-string">@&quot;Frameworks&quot;</span>].absoluteString;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ![bundle.bundlePath hasPrefix:embededDirPath];<br>&#125;<br></code></pre></td></tr></table></figure><p>应用的主二进制文件，和开发者添加的 embeded frameworks 都会在固定的文件目录下，所以直接比对路径前缀即可。</p><p>接下来说说第二种，这种方式的实现步骤如下：</p><ul><li>遍历所有的 image ，通过 image 的名称判断是否为系统 image</li><li>缓存所有系统 image 的起始位置，也就是 mach_header 的地址</li><li>判断类是否为系统类时，使用 dladdr 函数获取类所在 image 的信息，通过 dli_fbase 字段获取起始地址</li><li>比对 image 的起始地址得知是否为系统类</li></ul><p>实际尝试下来后，发现第二种方式耗时会比第一种多，dladdr 函数占用了大部分时间（<a href="https://github.com/tripleCC/Laboratory/blob/85fd397fa806deea12b78555ed7be6667c1dc238/AppleSources/dyld-635.2/src/dyld.cpp#L444-L455">内部会遍历所有 image 的开始结束地址，和传入的地址进行比对</a>），所以最终选择了第一种方式作为判断依据。</p><p>过滤系统类时，针对那种会自泄漏的对象，需要进行特殊处理，不予过滤。比如 NSTimer &#x2F; CADisplayLink 对象的常见内存泄漏场景，除了 target 强引用控制器造成循环引用域外，还有一种是打破了循环引用但没有在控制器销毁时执行 <code>invalidate</code> 操作，因为 NSTimer 由 RunLoop 持有，不手动停止的情况下，就会造成泄漏。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>基于延时的内存泄漏监测机制虽然适用于大部分视图、控制器和一般属性的泄漏场景，但是还有少部分情况，这种机制无法处理，比如单例对象和共享对象。</p><p>首先说下单例对象，假设有 singleton 属性，其 getter 方法返回 Singleton 单例，这时延时监测机制无法自动过滤这种情况，依然会认为 singleton 泄漏了。有一种检测属性返回值是否为单例的方法，就是向返回值对应类发送 init 或者 share 相关方法，通过方法返回值和属性返回值的对比结果来判断，但是事实上我们无法确定业务方的单例是否重写了 init，也无法获知具体的单例类方法，所以这种方案适用面比较局限。单例对象的处理，目前还是通过白名单的方式处理较为稳妥。</p><p>共享对象的应用场景就比较普遍了，比如现有 A，B 页面，A 页面持有模型 M ，在跳转至 B 页面时，会将 M 传递给 B ，B 强引用了 M ，当 B 销毁时， M 不会销毁，而 M 又是 B 某个属性的值，所以监测机制会判断 M 泄漏了，实际上 M 只是 A 传递给 B 的共享对象。在一个控制器做完检测就需要上传至效能后台的情况下，共享对象还没有很好的处理方法，后期考虑结合 FBRetainCycleDetector 查找泄漏对象的循环引用信息，然后一并上传至效能后台，方便排查这种情况。因为每次 pop 都使用 FBRetainCycleDetector 检测控制器会比较耗时、甚至会造成延迟释放和卡顿，所以先用延时机制找出潜在的泄漏对象，再使用 FBRetainCycleDetector 检测这些泄漏对象，能极大得减少需要处理的对象数量。最终网页呈现的效果如下：</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>像内存泄露这种问题，最好在应用初期就开始着手监测和解决，否则当应用功能代码逐渐增多后，回过头来处理这种问题费时费力，还是比较麻烦的。</p><p>本文基于 PLeakSniffer 和 MLeaksFinder 监测工具的基础上，结合团队业务情况，进行了一些的改造，添加了集合对象的处理、引用路径的记录、对象的统一检测等功能，优化了部分有问题的代码，在一定程度上提升了延时机制的可用性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络优化</title>
    <link href="/2020/05/23/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    <url>/2020/05/23/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><strong>网络优化及监控</strong><br>一、短连接优化方案<br>1、域名合并：<br>客户端修改huiyuan.api.2dfire.com、tuangou.api.2dfire.com合并api.2dfire.com&#x2F;huiyuan 、api.2dfire.com&#x2F;tuangou ，服务端Server Load Balancing中还原转发到不同业务服务器<br>优势：<br>1）域名得到了收编，减少了DNS调用次数，降低了DNS劫持风险；<br>2）针对同一域名，可以利用Keep-Alive来复用Http的连接；<br>3）客户端业务层不需要修改代码，后端业务服务也不需要进行任何修改。</p><p>2、IP直连<br>客户端架设自己的DNS服务<br>1）程序启动的时候拉取“api.2dfire.com”对应的所有的IP列表；<br>2）对所有IP进行跑马测试，找到速度最快的IP（后续所有的HTTPS请求都将域名更换为跑马最快的IP即可）。<br>比如：经过跑马测试发现域名“api.dianping.com”对应最快的IP是“1.23.456.789”。<br>URL“<a href="http://api.2dfire.com/ad/command?param1=123%E2%80%9D%E5%B0%86%E8%A2%AB%E6%9B%BF%E6%8D%A2%E4%B8%BA%E2%80%9Chttp://">http://api.2dfire.com/ad/command?param1=123”将被替换为“http://</a> 1.23.456.789&#x2F;ad&#x2F;command?param1&#x3D;123”<br>优势：<br>1）摒弃了系统DNS，减少外界干扰，摆脱DNS劫持困扰；<br>2）自建DNS更新时机可以控制；<br>3）IP列表更换方便。</p><p>3、代理长连模式<br>客户端与代理服务器之间的长连通道是通过IP建立的，与DNS没有关系。客户端的HTTP请求被转换为二进制数据流送到代理服务器，也不需要进行DNS解析。代理服务器转发请求到业务服务器时，都处于同一内网，因此可以自己搭建DNS服务，减少对公网DNS服务的依赖。<br>相比公网http通道，代理服务器与业务服务器之间的网络通道也可以进行优化，通过架设专线或者租用腾讯云等方式可以大大提升通道服务质量</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20211123121958366.png" alt="image-20211123121958366" style="zoom:33%;" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>swif与oc区别总结</title>
    <link href="/2020/04/20/swif%E4%B8%8Eoc%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/20/swif%E4%B8%8Eoc%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Swift中struct和class有什么区别？"><a href="#一、Swift中struct和class有什么区别？" class="headerlink" title="一、Swift中struct和class有什么区别？"></a>一、Swift中struct和class有什么区别？</h2><h6 id="1-struct是值引用、更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可以继承。"><a href="#1-struct是值引用、更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可以继承。" class="headerlink" title="1.struct是值引用、更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可以继承。"></a>1.struct是值引用、更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可以继承。</h6><p>对于值类型都有他们自己的数据副本，因此对一个变量操作不可能影响另一个变量。值类型包括结构体（数组和字典），枚举，基本数据类型（boolean, integer, float等）</p><p>二者的本质区别：struct是深拷贝；class是浅拷贝。</p><h6 id="2-property的初始化不同："><a href="#2-property的初始化不同：" class="headerlink" title="2.property的初始化不同："></a>2.property的初始化不同：</h6><p>class在初始化的时候不能直接把property放在默认的constructor的参数里，而是需要自己创建一个带参数的constructor；而struct可以把属性放在默认的constructor的参数里。</p><h6 id="3-变量赋值方式不同。"><a href="#3-变量赋值方式不同。" class="headerlink" title="3.变量赋值方式不同。"></a>3.变量赋值方式不同。</h6><p>struct是值拷贝；<br> class是引用拷贝</p><h6 id="4-struct-和-class-的差別是-struct-的-function-要去改变-property-的值的时候要加上-mutating，而-class-不用"><a href="#4-struct-和-class-的差別是-struct-的-function-要去改变-property-的值的时候要加上-mutating，而-class-不用" class="headerlink" title="4.struct 和 class 的差別是 struct 的 function 要去改变 property 的值的时候要加上 mutating，而 class 不用"></a>4.struct 和 class 的差別是 struct 的 function 要去改变 property 的值的时候要加上 mutating，而 class 不用</h6><p><img src="https://upload-images.jianshu.io/upload_images/1367599-d343b80b39aa1540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/604/format/webp" alt="img"></p><p>image.png</p><h6 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h6><p>struct不可以继承，class可以继承。</p><h6 id="6-struct比class更轻量："><a href="#6-struct比class更轻量：" class="headerlink" title="6.struct比class更轻量："></a>6.struct比class更轻量：</h6><p>struct分配在栈中，class分配在堆中。</p><span id="more"></span><h2 id="二、Swift中的方法调用有哪些形式"><a href="#二、Swift中的方法调用有哪些形式" class="headerlink" title="二、Swift中的方法调用有哪些形式?"></a>二、Swift中的方法调用有哪些形式?</h2><p>直接派发、函数表派发、消息机制派发。派发方式受声明位置，引用类型，特定行为的影响。为什么Swift有这么多派发形式？为了效率</p><p>直接派发 (Direct Dispatch)、函数表派发 (Table Dispatch )、消息机制派发 (Message Dispatch )都有</p><p>总结起来有这么几点:</p><ul><li>值类型总是会使用直接派发, 简单易懂</li><li>而协议和类的 extension 都会使用直接派发</li><li>NSObject 的 extension 会使用消息机制进行派发</li><li>NSObject 声明作用域里的函数都会使用函数表进行派发.</li><li>协议里声明的, 并且带有默认实现的函数会使用函数表进行派发</li></ul><h4 id="指定派发方式"><a href="#指定派发方式" class="headerlink" title="指定派发方式"></a>指定派发方式</h4><h6 id="final"><a href="#final" class="headerlink" title="final"></a>final</h6><p>final 允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符, 就算是 extension 里本来就是直接派发的函数. 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector.</p><h6 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h6><p>dynamic 可以让类里面的函数使用消息机制派发. 使用 dynamic, 必须导入 Foundation 框架, 里面包括了 NSObject 和 Objective-C 的运行时. dynamic 可以让声明在 extension 里面的函数能够被 override. dynamic 可以用在所有 NSObject 的子类和 Swift 的原声类.</p><p>参考文章：<a href="https://www.jianshu.com/p/91bfe3f11eec">深入理解 Swift 派发机制</a></p><h2 id="三、Swift和OC的区别？"><a href="#三、Swift和OC的区别？" class="headerlink" title="三、Swift和OC的区别？"></a>三、Swift和OC的区别？</h2><p>Swift和OC的区别有很多，这里总结这几条：</p><table><thead><tr><th></th><th>Swift</th><th>Objective-C</th></tr></thead><tbody><tr><td>语法特性</td><td>静态语言，更加安全</td><td>动态语言，不那么安全</td></tr><tr><td>语法</td><td>更精简</td><td>冗长</td></tr><tr><td>命名空间</td><td>有</td><td>无</td></tr><tr><td>方法调用</td><td>直接调用，函数表调用，消息转发</td><td>消息转发</td></tr><tr><td>泛型&#x2F;元组&#x2F;高阶函数</td><td>有</td><td>无</td></tr><tr><td>语言效率</td><td>性能更高，速度更快</td><td>略低</td></tr><tr><td>文件特性</td><td>.swift 单文件</td><td>.h&#x2F;.m包含头文件</td></tr><tr><td>编程特性</td><td>可以更好的实现函数式编程&#x2F;响应式编程</td><td>面向对象编程</td></tr></tbody></table><h1 id="四、从OC向Swift迁移的时候遇到的问题？"><a href="#四、从OC向Swift迁移的时候遇到的问题？" class="headerlink" title="四、从OC向Swift迁移的时候遇到的问题？"></a>四、从OC向Swift迁移的时候遇到的问题？</h1><p>可以参考这篇文章：<a href="https://links.jianshu.com/go?to=https://juejin.im/post/5e5a4f20518825495a277aa7">OC项目转Swift指南</a> 里的混编注意事项。</p><h1 id="五、怎么理解面向协议编程？"><a href="#五、怎么理解面向协议编程？" class="headerlink" title="五、怎么理解面向协议编程？"></a>五、怎么理解面向协议编程？</h1><p>面向对象是以对象的视角观察整体结构，万物皆为对象。</p><p>面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。</p><p>面向协议能够解决面向对象的菱形继承，横切关注点和动态派发的安全性等问题。</p><p>参考喵神的<a href="https://links.jianshu.com/go?to=https://onevcat.com/2016/11/pop-cocoa-1/">面向协议编程与 Cocoa 的邂逅 (上)</a></p><h1 id="六、-swift中-closure-与OC中block的区别？"><a href="#六、-swift中-closure-与OC中block的区别？" class="headerlink" title="六、 swift中 closure 与OC中block的区别？"></a>六、 swift中 closure 与OC中block的区别？</h1><ul><li>closure是匿名函数、block是一个结构体对象</li><li>closure通过逃逸闭包来在内部修改变量，block 通过 __block 修饰符</li></ul><h1 id="七、-objc"><a href="#七、-objc" class="headerlink" title="七、@objc"></a>七、@objc</h1><p>在Swift代码中，使用@objc修饰后的类型，可以直接供Objective-C调用。</p><h1 id="八、Swift-中的-KVC-和-KVO"><a href="#八、Swift-中的-KVC-和-KVO" class="headerlink" title="八、Swift 中的 KVC 和 KVO"></a>八、Swift 中的 KVC 和 KVO</h1><p>KVC<br> 要继承 NSObject</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">KVCClass</span> :<span class="hljs-title">NSObject</span>&#123;<br>    <span class="hljs-keyword">var</span> someValue: String = <span class="hljs-string">&quot;123&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> kvc = KVCClass()<br>kvc.someValue <span class="hljs-comment">// 123</span><br>kvc.setValue(<span class="hljs-string">&quot;456&quot;</span>, forKey: <span class="hljs-string">&quot;someValue&quot;</span>)<br>kvc.someValue <span class="hljs-comment">// 456</span><br></code></pre></td></tr></table></figure><p>KVO<br> 由于 Swift 为了效率, 默认禁用了动态派发, 因此 Swift 要实现 KVO, 除了要继承自 NSObject 外还要将观测的对象标记为 dynamic(让 swift 代码也能有 Objective-C 中的动态机制).</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">KVOClass</span>:<span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> someValue: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span><br>    <span class="hljs-keyword">var</span> someOtherValue: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverClass</span>: <span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">observer</span>() &#123;<br>        <span class="hljs-keyword">let</span> kvo <span class="hljs-operator">=</span> <span class="hljs-type">KVOClass</span>()<br>        kvo.addObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;someValue&quot;</span>, options: .new, context: <span class="hljs-literal">nil</span>)<br>        kvo.addObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;someOtherValue&quot;</span>, options: .new, context: <span class="hljs-literal">nil</span>)<br>        kvo.someValue <span class="hljs-operator">=</span> <span class="hljs-string">&quot;456&quot;</span><br>        kvo.someOtherValue <span class="hljs-operator">=</span> <span class="hljs-string">&quot;def&quot;</span><br>        kvo.removeObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;someValue&quot;</span>)<br>        kvo.removeObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;someOtherValue&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">observeValue</span>(<span class="hljs-params">forKeyPath</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">String</span>?, <span class="hljs-params">of</span> <span class="hljs-params">object</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span>, <span class="hljs-params">change</span>: [<span class="hljs-params">NSKeyValueChangeKey</span> : <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>, <span class="hljs-params">context</span>: <span class="hljs-type">UnsafeMutableRawPointer</span>?) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(keyPath<span class="hljs-operator">!</span>)</span> change to <span class="hljs-subst">\(change<span class="hljs-operator">!</span>[.newKey] <span class="hljs-keyword">as!</span> String)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-type">ObserverClass</span>().observer()<br></code></pre></td></tr></table></figure><h1 id="九、associatedtype-的作用"><a href="#九、associatedtype-的作用" class="headerlink" title="九、associatedtype 的作用"></a>九、associatedtype 的作用</h1><p>关联类型：为协议中的某个类型提供了一个别名，其代表的真实类型在实现者中定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//协议，使用关联类型</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">TableViewCell</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">T</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateCell</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">data</span>: <span class="hljs-type">T</span>)<br>&#125;<br> <br><span class="hljs-comment">//遵守TableViewCell</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTableViewCell</span>: <span class="hljs-title class_">UITableViewCell</span>, <span class="hljs-title class_">TableViewCell</span> &#123;<br>    <span class="hljs-keyword">typealias</span> <span class="hljs-type">T</span> <span class="hljs-operator">=</span> <span class="hljs-type">Model</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateCell</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">data</span>: <span class="hljs-type">Model</span>) &#123;<br>        <span class="hljs-comment">// do something ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十、泛型"><a href="#十、泛型" class="headerlink" title="十、泛型"></a>十、泛型</h1><h6 id="1-类中泛型"><a href="#1-类中泛型" class="headerlink" title="1.类中泛型"></a>1.类中泛型</h6><p>实现一个栈，栈里边的元素可以是任何类型，但是所有元素又必须是同一种类型，使用泛型实现的代码就是这样的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//类作用域</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">YJKStack</span>&lt;<span class="hljs-title class_">T</span>&gt;: <span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-comment">//栈空间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> list:[<span class="hljs-type">T</span>] <span class="hljs-operator">=</span> []<br>    <br>    <span class="hljs-comment">//进栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">item</span>:<span class="hljs-type">T</span>)&#123;<br>        list.append(item)<br>    &#125;<br>    <br>    <span class="hljs-comment">//出栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">T</span>&#123;<br>        <span class="hljs-keyword">return</span> list.removeLast()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-泛型类型约束"><a href="#2-泛型类型约束" class="headerlink" title="2.泛型类型约束"></a>2.泛型类型约束</h6><p>实际运用中，我们的参数虽然可以不是特定的类，但是通常需要这个参数要实现某个协议或者是某个类的子类。这时候就要给泛型添加约束了，代码就是下面这一堆喽</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">YJKProtocolStack</span>&lt;<span class="hljs-title class_">T</span>: <span class="hljs-title class_">A</span>&amp;<span class="hljs-title class_">B</span>&gt;  须实现多个协议的话，用 &amp; 符号链接就好啦。<br><span class="hljs-title class_">class</span> <span class="hljs-title class_">YJKProtocolStack</span>&lt;<span class="hljs-title class_">T</span>: <span class="hljs-title class_">A</span>&gt;: <span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-comment">//栈空间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> list:[<span class="hljs-type">T</span>] <span class="hljs-operator">=</span> []<br>    <br>    <span class="hljs-comment">//进栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">item</span>:<span class="hljs-type">T</span>)&#123;<br>        list.append(item)<br>    &#125;<br>    <br>    <span class="hljs-comment">//出栈</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">T</span>&#123;<br>        <span class="hljs-keyword">return</span> list.removeLast()<br>    &#125;<br> &#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">B</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="十一、权限修饰符"><a href="#十一、权限修饰符" class="headerlink" title="十一、权限修饰符"></a>十一、权限修饰符</h1><p>open ：修饰的属性或者方法在其他作用域既可以被访问也可以被继承或重载 override。<br> public ：修饰的属性或者方法可以在其他作用域被访问，但不能在重载 override 中被访问，也不能在继承方法中的 Extension 中被访问。<br> internal：被修饰的属性和方法只能在模块内部可以访问，超出模块内部就不可被访问了。（默认）<br> fileprivate ：其修饰的属性或者方法只能在当前的 Swift 源文件里可以访问。<br> private ：只允许在当前类中调用，不包括 Extension ，用 private 修饰的方法不可以被代码域之外的地方访问。<br> 从高到低排序如下：<br> open &gt; public &gt; interal &gt; fileprivate &gt; private</p><h1 id="十二、map、filter、reduce-的作用"><a href="#十二、map、filter、reduce-的作用" class="headerlink" title="十二、map、filter、reduce 的作用"></a>十二、map、filter、reduce 的作用</h1><p>map 用于映射, 可以将一个列表转换为另一个列表</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">1, 2, 3</span>].map&#123;<span class="hljs-string">&quot;\($0)&quot;</span>&#125;<span class="hljs-comment">// 数字数组转换为字符串数组</span><br>[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>]<br></code></pre></td></tr></table></figure><p>filter 用于过滤, 可以筛选出想要的元素</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">1, 2, 3</span>].filter&#123;$<span class="hljs-number">0</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125; <span class="hljs-comment">// 筛选偶数</span><br><span class="hljs-comment">// [2] </span><br></code></pre></td></tr></table></figure><p>reduce 合并</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1, 2, 3].reduce(<span class="hljs-string">&quot;&quot;</span>)&#123;<span class="hljs-variable">$0</span> + <span class="hljs-string">&quot;\(<span class="hljs-variable">$1</span>)&quot;</span>&#125;// 转换为字符串并拼接<br>// <span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure><h1 id="十三、defer、guard的作用？"><a href="#十三、defer、guard的作用？" class="headerlink" title="十三、defer、guard的作用？"></a>十三、defer、guard的作用？</h1><p>guard :过滤器，拦截器<br> guard 和 if 类似, 不同的是, guard 总是有一个 else 语句, 如果表达式是假或者值绑定失败的时候, 会执行 else 语句, 且在 else 语句中一定要停止函数调用.</p><p>defer 语句块中的代码, 会在当前作用域结束前调用,无论函数是否会抛出错误。每当一个作用域结束就进行该作用域defer执行。 如果有多个 defer, 那么后加入的先执行.(延迟执行的意思)</p><h1 id="十四、throws-和-rethrows-的用法与作用"><a href="#十四、throws-和-rethrows-的用法与作用" class="headerlink" title="十四、throws 和 rethrows 的用法与作用"></a>十四、throws 和 rethrows 的用法与作用</h1><p>throws 用在函数上, 表示这个函数会抛出错误.<br> 有两种情况会抛出错误, 一种是直接使用 throw 抛出, 另一种是调用其他抛出异常的函数时, 直接使用 try XX 没有处理异常.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">DivideError</span>: <span class="hljs-title class_">Error</span> &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">EqualZeroError</span>;<br>&#125;<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">divide</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-type">Double</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-type">Double</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>    <span class="hljs-keyword">guard</span> b <span class="hljs-operator">!=</span> <span class="hljs-type">Double</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-type">DivideError</span>.<span class="hljs-type">EqualZeroError</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a <span class="hljs-operator">/</span> b<br>&#125;<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">split</span>(<span class="hljs-params">pieces</span>: <span class="hljs-type">Int</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> divide(<span class="hljs-number">1</span>, <span class="hljs-type">Double</span>(pieces))<br>&#125;<br></code></pre></td></tr></table></figure><p>rethrows 与 throws 类似, 不过只适用于参数中有函数, 且函数会抛出异常的情况, rethrows 可以用 throws 替换, 反过来不行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">processNumber</span>(<span class="hljs-params">a</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">b</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">function</span>: (<span class="hljs-type">Double</span>, <span class="hljs-type">Double</span>) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Double</span>) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-type">Double</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> function(a, b)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十五、为什么数组索引越界会崩溃，而字典用下标取值时-key-没有对应值的话返回的是-nil-不会崩溃。"><a href="#十五、为什么数组索引越界会崩溃，而字典用下标取值时-key-没有对应值的话返回的是-nil-不会崩溃。" class="headerlink" title="十五、为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃。"></a>十五、为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃。</h1><ul><li>1 数组索引访问的是一段连续地址,越界访问也能访问到内存,但这段内存不一定可用,所以会引起Crash.</li><li>2 字典的key并没有对应确定的内存地址,所以是安全的.</li></ul><h1 id="十六、swift把struct作为数据模型的优缺点？"><a href="#十六、swift把struct作为数据模型的优缺点？" class="headerlink" title="十六、swift把struct作为数据模型的优缺点？"></a>十六、swift把struct作为数据模型的优缺点？</h1><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>1.安全性：struct是值类型传递的，它们没有引用计数</li><li><ol><li>内存：由于它们没有引用数，它们不会因为循环引用导致内存泄漏</li></ol></li><li><ol><li>速度：值类型通常来说是以栈的形式分配的，而不是用堆。因此它们比Class要快很多。</li></ol></li><li><ol><li>拷贝：OC里拷贝一个对象，你必须选用正确的拷贝类型（深拷贝、浅拷贝），而值类型的拷贝则非常轻松！</li></ol></li><li><ol><li>线程安全：值类型是自动线程安全的。无论你从哪个线程去访问你的struct，都非常简单。</li></ol></li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li><ol><li>OC与swift混合开发：OC调用的swift代码必须继承NSObject。</li></ol></li><li><ol><li>继承：struct不能相互继承</li></ol></li><li><ol><li>NSUserDefatults: struct不能被序列化成NSData对象</li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>data段注册</title>
    <link href="/2020/04/13/data%E6%AE%B5%E6%B3%A8%E5%86%8C/"/>
    <url>/2020/04/13/data%E6%AE%B5%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="1-attribute"><a href="#1-attribute" class="headerlink" title="1. attribute"></a>1. <strong>attribute</strong></h4><p><strong><strong>attribute</strong></strong>((used, section(“____DATA,____launch”)))</p><p>Clang 提供了很多的编译函数，它们可以完成不同的功能，其中一项就是 section() 函数，section() 函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。在具体的实现中，主要分为编译期和运行时两部分。在编译期，编译器会将标记了 attribute((section())) 的数据写到指定的数据段中，例如写一个{key(key代表不同的启动阶段), *pointer} 对到数据段。到运行时，在合适的时间节点，在根据 key 读取出函数指针，完成函数的调用。</p><p>Clang Attributes 是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程，一般以 <strong>attribute</strong>(xxx) 的形式出现在代码中；为方便使用，一些常用属性也被 Cocoa 定义成宏，比如在系统头文件中经常出现的 NS_CLASS_AVAILABLE_IOS(9_0) 就是 <strong>attribute</strong>(availability(…)) 这个属性的简单写法。编译器提供了我们一种 <strong>attribute</strong>((section(“xxx段，xxx节”)的方式让我们将一个指定的数据储存到我们需要的节当中。</p><p><strong>used</strong></p><p>used的作用是告诉编译器，我声明的这个符号是需要保留的。被used修饰以后，意味着即使函数没有被引用，在Release下也不会被优化。如果不加这个修饰，那么Release环境链接器会去掉没有被引用的段。</p><p><strong>section</strong></p><p>通常情况下，编译器会将对象放置于DATA段的data或者bss节中。但是，有时我们需要将数据放置于特殊的节中，此时section可以达到目的。</p><p><strong>constructor</strong></p><p>constructor：顾名思义，加上这个属性的函数会在可执行文件（或 shared library）load时被调用，可以理解为在 main() 函数调用前执行。</p><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一点，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机：</p><span id="more"></span><p>更多相关知识可以参考</p><p><a href="http://liumh.com/2018/08/18/ios-attribute-section/">http://liumh.com/2018/08/18/ios-attribute-section/</a><br><a href="https://www.jianshu.com/p/965f6f903114">https://www.jianshu.com/p/965f6f903114</a><br><a href="https://nshipster.com/__attribute__/">https://nshipster.com/<strong>attribute</strong>&#x2F;</a></p><h4 id="2-编译期写入数据"><a href="#2-编译期写入数据" class="headerlink" title="2. 编译期写入数据"></a>2. 编译期写入数据</h4><p>首先我们定义函数存储的结构体，如下，function 是函数指针，指向我们要写入的函数，stage 为启动项执行的阶段，priority 为执行优先级，优先级高的启动项优先执行。结构体中还可以增加其他字段，比如类名方法名之类，调试的时候可以查看有哪些组件和方法有写入。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">struct</span> GHW_Function &#123;<br>    <span class="hljs-built_in">char</span> *stage;<br>    <span class="hljs-built_in">long</span> priority;<br>    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">function</span>)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>定义函数 _GHWStage_A ，里面是需要在 Stage_A 阶段要执行的任务。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">void</span> _GHWStage_A () &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ModuleA:Stage_A&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>将包含函数指针的结构体写入到我们指定的数据区指定的段 __DATA, 指定的节 __launch，方法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__attribute__((used, <span class="hljs-built_in">section</span>(<span class="hljs-string">&quot;__DATA,__launch&quot;</span>))) \<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">GHW_Function</span> __FStage_A = (<span class="hljs-keyword">struct</span> GHW_Function)&#123;(<span class="hljs-type">char</span> *)(&amp;(<span class="hljs-string">&quot;Stage_A&quot;</span>)),  _priority_  , (<span class="hljs-type">void</span> *)(&amp;_GHWStage_A)&#125;; \<br></code></pre></td></tr></table></figure><p>上面步骤看起来很烦，而且代码晦涩难懂，所以要使用宏来定义一下，如下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing">#define <span class="hljs-title function_">GHW_FUNCTION_EXPORT</span>(<span class="hljs-built_in">key</span>) \<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _GHW##<span class="hljs-built_in">key</span>(<span class="hljs-keyword">void</span>); \<br>__attribute__((used, <span class="hljs-title function_">section</span>(<span class="hljs-string">&quot;__DATA,__launch&quot;</span>))) \<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct GHW_Function __F##<span class="hljs-built_in">key</span> = (struct GHW_Function)&#123;(<span class="hljs-type">char</span> *)(&amp;#<span class="hljs-built_in">key</span>), _priority_,  (<span class="hljs-keyword">void</span> *)(&amp;_GHW##<span class="hljs-built_in">key</span>)&#125;; \<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _GHW##<span class="hljs-built_in">key</span> \<br></code></pre></td></tr></table></figure><p>然后我们将函数写入数据区方式变得很简单了，还是上面的代码，写入指定的段和节，方法如下</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">GHW_FUNCTION_EXPORT</span>(Stage_A, kGHWLauncherPriorityHigh)() &#123;<br>    <span class="hljs-built_in">printf</span>(&quot;ModuleA:Stage_A\n&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以非常方便简单了。</p><p>将工程打包，然后用 MachOView 打开 Mach-O 文件，可以看出数据写入到相关数据区了，如下</p><p><a href="https://github.com/guohongwei719/GHWAppLaunchManager/blob/master/resources/4.png"><img src="https://github.com/guohongwei719/GHWAppLaunchManager/raw/master/resources/4.png" alt="img"></a></p><h4 id="3-运行时读出数据"><a href="#3-运行时读出数据" class="headerlink" title="3. 运行时读出数据"></a>3. 运行时读出数据</h4><p>启动项也需要根据所完成的任务被分类，有些启动项是需要刚启动就执行的操作，如 Crash 监控、统计上报等，否则会导致信息收集的缺失；有些启动项需要在较早的时间节点完成，例如一些提供用户信息的 SDK、定位功能的初始化、网络初始化等；有些启动项则可以被延迟执行，如一些自定义配置，一些业务服务的调用、支付 SDK、地图 SDK 等。我们所做的分阶段启动，首先就是把启动流程合理地划分为若干个启动阶段，然后依据每个启动项所做的事情的优先级把它们分配到相应的启动阶段，优先级高的放在靠前的阶段，优先级低的放在靠后的阶段。</p><p>如果要覆盖到 main 之前的阶段，之前我们是使用 load 方法，现在使用 <strong>attribute</strong> 的 constructor 属性也可以实现这个效果，而且更方便，优势如下</p><ul><li>所有 Class 都已经加载完成</li><li>不用像 load 还得挂在在一个 Class 中</li></ul><p>相关代码如下</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">__attribute__((<span class="hljs-function"><span class="hljs-keyword">constructor</span>))</span><br><span class="hljs-function"><span class="hljs-title">void</span> <span class="hljs-title">premain</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    [[GHWLaunchManager sharedInstance] executeArrayForKey:kGHWLauncherStagePreMain];</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>表示在 main 之前去获取数据区 pre_main 节的函数指针执行。<br>app willFinish 和 didFinish 阶段也可以执行相关代码，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application willFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions &#123;<br>    [[GHWLaunchManager sharedInstance] executeArrayForKey:kGHWLauncherStageA];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions &#123;<br>    [[GHWLaunchManager sharedInstance] executeArrayForKey:kGHWLauncherStageB];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读出数据有两种方式：</p><ul><li>可以使用 _dyld_register_func_for_add_image 函数，这个函数是用来注册回调，在 dyld 加载镜像时，会执行注册过的回调函数，获取到每个镜像的 mach_header 然后读出数据；</li><li>镜像加载完后遍历每个镜像；</li></ul><p>本方案里面采用的第二种方式。</p><h4 id="4-读出数据要注意的地方（use-frameworks-）"><a href="#4-读出数据要注意的地方（use-frameworks-）" class="headerlink" title="4. 读出数据要注意的地方（use_frameworks!）"></a>4. 读出数据要注意的地方（use_frameworks!）</h4><p>实际在读的时候要根据我们 podfile 里面集成方式而有所区别，如果 Podfile 里面有 use_frameworks! 则是动态库集成方式，如果注释掉的话就是静态库的集成方式，静态库集成方式比较好办，因为只有一个主二进制文件，写入的数据区也是写到这个里面，只需要从这一个二进制文件里面读取就可以了。但是如果是动态库集成的各个组件，那么打成包以后各个组件最后跟主二进制文件是分开的，各个组件写入的数据区跟主二进制不是在一起的，而是写入到自己二进制文件里面相应的数据区，因此我们在读的时候需要遍历所有动态库。我们 App 启动时会加载所有动态库，一共有 569个，其中 83 个是 Podfile 里面集成的，其他都是系统库。这些库的路径也有区别，Podfile 集成进去的库路径类似下面这样</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span><span class="hljs-number">70</span>C36D61-CD7A-<span class="hljs-number">49</span>F7-A690-<span class="hljs-number">0</span>C8B3D36C36A<span class="hljs-regexp">/HelloTrip.app/</span>Frameworks<span class="hljs-regexp">/AFNetworking.framework/</span>AFNetworking<br><span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span><span class="hljs-number">70</span>C36D61-CD7A-<span class="hljs-number">49</span>F7-A690-<span class="hljs-number">0</span>C8B3D36C36A<span class="hljs-regexp">/HelloTrip.app/</span>Frameworks<span class="hljs-regexp">/APAddressBook.framework/</span>APAddressBook<br><span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span><span class="hljs-number">70</span>C36D61-CD7A-<span class="hljs-number">49</span>F7-A690-<span class="hljs-number">0</span>C8B3D36C36A<span class="hljs-regexp">/HelloTrip.app/</span>Frameworks<span class="hljs-regexp">/AliyunOSSiOS.framework/</span>AliyunOSSiOS<br></code></pre></td></tr></table></figure><p>系统库类似下面这样</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/Frameworks/</span>AddressBookUI.framework/AddressBookUI<br><span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/Frameworks/</span>AVFoundation.framework/AVFoundation<br><span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/Frameworks/</span>AssetsLibrary.framework/AssetsLibrary<br><span class="hljs-regexp">/usr/</span>lib/libresolv.<span class="hljs-number">9</span>.dylib<br></code></pre></td></tr></table></figure><p>因此根据路径里面是否包含 &#x2F;HelloTrip.app&#x2F; 来判断是否 Podfile 集成的库，是的话就去找对应的数据区。</p><p>经过多次测试，我们 App 在没有过滤路径情况下遍历动态库上的耗时如下</p><p>0.002198934555053711<br>0.002250075340270996<br>0.003002047538757324<br>0.006783008575439453<br>0.002267003059387207<br>0.003368020057678223<br>0.003902077674865723</p><p>有过滤路径情况下遍历时间如下：</p><p>0.0004119873046875<br>0.0007159709930419922<br>0.0004429817199707031<br>0.0004270076751708984<br>0.0004940032958984375<br>0.0004789829254150391<br>0.0004340410232543945<br>0.0004389286041259766</p><p>可见过滤情况下遍历一次所有动态库不到一毫秒，完全可以接受。因此如果 Podfile 中开启了 use_frameworks! ，使用动态库集成方式，那么读取 section 数据具体代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSMutableArray</span>&lt;GHWModuleMetaDataModel *&gt; * modulesInDyld() &#123;<br>    <span class="hljs-built_in">NSString</span> *appName = [[[<span class="hljs-built_in">NSBundle</span> mainBundle] infoDictionary] objectForKey:(<span class="hljs-built_in">NSString</span> *)kCFBundleExecutableKey];<br>    <span class="hljs-built_in">NSString</span> *fullAppName = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;/%@.app/&quot;</span>, appName];<br>    <span class="hljs-type">char</span> *fullAppNameC = (<span class="hljs-type">char</span> *)[fullAppName UTF8String];<br>    <span class="hljs-built_in">NSMutableArray</span>&lt;GHWModuleMetaDataModel *&gt; * result = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br>    <span class="hljs-type">int</span> num = _dyld_image_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *name = _dyld_get_image_name(i);<br>        <span class="hljs-keyword">if</span> (strstr(name, fullAppNameC) == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> mach_header *header = _dyld_get_image_header(i);<br>        <span class="hljs-comment">//        printf(&quot;%d name: %s\n&quot;, i, name);</span><br>        <br>        Dl_info info;<br>        dladdr(header, &amp;info);<br>        <span class="hljs-keyword">const</span> GHWExportValue dliFbase = (GHWExportValue)info.dli_fbase;<br>        <span class="hljs-keyword">const</span> GHWExportSection *section = GHWGetSectByNameFromHeader(header, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;__launch&quot;</span>);<br>        <span class="hljs-keyword">if</span> (section == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> addrOffset = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GHW_Function);<br>        <span class="hljs-keyword">for</span> (GHWExportValue addr = section-&gt;offset;<br>             addr &lt; section-&gt;offset + section-&gt;size;<br>             addr += addrOffset) &#123;<br>            <br>            <span class="hljs-keyword">struct</span> GHW_Function entry = *(<span class="hljs-keyword">struct</span> GHW_Function *)(dliFbase + addr);<br>            GHWModuleMetaDataModel * metaData = [[GHWModuleMetaDataModel alloc] init];<br>            metaData.priority = entry.priority;<br>            metaData.imp = entry.function;<br>            metaData.stage = [<span class="hljs-built_in">NSString</span> stringWithCString:entry.stage encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>            [result addObject:metaData];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次读取我们自定义的 __launch 节的数据，将启动项相关 C 结构体数据转为对应 OC 的数据模型，放到一个数组里面。然后将数组转化为一个字典，key 为启动相关阶段，obj 为该阶段所有启动项数组。后面再执行的时候直接去字典里面根据对应阶段获取所有启动项数组。代码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)executeArrayForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *arrayModule;<br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span>.moduleDic count]) &#123;<br>        arrayModule = modulesInDyld();<br>        <span class="hljs-keyword">if</span> (!arrayModule.count) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        [arrayModule sortUsingComparator:^<span class="hljs-built_in">NSComparisonResult</span>(GHWModuleMetaDataModel * _Nonnull obj1, GHWModuleMetaDataModel * _Nonnull obj2) &#123;<br>            <span class="hljs-keyword">return</span> obj1.priority &lt; obj2.priority;<br>        &#125;];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; [arrayModule count]; i++) &#123;<br>            GHWModuleMetaDataModel *model = arrayModule[i];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.moduleDic[model.stage]) &#123;<br>                <span class="hljs-built_in">NSMutableArray</span> *stageArray = <span class="hljs-keyword">self</span>.moduleDic[model.stage];<br>                [stageArray addObject:model];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">NSMutableArray</span> *stageArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br>                [stageArray addObject:model];<br>                <span class="hljs-keyword">self</span>.moduleDic[model.stage] = stageArray;<br>            &#125;<br>        &#125;<br>    &#125;<br>    arrayModule = <span class="hljs-keyword">self</span>.moduleDic[key];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; [arrayModule count]; i++) &#123;<br>        GHWModuleMetaDataModel *model = arrayModule[i];<br>        IMP imp = model.imp;<br>        <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>) = (<span class="hljs-type">void</span> *)imp;<br>        func();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h3><p>在启动流程中，在启动阶段 Stage_A 触发所有注册到 Stage_A 时间节点的启动项，通过对这种方式，几乎没有任何额外的辅助代码，我们用一种很简洁的方式完成了启动项的自注册。</p><p>后续需要确定启动项的添加 &amp; 维护规范，启动项分类原则，优先级和启动阶段，目的是管控性能问题增量，保证优化成果。</p><p>本方案核心思想有两点：</p><ul><li>使用 <strong>attribute</strong> 实现编译期自动注册；</li><li>组件自注册，去中心化。</li></ul><p>后者依赖前者的基础基础才能得以实现，可以简单理解为一种快速写入和读取配置表的类似技术。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>app启动时间优化</title>
    <link href="/2020/03/21/app%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/"/>
    <url>/2020/03/21/app%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://link.zhihu.com/?target=https://developer.apple.com/videos/play/wwdc2016/406/">《Optimizing App Startup Time》议题</a>上，提到了启动分为冷启动和暖启动两种。</p><p>常规的优化方式，还包括像动态库懒加载、TTI 任务调度、后台启动、防劣化等。</p><p>暖启动：是指内存中包含 App 的相关数据，与我们日常提到的热启动不太一样，连续杀掉 App 的启动也可能是暖启动。</p><p>冷启动：是指系统的内核缓存区里没有 App 相关数据。冷暖启动的启动时间会差异比较大，冷启动的数据更能反映 App 真实的启动时长。保证 App 是冷启动的方法，就是通过重启设备，清理系统内核缓存区。</p><p>常见的 iOS 启动时长测试方法，主要有以下几种</p><ol><li><strong>Xcode Developer Tool</strong>： 使用 Instruments 的 Time Profiler 插件，可以检测 App CPU 的使用情况。能看到 App 的启动时间和各个方法消耗的时间；</li><li><strong>客户端计算统计</strong>： 通过 hook 关键函数的调用，计算获得性能数据。</li><li>![image-20230227114633430](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230227114633430.png)</li></ol><p> <strong>App总启动流程 &#x3D; pre-main (+load,initializer)+ main函数代理（didFinishLaunchingWithOptions）+ 首屏渲染（viewDidAppear）</strong>，后两个阶段都属于 <code>main函数</code> 执行阶段。</p><p>![image-20210310151027524](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210310151027524.png)</p><p>![image-20211114154156099](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211114154156099.png)</p><ul><li><p>main前</p><ul><li>加载可执行文件（App的.o文件集合）</li><li>加载动态链接库（系统和应用的动态链接库），进行rebase指针调整和bind符号绑定</li><li>Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查</li><li>初始化，包括执行+load()、attribute(constructor)修饰的函数的调用、创建C++静态全局变量</li></ul><p>main后</p><ul><li>首页初始化所需要配置文件的读写操作</li><li>首页界面渲染</li></ul></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Total</span> pre-main time: <span class="hljs-number">977</span>.<span class="hljs-number">95</span> milliseconds (<span class="hljs-number">100</span>.<span class="hljs-number">0</span>%)<br>         <span class="hljs-attribute">dylib</span> loading time: <span class="hljs-number">433</span>.<span class="hljs-number">20</span> milliseconds (<span class="hljs-number">44</span>.<span class="hljs-number">2</span>%)<br>        <span class="hljs-attribute">rebase</span>/binding time:  <span class="hljs-number">97</span>.<span class="hljs-number">24</span> milliseconds (<span class="hljs-number">9</span>.<span class="hljs-number">9</span>%)<br>            <span class="hljs-attribute">ObjC</span> setup time:  <span class="hljs-number">50</span>.<span class="hljs-number">13</span> milliseconds (<span class="hljs-number">5</span>.<span class="hljs-number">1</span>%)<br>           <span class="hljs-attribute">initializer</span> time: <span class="hljs-number">397</span>.<span class="hljs-number">36</span> milliseconds (<span class="hljs-number">40</span>.<span class="hljs-number">6</span>%)<br>           <span class="hljs-attribute">slowest</span> intializers :<br>             <span class="hljs-attribute">libSystem</span>.B.dylib :  <span class="hljs-number">11</span>.<span class="hljs-number">48</span> milliseconds (<span class="hljs-number">1</span>.<span class="hljs-number">1</span>%)<br>                   <span class="hljs-attribute">AgoraRtcKit</span> : <span class="hljs-number">105</span>.<span class="hljs-number">87</span> milliseconds (<span class="hljs-number">10</span>.<span class="hljs-number">8</span>%)<br>                        <span class="hljs-attribute">Hestia</span> : <span class="hljs-number">415</span>.<span class="hljs-number">46</span> milliseconds (<span class="hljs-number">42</span>.<span class="hljs-number">4</span>%)<br><br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="main函数代理阶段"><a href="#main函数代理阶段" class="headerlink" title="main函数代理阶段"></a>main函数代理阶段</h3><h4 id="1、手动插入代码计算耗时"><a href="#1、手动插入代码计算耗时" class="headerlink" title="1、手动插入代码计算耗时"></a>1、手动插入代码计算耗时</h4><p>  在 <code>man()</code> 函数开始执行时就开始时间：</p>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CFAbsoluteTime</span> StartTime;  <span class="hljs-comment">//  记录全局变量</span><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        StartTime = <span class="hljs-built_in">CFAbsoluteTimeGetCurrent</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIApplicationMain</span>(argc, argv, <span class="hljs-literal">nil</span>, <span class="hljs-built_in">NSStringFromClass</span>([AppDelegate <span class="hljs-keyword">class</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无侵入首屏渲染完成时间我们希望和 <code>MetricKit</code> 对齐，即获取到 <code>CA::Transaction::commit()</code>方法被调用的时间。</p><p><code>CA::Transaction::commit()</code>，<code>CFRunLoopPerformBlock</code>，<code>kCFRunLoopBeforeTimers</code> 这三个时机的顺序从早到晚依次是：</p><p>![image-20210311113820158](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210311113820158.png)</p><p>可以通过在 didFinishLaunch 中向 Runloop 注册 block 或者 BeforeTimer 的 Observer 来获取上图中两个时间点的回调，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 13.0) &#123;<br>        //注册kCFRunLoopBeforeTimers回调<br>        CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop];<br>        CFRunLoopActivity activities = kCFRunLoopAllActivities;<br>        CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, activities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;<br>            if (activity == kCFRunLoopBeforeTimers) &#123;<br>                NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970];<br>                NSLog(@&quot;runloop beforetimers launch end:%f&quot;,stamp);<br>                CFRunLoopRemoveObserver(mainRunloop, observer, kCFRunLoopCommonModes);<br>                [HSALaunchManage initLaunchService];<br>            &#125;<br>        &#125;);<br>        CFRunLoopAddObserver(mainRunloop, observer, kCFRunLoopCommonModes);<br>    &#125;<br>    else &#123;<br>        //    注册block<br>        CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop];<br>        CFRunLoopPerformBlock(mainRunloop,NSDefaultRunLoopMode,^()&#123;<br>            NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970];<br>            NSLog(@&quot;runloop block launch end:%f&quot;,stamp);<br>            [HSALaunchManage initLaunchService];<br>        &#125;);<br>    &#125;<br><br></code></pre></td></tr></table></figure><ol><li>iOS13（含）以上的系统采用 <code>runloop</code> 中注册一个 <code>kCFRunLoopBeforeTimers</code> 的回调获取到的 App 首屏渲染完成的时机更准确。</li><li>iOS13 以下的系统采用 <code>CFRunLoopPerformBlock</code> 方法注入 block 获取到的 App 首屏渲染完成的时机更准确。</li></ol><h3 id="启动时间统计"><a href="#启动时间统计" class="headerlink" title="启动时间统计:"></a>启动时间统计:</h3><h4 id="main-函数启动时间"><a href="#main-函数启动时间" class="headerlink" title="main()函数启动时间"></a>main()函数启动时间</h4><p><strong>MianStartTime:1617002963.711972</strong></p><p><strong>1617002963.862700</strong></p><h4 id="首屏结束时间："><a href="#首屏结束时间：" class="headerlink" title="首屏结束时间："></a>首屏结束时间：</h4><p><strong>runloop beforetimers launch end:1617002965.720096</strong></p><p>Total pre-main time: 797.23 milliseconds</p><p>首屏时间-Mianstart  5.72-3.7119&#x3D;2.0081 秒 </p><p>总时间：2.0081+0.977&#x3D;2.9851 秒</p><p><em><strong>对于 main() 调用之前的耗时可以优化的点有</strong></em></p><ul><li>1、减少不必要的 framework，因为动态链接比较耗时</li><li>2、check framework 应当设为 optional 和 required，如果该 framework 在当前 App 支持的所有 iOS 系统版本都存在，那么就设为 required，否则就设为 optional，因为 optional 会有些额外的检查</li><li>3、合并或者删减一些 OC 类，关于清理项目中没用到的类</li><li>4、删减没有被调用到或者已经废弃的方法</li><li>5、将不必须在 + load 方法中做的事情延迟到 + initialize 中或者放延迟到首屏渲染之后，通过监听启动完成后的一个通知，再执行原来的一些耗时逻辑，从而将耗时逻辑尽可能的延后，尽量使用异步处理。</li><li>6、高频次方法有些方法的单个耗时不高，但是在启动路径上会调用很多次的，这种累计起来的耗时也不低，比如读 Info.plist 里面的配置：</li></ul><ul><li>(NSString *)plistChannel{<br>return [[[NSBundle mainBundle] infoDictionary] objectForKey:@”CHANNEL_NAME”];<br>}</li></ul><p>修改的方式很简单，加一层内存缓存即可，这种问题在 TimeProfiler 里时间段选长一些往往就能看出来。</p><h4 id="2、APP-Launch-检测"><a href="#2、APP-Launch-检测" class="headerlink" title="2、APP Launch 检测"></a>2、APP Launch 检测</h4><p>![image-20210312173338839](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210312173338839.png)</p><p>![image-20210413111434697](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210413111434697.png)</p><p>![image-20210623152404407](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210623152404407.png)</p><p>![image-20210623155929385](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210623155929385.png)</p><p>![image-20210623154833028](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210623154833028.png)</p><h3 id="一、阿里云sdk初始化"><a href="#一、阿里云sdk初始化" class="headerlink" title="一、阿里云sdk初始化"></a>一、阿里云sdk初始化</h3><h3 id="二、flutter初始化"><a href="#二、flutter初始化" class="headerlink" title="二、flutter初始化"></a>二、flutter初始化</h3><p>[FlutterBoostPlugin.sharedInstance startFlutterWithPlatform:[RTFlutterRouter shareFlutterRouter]</p><p>  onStart:^(FlutterEngine *engine) {}]; 把flutter初始化延后至首屏渲染之后</p><h3 id="三、其他-load方法"><a href="#三、其他-load方法" class="headerlink" title="三、其他+load方法"></a>三、其他+load方法</h3><p>1、[self configProgressView];</p><p> [[FRWLocalizableManager sharedInstance] localizabledImageNamed:imgName inBundle:bundle] 先从缓存取，缓存没有从本地取，然后把图片写入缓存，80ms，已没有用移除。</p><p>2、[HVSRCLiveChatRoomUtils initializeRongCloudIM];  11ms</p><p>3、[FRRWebEngine startEngine]; 59ms</p><p>实现一个类，负责首屏渲染之后处理初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">+(void)initLaunchService &#123;<br>//flutter<br>  [FlutterBoostPlugin.sharedInstance startFlutterWithPlatform:[RTFlutterRouter shareFlutterRouter] onStart:^(FlutterEngine *engine) &#123;&#125;];<br>  //融云<br>  [HVSRCLiveChatRoomUtils initializeRongCloudIM];<br>  //webView<br>  [FRRWebEngine startEngine];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、移除部分无用代码和类"><a href="#四、移除部分无用代码和类" class="headerlink" title="四、移除部分无用代码和类"></a>四、移除部分无用代码和类</h3><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><p> 之前直觉的就把第三方的初始化放到了 didFinishLaunchingWithOptions 方法里，我专门建了一个类来负责启动事件，区分开可以放在首屏显示之后再初始化的第三方库，以后再引入的时候就会判断一下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">/**<br><span class="hljs-bullet">* </span>这个类负责所有原来didFinishLaunchingWithOptions和+load中 延迟事件的加载，根据需要减少 didFinishLaunchingWithOptions 里耗时的操作.<br><span class="hljs-bullet">* </span>第一类: 比如日志 / 统计等需要第一时间启动的, 仍然放在 didFinishLaunchingWithOptions 中.<br><span class="hljs-bullet">* </span>第二类: 部分第三方库的启动、数据处理等业务，不需要放在didFinishLaunchingWithOptions中，延后至首屏显示之后<br>*/<br></code></pre></td></tr></table></figure><p>图片<br>启动难免会用到很多图，有没有办法优化图片加载的耗时呢？<br>用 Asset 管理图片而不是直接放在 bundle 里。Asset 会在编译期做优化，让加载的时候更快，此外在 Asset 中加载图片是要比 Bundle 快的，因为 UIImage imageNamed 要遍历 Bundle 才能找到图。加载 Asset 中图的耗时主要在在第一次张图，因为要建立索引，可以通过把启动的图放到一个小的 Asset 里来减少这部分耗时。</p><p>每次创建 UIImage 都需要 IO，在首帧渲染的时候会解码。所以可以通过提前子线程预加载（创建 UIImage）来优化这部分耗时。</p><p>有的启动只有到了比较晚的阶段“RootWindow 创建”和“首帧渲染”才会用到图片，<strong>所以可以在启动的早期开预加载的子线程启动任务</strong>。</p><h4 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h4><p>既然启动的路径上会触发大量的 Page In，那么有没有什么办法优化呢？</p><p>启动具有局部性特征，即只有少部分函数在启动的时候用到，这些函数在中的分布是零散的，所以 Page In 读入的数据利用率并不高。如果我们可以把启动用到的函数排列到二进制的连续区间，那么就可以减少 Page In 的次数，从而优化启动时间：</p><p>以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210506165054800.png" alt="image-20210506165054800" style="zoom: 67%;" /><p>链接器 ld 有个参数-order_file 支持按照符号的方式排列二进制。获取启动时候用到的符号主流有两种方式：</p><ul><li><p>静态扫描获取 +load 和 C++静态初始化，hook objc_msgSend 获取 Objective C 符号。</p></li><li><p>LLVM 函数插桩，灰度统计启动路径符号，用大多数用户的符号生成 order_file。</p></li></ul><p>Facebook 的 LLVM 函数插桩是针对 order_file 定制，并且代码也是他们自己给 LLVM 开发的，目前已经合并到 LLVM 主分支了。</p><p>![image-20210506165105863](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210506165105863.png)</p><p>Facebook 的方案更精细化，生成的 order_file 是最优解，但是工程量很大。抖音的方案<strong>不需要源码编译</strong>，<strong>不需要对现有编译环境和流程改造</strong>，侵入性最小，缺点就是只能覆盖 90%左右的符号。</p><p>- 灰度是任何优化都要利用好的一个阶段，因为很多新的优化方案存在不确定性，需要先在灰度上验证。</p><h3 id="非常规方案"><a href="#非常规方案" class="headerlink" title="非常规方案"></a>非常规方案</h3><p>其他启动时间统计工具、启动方法耗时检测工具、二进制重排、动态库懒加载</p><h4 id="动态库懒加载"><a href="#动态库懒加载" class="headerlink" title="动态库懒加载"></a>动态库懒加载</h4><p>最开始我们提到可以通过删代码的方式来减少代码量，那么有没有什么不减少代码总量，就可以减少启动时候要加载代码数量的方式呢？</p><ul><li>答案就是动态库懒加载。</li></ul><p>什么是懒加载的动态库呢？正常动态库都是会被主二进制直接或者间接链接的，那么这些动态库会在启动的时候加载。<strong>如果只打包进 App，不参与链接，那么启动的时候就不会自动加载，在运行时需要用到动态库里面的内容的时候，再手动懒加载</strong>。</p><p>懒加载动态库需要在编译期和运行时都进行改造，编译期的架构：</p><p><img src="https://static001.infoq.cn/resource/image/53/a2/53277be65a8882bfb437aef8fba065a2.png" alt="img"></p><p>像 A.framework 等动态库是懒加载的，因为并没有参与主二进制的直接 or 间接链接。动态库之间一定会有一些共同的依赖，把这些依赖打包成 Shared.framework 解决公共依赖的问题。</p><p>运行时通过<code>-[NSBundle load]</code>来加载，本质上调用的是底层的 <code>dlopen</code>。那么什么时候触发动态库手动加载呢？</p><p>动态库可以分成两种：业务和功能。<strong>业务就是 UI 的入口，可以把动态库加载的逻辑收敛到路由内部，这样外部其实并不知道动态库是懒加载的，也能更好地容错</strong>。功能库（比如上图的 QR.framework）会有些不一样，因为没有 UI 等入口，需要功能库自己维护 Wrapper：</p><ul><li><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210506165131007.png" alt="image-20210506165131007" style="zoom: 33%;" /></li><li>App 对 Wrapper 直接依赖，这样外部并不知道这个动态库是懒加载的</li><li>Wrapper 内部封装了动态调用逻辑，动态调用指的是通过 dlsym 等方式调用</li></ul><p>动态库懒加载除了启动加载的代码减少，还能长期防止业务增加代码引起启动劣化，因为业务的初始化在第一次访问的时候完成的。</p><p>这个方案还有其他优点，比如动态库化后本地编译时间会大幅度降低，对其他性能指标也有好处，缺点是会牺牲一定程度的包大小，但可以用段压缩等方式优化懒加载的动态库来打平这部分损耗。</p><h4 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h4><p>Background Fetch 可以隔一段时间把 App 在后台启动，对于时间敏感的 App（比如新闻）可以在后台刷新数据，这样能够提高 Feed 加载的速度，进而提升用户体验。</p><p>那么，这种类似“后台保活”的机制，为什么能提高启动速度呢？我们来看一个典型的 case：</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20210506165219913.png" alt="image-20210506165219913" style="zoom: 50%;" /><ol><li>系统在后台启动 App</li><li>时间长因为内存等原因，后台的 App 被 kill 了</li><li>这时候用户立刻启动 App，那么这次启动就是一次<strong>热启动</strong>，因为缓存还在</li><li>又一次系统在后台启动 App</li><li>这次用户在 App 在后台的时候点了 App，那么这次启动就是一次<strong>后台回前台</strong>，因为 App 仍然活着</li></ol><p>通过这两个典型的场景，可以看出来为什么 Background Fetch 能提高启动速度了：</p><ul><li><strong>提高热启动在冷启动的占比</strong></li><li><strong>后台启动回前台被定义为启动，因为用户的角度来说这就是一次启动</strong></li></ul><p>后台启动有一些要注意的点，<strong>比如日活，广告，甚至是 AB 进组逻辑都会受影响</strong>，需要做不少适配。往往需要启动器来支撑，因为正常启动在 didFinishLaunch 执行的任务，在后台启动的时候需要延迟到第一次回前台的时候再执行。</p><p>资料：</p><ul><li>1、去除没有用到的资源： <a href="https://github.com/tinymind/LSUnusedResources">https://github.com/tinymind/LSUnusedResources</a></li><li>2、利用AppCode：<a href="https://www.jetbrains.com/objc/">https://www.jetbrains.com/objc/</a> 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li><li>3、可借助第三方工具解析LinkMap文件： <a href="https://github.com/huanxsd/LinkMap">https://github.com/huanxsd/LinkMap</a> 生成LinkMap文件，可以查看可执行文件的具体组成</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OC接入swift</title>
    <link href="/2020/03/04/OC%E6%8E%A5%E5%85%A5swift/"/>
    <url>/2020/03/04/OC%E6%8E%A5%E5%85%A5swift/</url>
    
    <content type="html"><![CDATA[<h2 id="一、设置桥接文件"><a href="#一、设置桥接文件" class="headerlink" title="一、设置桥接文件"></a>一、设置桥接文件</h2><p>不管是objective-c调用swift，还是swift调用objective-c，都需要创建桥接文件，通过桥接文件实现两者的相互调用。<br>当我们引入oc或者swift进入另一个语言的项目的时候系统会提示是否自动创建桥接文件，此时可直接创建。<br>但除此之外我们也可以选择手动创建。此时需要我们在新建文件里选择<code>Header File</code>，点击确认创建桥接文件，桥接文件名字一般为：<code>ProjectName-Bridging-Header.h</code>。然后在<code>Build settings</code>里搜索bridging，找到<code>Objective-C Bridging Header</code>的选项，将该文件的路径填写进去，或者直接拉入。这里的路径最好选择相对路径的形式（<code>ProjectName/BridgingFileName.h</code>）。<br>ProjectName为你项目的项目名，BridgingFileName为桥接文件的名字。</p><h2 id="二、桥接方法"><a href="#二、桥接方法" class="headerlink" title="二、桥接方法"></a>二、桥接方法</h2><h3 id="oc项目调用swift文件"><a href="#oc项目调用swift文件" class="headerlink" title="oc项目调用swift文件"></a>oc项目调用swift文件</h3><p>oc项目针对swift文件会自动创建<code>ProjectName-Swift.h</code>文件，该文件不需要我们去做更改，所以当我们设置完桥接文件之后，只需要在要调用的文件处import该头文件即可，即：<code>import &lt;ProjectName-Swift.h&gt;</code>，其中ProjectName为该项目的工程名。引入该头文件后，即可调用Swift对应的类和方法。</p><p>注意点：<strong>引入的swift文件需要调用的类和方法需要进行修饰，然后oc项目才能调用</strong>。可使用@objcMembers直接修饰类，或者也可以使用@objc分别修饰想要调用给oc的方法和属性，然后oc项目就可调用swift的相关方法了。</p><h3 id="swift项目调用oc文件"><a href="#swift项目调用oc文件" class="headerlink" title="swift项目调用oc文件"></a>swift项目调用oc文件</h3><p>swift项目调用oc文件更为简单，只需要将oc类的头文件导入桥接文件即可，需要调用哪个oc文件就import哪个头文件（#import “ClassName.h”）进去。<br>swift项目调用oc的类和方法不需要引入头文件，所以设置完之后可以直接在swift中直接调用oc方法。</p><span id="more"></span><h2 id="OC调用Swift"><a href="#OC调用Swift" class="headerlink" title="OC调用Swift"></a>OC调用Swift</h2><p>简单说下OC调用Swift需要注意的点：</p><p>1.import $(SWIFT_MODULE_NAME)-Swift.h</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;OCAndSwift-Swift.h&quot;</span><br></code></pre></td></tr></table></figure><p>2.调用Swift类时，Swift类必须继承自NSObject</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SwiftClass</span>: <span class="hljs-type">NSObject</span> &#123; <span class="hljs-keyword">var</span> claseName = <span class="hljs-string">&quot;SwiftClass&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>3.调用Swift类的方法，属性时，Swift类的方法属性都必须加上@objc关键字</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@objc</span> var <span class="hljs-attribute">retrainConfirmBlock</span>: (() -&gt; Void)?<span class="hljs-variable">@objc</span> convenience <span class="hljs-built_in">init</span>()<br></code></pre></td></tr></table></figure><p>4.如果使用KVC，KVO等监听，需要对监听的属性加上dynamic关键字，因为Swift并不是动态派发的语言，dynamic关键字会让编译器进行动态分发而不是静态分发.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> orderNumber: <span class="hljs-type">NSNumber</span>?<br></code></pre></td></tr></table></figure><h2 id="Swift调用OC"><a href="#Swift调用OC" class="headerlink" title="Swift调用OC"></a>Swift调用OC</h2><p>Swift调用OC需要注意的点：</p><p>1.$(SWIFT_MODULE_NAME)-Bridging-Header.h引入OC类头文件.</p><p>2.OC类的相关属性及方法在Swift类中都可以直接调用，只需要注意Swift语法即可.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">UIView</span><span class="hljs-selector-class">.animate</span>(<span class="hljs-attribute">withDuration</span>: <span class="hljs-built_in">TimeInterval</span>(time), <span class="hljs-attribute">delay</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">options</span>: UIView.AnimationOptions.curveLinear, <span class="hljs-attribute">animations</span>: &#123;<span class="hljs-comment">// animate &#125;) &#123;(finish) in//finish&#125;</span><br></code></pre></td></tr></table></figure><p>3.OC类的多数基本类型如NSArray，NSDictionay，NSError等对象(Object) 都可以通过 as? 和Swift中的基础类型Array，Dictionary，Error等值类型互换.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> contentAry = info[<span class="hljs-string">&quot;content&quot;</span>] <span class="hljs-keyword">as</span>? [<span class="hljs-title class_">String</span>]titleLabel.<span class="hljs-property">text</span> = title <span class="hljs-keyword">as</span>? <span class="hljs-title class_">String</span> ?? <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> failedWith = error <span class="hljs-keyword">as</span>? <span class="hljs-title class_">Error</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>4.OC宏的使用，Swift使用OC的宏，只能直接使用非常简单的值类型宏，对于复杂的宏方法则需要自己重写一个全局方法替代，全局静态常量可以直接使用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kExpireTime 60  <span class="hljs-comment">// √</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sharedAppDelegate ((AppDelegate *)([UIApplication sharedApplication].delegate)) <span class="hljs-comment">// X</span></span><br></code></pre></td></tr></table></figure><h2 id="Swift特性"><a href="#Swift特性" class="headerlink" title="Swift特性"></a>Swift特性</h2><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>1.简单介绍一下Optional-可选类型，Optional实际上是一个枚举类型：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">Optional</span>&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123;<span class="hljs-keyword">case</span> nonecase some(Wrapped)...&#125;<br></code></pre></td></tr></table></figure><p>表示一个数据可能有值也可能为空即nil，类型可以用Optional或者T?（常用）表示.</p><p>2.如果一个可选类型有值，那么这个值也是被包装起来的，例如optional(“test”)，如果需要取出值就需要解包</p><p>解包方式有 if let 以及！，！表示强解，一般在确定值不为空的时候使用，否则会造成崩溃.</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-keyword">if</span> <span class="hljs-built_in">let</span> <span class="hljs-built_in">text</span> = OptionalText &#123;print(<span class="hljs-built_in">text</span>)&#125;<br><span class="hljs-built_in">let</span> <span class="hljs-built_in">text</span> = OptionalText!<br></code></pre></td></tr></table></figure><p>3.在与OC混编过程中，因为OC没有可选类型的概念，需要注意可选类型带来的问题.例如</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">offset</span>: <span class="hljs-type">CGFloat</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>,  <span class="hljs-params">text</span>: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>) &#123;<br><span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: .zero)<span class="hljs-keyword">self</span>.type <span class="hljs-operator">=</span> typeself.offset <span class="hljs-operator">=</span> offset&#125;<br></code></pre></td></tr></table></figure><p>这个方法如果想给OC调用则会报错</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">Method</span> <span class="hljs-title function_">cannot</span> <span class="hljs-title function_">be</span> <span class="hljs-title function_">marked</span> @<span class="hljs-title function_">objc</span> <span class="hljs-title function_">because</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">type</span> <span class="hljs-title function_">of</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">parameter</span> 1 <span class="hljs-title function_">cannot</span> <span class="hljs-title function_">be</span> <span class="hljs-title function_">represented</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">Objective</span>-<span class="hljs-title function_">C</span><br></code></pre></td></tr></table></figure><p>提示第一个参数无法用OC表示，因为在OC中CGFloat是值类型，不能为nil，而对于OC中的对象类型NSString （String自动转换）则可以接受.</p><p>另外，Swift使用OC定义类型时也要注意是否为可空类型</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSNumber</span> *number1;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">NSNumber</span> *number2;<br></code></pre></td></tr></table></figure><p>带nullable关键字的属性可以被Swift转为可选类型，但是不带nullable的属性则默认被！强解，这里需要注意使用OC网络数据等，如果不做判断可以会导致崩溃.</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是Swift中的一大利器，许多swift的标准库都是通过泛型代码构建的，例如数组和字典都是泛型集，在系统库或者一些知名三方库中，随处可见的Element，<T>，Where等等占位符或关键字，都是使用泛型在构建代码，引用一段Swift文档对于泛型的描述.</p><blockquote><p><em>Generic code</em> enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.</p><p>Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. In fact, you’ve been using generics throughout the <em>Language Guide</em>, even if you didn’t realize it. For example, Swift’s <code>Array</code> and <code>Dictionary</code> types are both generic collections. You can create an array that holds <code>Int</code> values, or an array that holds <code>String</code> values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be.</p></blockquote><p>概括泛型的关键字：自定义，任意类型，灵活，重用，清晰，抽象.篇幅关系，Swift泛型的应用以后再详细总结.</p><p>在Xcode7之后，为了“迎合”Swift，苹果对OC也做了许多提升，其中包括Nullability，轻量级泛型和__kindof等等，nullable上文我们提到过，可以在Swift使用OC属性时自动编译为Optional类型，那么在在泛型的混编上应该注意什么呢？</p><h4 id="1-OC种泛型的使用"><a href="#1-OC种泛型的使用" class="headerlink" title="1.OC种泛型的使用"></a>1.OC种泛型的使用</h4><p>在OC当中对泛型比较常用的方式，例如对数组元素类型的定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSArray</span>&lt;<span class="hljs-type">NSString</span> *&gt; <span class="hljs-operator">*</span>messageArray<br></code></pre></td></tr></table></figure><p>一方面可以限制集合类型，一方面可以直接使用点语法，并且在添加，遍历时会有类型提示.</p><h4 id="2-OC泛型的定义"><a href="#2-OC泛型的定义" class="headerlink" title="2.OC泛型的定义"></a>2.OC泛型的定义</h4><p>OC中2种自定义泛型定义：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__covariant</span>:协变, 子类转父类 <span class="hljs-variable">__contravariant</span>:逆变 父类转子类<br></code></pre></td></tr></table></figure><p>那么什么是协变，逆变呢，我们用一个例子来说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface Generic&lt;ObjectType&gt; : NSObject@end@interface ViewController ()@property (nonatomic, strong) Generic * generic;@property (nonatomic, strong) Generic&lt;NSString*&gt; * stringGeneric;@property (nonatomic, strong) Generic&lt;NSMutableString*&gt; * mutableGeneric;@end@implementation ViewController- (void)viewDidLoad &#123;    [super viewDidLoad];    self.generic = self.stringGeneric;    self.generic = self.mutableGeneric;    self.stringGeneric = self.generic;    self.stringGeneric = self.mutableGeneric; // Incompatible pointer types assigning to &#x27;Generic&lt;NSString*&gt; *&#x27; from &#x27;Generic&lt;NSMutableString*&gt; *&#x27;    self.mutableGeneric = self.generic;    self.mutableGeneric = self.stringGeneric; // Incompatible pointer types assigning to &#x27;Generic&lt;NSMutableString*&gt; *&#x27; from &#x27;Generic&lt;NSString*&gt; *&#x27;&#125;@end<br></code></pre></td></tr></table></figure><p>从代码警告我们可以看出：</p><ol><li>不指定泛型类型的对象generic可以和任意泛型类型对象转换.</li><li>指定了泛型类型的对象generic不能和不同泛型类型对象转换(只是警告).</li></ol><p>如果你需要主动控制转换关系则需要添加 __covariant 或 __contravariant，效果如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@interface</span> <span class="hljs-title class_">Generic</span>&lt;__covariant <span class="hljs-title class_">ObjectType</span>&gt; : <span class="hljs-title class_">NSObjectself</span>.stringGeneric = <span class="hljs-variable language_">self</span>.mutableGeneric; <span class="hljs-regexp">//</span> 子类转父类<span class="hljs-variable language_">self</span>.mutableGeneric = <span class="hljs-variable language_">self</span>.stringGeneric; <span class="hljs-regexp">//</span> <span class="hljs-title class_">Incompatible</span> pointer types assigning to <span class="hljs-string">&#x27;Generic&lt;NSMutableString*&gt; *&#x27;</span> from <span class="hljs-string">&#x27;Generic&lt;NSString*&gt; *&#x27;</span><br><span class="hljs-variable">@interface</span> <span class="hljs-title class_">Generic</span>&lt;__contravariant <span class="hljs-title class_">ObjectType</span>&gt; : <span class="hljs-title class_">NSObjectself</span>.stringGeneric = <span class="hljs-variable language_">self</span>.mutableGeneric; <span class="hljs-regexp">//</span> <span class="hljs-title class_">Incompatible</span> pointer types assigning to <span class="hljs-string">&#x27;Generic&lt;NSString*&gt; *&#x27;</span> from <span class="hljs-string">&#x27;Generic&lt;NSMutableString*&gt; *&#x27;</span><span class="hljs-variable language_">self</span>.mutableGeneric = <span class="hljs-variable language_">self</span>.stringGeneric; <span class="hljs-regexp">//</span> 父类转子类<br></code></pre></td></tr></table></figure><h4 id="3-OC泛型在Swift中的使用"><a href="#3-OC泛型在Swift中的使用" class="headerlink" title="3.OC泛型在Swift中的使用"></a>3.OC泛型在Swift中的使用</h4><p>1.OC中定义的泛型，在Swift中使用时，必须指定泛型类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> g <span class="hljs-operator">=</span> <span class="hljs-type">Generic</span>&lt;<span class="hljs-type">AnyObject</span>&gt;()<br></code></pre></td></tr></table></figure><p>2.使用泛型类型的子类时，如果想要使用父类的方法或属性，建议先使用as转换类型，获取到方法列表或属性列表后，再把as去掉，因为子类无法直接获取到父类的方法属性列表，有点坑.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> gChild = GenericChild&lt;AnyObject&gt;<span class="hljs-literal">()</span>(gChild <span class="hljs-keyword">as</span> GenericChild&lt;AnyObject&gt;).generic<span class="hljs-constructor">Func()</span>gChild.generic<span class="hljs-constructor">Func()</span><br></code></pre></td></tr></table></figure><p>3.swift并不吃OC泛型的协变，逆变这一套，它只有一个基本原则：类型固定.只要你在初始化时说明了对象的泛型类型，那么他不管怎么转换类型，指针赋值，始终只能转换为他自己的类型.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> gString <span class="hljs-operator">=</span> <span class="hljs-type">Generic</span>&lt;<span class="hljs-type">NSString</span>&gt;()<br><span class="hljs-keyword">var</span> gMutableString <span class="hljs-operator">=</span> <span class="hljs-type">Generic</span>&lt;<span class="hljs-type">NSMutableString</span>&gt;()<br>gMutableString <span class="hljs-operator">=</span> gString <span class="hljs-keyword">as!</span> <span class="hljs-type">Generic</span>&lt;<span class="hljs-type">NSMutableString</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="4-Swift泛型在OC中的使用"><a href="#4-Swift泛型在OC中的使用" class="headerlink" title="4.Swift泛型在OC中的使用"></a>4.Swift泛型在OC中的使用</h4><p>不行（可以查看一下$(SWIFT_MODULE_NAME)-Swift.h中是没有将Swift泛型类编译成OC类的哦）.</p><h3 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h3><p>1.OC中的blcok与Swift中closure都是经常使用的代码类型，Swift调用OC block会自动转化为closure类型.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">void</span> (^completionBlock)(<span class="hljs-built_in">NSData</span> *, <span class="hljs-built_in">NSError</span> *) = ^(<span class="hljs-built_in">NSData</span> *data,<span class="hljs-built_in">NSError</span> *error) &#123;<span class="hljs-comment">/* ... */</span>&#125;<br>let completionBlock: (<span class="hljs-built_in">NSData</span>, <span class="hljs-built_in">NSError</span>) -&gt; Void = &#123;data, errorin <span class="hljs-comment">/* ... */</span>&#125;<br></code></pre></td></tr></table></figure><p>2.Swift中closure和function是同一种类型，所以可以将Swift的方法名作为block参数传递给OC.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> completionBlock: (<span class="hljs-type">NSData</span>, <span class="hljs-type">NSError</span>) -&gt; <span class="hljs-type">Void</span> <span class="hljs-operator">=</span> &#123;data, error    <span class="hljs-keyword">in</span> <span class="hljs-comment">/* ... */</span>&#125;<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">completionBlockFunc</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">data</span>:<span class="hljs-type">NSData</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">error</span>:<span class="hljs-type">NSError</span>) -&gt; <span class="hljs-type">Void</span> &#123;        <span class="hljs-comment">/* ... */</span>    &#125;<br></code></pre></td></tr></table></figure><p>3.block默认截获变量，如果需要截获引用，则需要加上__block关键字，closure默认截获变量的指针，也就是说closure默认就添加了__block关键字，但是在变量没有改变的情况下，closure会做优化只持有变量的值而不是指针.</p><blockquote><p>As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by or outside a closure.</p></blockquote><p>4.循环引用及Weak-Strong Dance</p><p>OC中未避免循环引用，会对持有对象做weak处理，Swift中修饰对象为弱引用有2种方式.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 对此对象进行弱引用，此对象引用计数不会增加，修饰的对象为可选类型weak var object// 对此对象进行弱引用，此对象引用计数不会增加，修饰的对象不能为nilunowned </span><br><span class="hljs-keyword">var</span> objectself.closure <span class="hljs-operator">=</span> &#123;    [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>    <br><span class="hljs-comment">// self 不能为空，否则会造成崩溃   </span><br><span class="hljs-keyword">self</span>.viewDidLoad() <br>&#125;<br><span class="hljs-keyword">self</span>.closure <span class="hljs-operator">=</span> &#123;     [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>     <span class="hljs-comment">// self 是可选类型，此处可以解包self  </span><br><span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.viewDidLoad()&#125;<br></code></pre></td></tr></table></figure><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>OC中NS_ENUM枚举定义和Swift中的Enum默认是相互转化的，但是秉着简洁清晰的代码原则，Swift把OC中枚举类型名称给yan割了，例如</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_ENUM</span>(<span class="hljs-type">NSInteger</span>, <span class="hljs-type">UITableViewCellStyle</span>) &#123; <span class="hljs-type">UITableViewCellStyleDefault</span>, <span class="hljs-type">UITableViewCellStyleValue1</span>, <span class="hljs-type">UITableViewCellStyleValue2</span>, <span class="hljs-type">UITableViewCellStyleSubtitle</span>&#125;;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">enum</span> UITableViewCellStyle: <span class="hljs-built_in">Int</span> &#123;    <span class="hljs-keyword">case</span> <span class="hljs-literal">Default</span>    <span class="hljs-keyword">case</span> Value1    <span class="hljs-keyword">case</span> Value2    <span class="hljs-keyword">case</span> Subtitle&#125;<br></code></pre></td></tr></table></figure><p>Swift用点语法来使用枚举：（许多系统的枚举类也被改了，如果不知道怎么写，可以把OC的系统枚举写上，会有错误提示帮你更正）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cellStyle</span>: UITableViewCellStyle = .<span class="hljs-built_in">Default</span><br></code></pre></td></tr></table></figure><p>Swift中的枚举比起OC来强大了很多，OC中的枚举只能定义类型，但是Swift中的枚举可以添加方法和属性，类似于Struct，可以实现很多自定义的功能.</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">enum NDDErrCode: Int, CustomStringConvertible &#123;    <span class="hljs-keyword">case</span> success = <span class="hljs-number">0</span>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">fail</span>    <span class="hljs-keyword">case</span> noData    <span class="hljs-keyword">case</span> noMoreData    <span class="hljs-built_in">var</span> description: <span class="hljs-built_in">String</span> &#123;        switch <span class="hljs-built_in">self</span> &#123;        <span class="hljs-keyword">case</span> .success:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>        <span class="hljs-keyword">case</span> .<span class="hljs-keyword">fail</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;失败&quot;</span>        <span class="hljs-keyword">case</span> .noData:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;没有数据&quot;</span>        <span class="hljs-keyword">case</span> .noMoreData:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;没有更多数据&quot;</span>        &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>OC中Protocol更倾向于代理功能，由Protocol协议，代理对象delegate以及委托者组成，主要用于事件回调，页面传值等功能；</p><p>Swift中的Protocol更多的是面向协议编程，指抽象出不同类的相同行为（方法），特点（属性）等等，实现模块化解耦.还可以通过extension，实现协议的默认方法（OC不行），也无需生命代理对象等.</p><p>Swift调用OC的Protocol和调用方法一样，OC调用Swift协议时，需要注意创建Protocol时，@objc，optional等关键字和协议类型（any，class，anyObject）等协议遵循限制.</p><h4 id="RAC-and-RxSwift"><a href="#RAC-and-RxSwift" class="headerlink" title="RAC and RxSwift"></a>RAC and RxSwift</h4><p>Swift可以使用RAC（不建议，毕竟有正宫娘娘RxSwift），除了语法外，需要注意RAC大部分类也是OC泛型，需要类型转换以获取父子类方法及属性列表.</p><p>OC无法使用RxSwift.</p><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>OC单例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-keyword">instancetype</span>)sharedInstance &#123;    <span class="hljs-keyword">static</span> Singleton *shared = <span class="hljs-literal">nil</span>;    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;        shared = [[Singleton alloc] init];    &#125;);    <span class="hljs-keyword">return</span> _shared;&#125;<br></code></pre></td></tr></table></figure><p>Swift单例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> sharedInstance = Singleton()<br></code></pre></td></tr></table></figure><h4 id="json转模型"><a href="#json转模型" class="headerlink" title="json转模型"></a>json转模型</h4><p>OC中常用json转对象工具MJExtension，Swift中常用工具较多，如HandyJson，ObjectMapper等等，另外Swift4引入的Codable协议也是非常方便的.</p><h4 id="OC变参方法"><a href="#OC变参方法" class="headerlink" title="OC变参方法"></a>OC变参方法</h4><p>OC的变参方法无法直接在Swift中被调用，需要对变参方法进行修改，使用va_list对变参进行拼接.</p><p>原方法</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">+ (<span class="hljs-literal">void</span>)stringParams:(NSString *)<span class="hljs-keyword">params</span>,<span class="hljs-params">...</span>;<br></code></pre></td></tr></table></figure><p>重写方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">void</span>) stringParams:(<span class="hljs-built_in">NSString</span> *)params args:(va_list)args &#123;    va_list args_copy;    __va_copy(args_copy,args);    <span class="hljs-built_in">NSMutableString</span>* format = [<span class="hljs-built_in">NSMutableString</span> stringWithString:<span class="hljs-string">@&quot;&quot;</span>];    <span class="hljs-keyword">while</span> (va_arg(args, <span class="hljs-built_in">NSString</span>*))    &#123;        [format appendString:<span class="hljs-string">@&quot;%@,&quot;</span>];    &#125;    va_end(args);    <span class="hljs-keyword">if</span>(format.length&gt;<span class="hljs-number">0</span>)        [format deleteCharactersInRange:<span class="hljs-built_in">NSMakeRange</span>(format.length<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)];    <span class="hljs-built_in">NSString</span>* newFormat = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@&quot;</span>,format];    <span class="hljs-built_in">NSString</span> * result = [[<span class="hljs-built_in">NSString</span> alloc]initWithFormat:newFormat arguments:args_copy];    va_end(args_copy);    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, result);&#125;<br></code></pre></td></tr></table></figure><p>swift调用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> args: <span class="hljs-literal">[CV<span class="hljs-identifier">arArg</span>]</span> = <span class="hljs-literal">[&quot;<span class="hljs-identifier">i</span>&#x27;<span class="hljs-identifier">m</span>&quot;, &quot; <span class="hljs-identifier">funny</span>&quot;]</span>        <span class="hljs-keyword">with</span><span class="hljs-constructor">VaList(<span class="hljs-params">args</span>)</span> &#123;                (pointer: CVaListPointer) <span class="hljs-keyword">in</span>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewController</span>.</span></span><span class="hljs-built_in">string</span><span class="hljs-constructor">Params(<span class="hljs-string">&quot;%@,%@&quot;</span>, <span class="hljs-params">args</span>: <span class="hljs-params">pointer</span>)</span>                &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遇见多线程问题记录</title>
    <link href="/2020/02/21/%E9%81%87%E8%A7%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/02/21/%E9%81%87%E8%A7%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NSNotification"><a href="#1-NSNotification" class="headerlink" title="1. NSNotification"></a>1. NSNotification</h2><p>我们都知道，NSNotification 在哪个线程 post，最终就会在哪个线程执行。如果我们不是在主线程 post 的，但是却在主线程接收的，而且我们期望 selector 在主线程执行。这时候我们需要注意下，在 selector 需要 dispatch 到主线程才可以。当然你也可以使用 addObserverForName:object:queue:usingBlock: 来指定执行 block 的 queue。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BLPostNotification</span></span><br><br>- (<span class="hljs-type">void</span>)postNotification &#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;com.bool.post.notification&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>        <span class="hljs-comment">// 从非主线程发送通知 （通知名字最好定义成一个常量）</span><br>        [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="hljs-string">@&quot;downloadImage&quot;</span> object:<span class="hljs-literal">nil</span>];<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ImageViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(show) name:<span class="hljs-string">@&quot;downloadImage&quot;</span> object:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)showImage &#123;<br>    <span class="hljs-comment">// 需要 dispatch 到主线程更新 UI</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-comment">// update UI</span><br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h2 id="2-NSTimer"><a href="#2-NSTimer" class="headerlink" title="2. NSTimer"></a>2. NSTimer</h2><p>使用 NSTimer 时，在哪个线程生成的 timer，就在哪个线程销毁，否则会有意想不到的结果。官方这样描述的：</p><blockquote><p>However, for a repeating timer, you must invalidate the timer object yourself by calling its invalidate method. Calling this method requests the removal of the timer from the current run loop; as a result, you should always call the invalidate method from the same thread on which the timer was installed.</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">BLTimerTest</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> queue;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSTimer</span> *timer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BLTimerTest</span></span><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _queue = dispatch_queue_create(<span class="hljs-string">&quot;com.bool.timer.test&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)installTimer &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.queue, ^&#123;<br>        <span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">3.0</span>f repeats:<span class="hljs-literal">YES</span> block:^(<span class="hljs-built_in">NSTimer</span> * _Nonnull timer) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;test timer&quot;</span>);<br>        &#125;];<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)clearTimer &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.queue, ^&#123;<br>        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.timer isValid]) &#123;<br>            [<span class="hljs-keyword">self</span>.timer invalidate];<br>            <span class="hljs-keyword">self</span>.timer = <span class="hljs-literal">nil</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h2 id="3-Dispatch-Once-死锁"><a href="#3-Dispatch-Once-死锁" class="headerlink" title="3. Dispatch Once 死锁"></a>3. Dispatch Once 死锁</h2><p>在开发中，我们经常使用 dispatch_once，但是递归调用会造成死锁。例如下面这样：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)dispatchOnceTest &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        [<span class="hljs-keyword">self</span> dispatchOnceTest];<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于为什么会死锁，上文介绍 Dispatch Once 的时候已经说明了，这里就不多做介绍了。提醒一下使用的时候要注意，不要造成递归调用。</p><h2 id="4-Dispatch-Group"><a href="#4-Dispatch-Group" class="headerlink" title="4. Dispatch Group"></a>4. Dispatch Group</h2><p>在使用 dispatch_group 的时候，dispatch_group_enter(taskGroup) 和 dispatch_group_leave(taskGroup) 一定要成对，否则也会出现崩溃。大多数情况下我们都会注意，但是有时候可能会疏忽。例如多层 for loop 时 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)testDispatchGroup &#123;<br>    <span class="hljs-built_in">NSString</span> *path = <span class="hljs-string">@&quot;&quot;</span>;<br>    <span class="hljs-built_in">NSFileManager</span> *fileManager = [<span class="hljs-built_in">NSFileManager</span> defaultManager];<br>    <span class="hljs-built_in">NSArray</span> *folderList = [fileManager contentsOfDirectoryAtPath:path error:<span class="hljs-literal">nil</span>];<br>    dispatch_group_t taskGroup = dispatch_group_create();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *folderName <span class="hljs-keyword">in</span> folderList) &#123;<br>        dispatch_group_enter(taskGroup);<br>        <span class="hljs-built_in">NSString</span> *folderPath = [<span class="hljs-string">@&quot;path&quot;</span> stringByAppendingPathComponent:folderName];<br>        <span class="hljs-built_in">NSArray</span> *fileList = [fileManager contentsOfDirectoryAtPath:folderPath error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *fileName <span class="hljs-keyword">in</span> fileList) &#123;<br>            <span class="hljs-built_in">dispatch_async</span>(_queue, ^&#123;<br>                <span class="hljs-comment">// 异步任务</span><br>                dispatch_group_leave(taskGroup);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的 dispatch_group_enter(taskGroup) 在第一层 for loop 中，而 dispatch_group_leave(taskGroup) 在第二层 for loop 中，两者的关系是一对多，很容造成崩溃。有时候嵌套层级太多，很容易忽略这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存泄漏检测工具</title>
    <link href="/2020/01/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/01/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>我们在编写日常业务代码时，或多或少都会引入一些导致内存泄漏的代码，而这种行为又很难被监控，这就导致应用内存泄漏的口子越开越大，直接影响到线上应用的稳定性。虽然 Xcode 的 Instrucment 提供了 Leaks 和 Allocations 工具让我们能精准地定位内存泄漏问题，但是这种方式相对比较繁琐，需要开发人员频繁地去操作应用界面，以触发泄漏场景，所以 Leaks 和 Allocations 更加适合定期组织的大排查，作为监测手段，则显得笨重。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于内存泄漏的监测，业内已经有了两款成熟的开源工具，分别是 PLeakSniffer 和 MLeaksFinder。PLeakSniffer 使用 Ping-Pong 方式监测对象是否存活，在进入页面时，创建控制器关联的一系列对象代理，根据这些代理在控制器销毁时能否响应 Ping 判断代理对应的对象是否泄漏。MLeaksFinder 则是在控制器销毁时，延迟 3s 后再向监测对象发送消息，根据监测对象能否响应消息判断其是否泄漏。这两个方案基本能覆盖大部分对象泄漏或者延迟释放了的场景，考虑到性能损耗以及内存占用因素，我偏向于第二种方案。</p><p>下面说下在实际试用这两款工具后，我遇到的部分问题。</p><p>首先是 MLeaksFinder ：</p><ul><li>没有处理集合对象</li><li>没有处理对象持有的属性</li><li>每个对象都触发 3s 延迟机制，没有缓存后统一处理</li><li>检测结果输出分散</li></ul><p>然后是 PLeakSniffer ：</p><ul><li>没有处理集合对象</li><li>处理对象持有属性时，系统类过滤不全面</li><li>处理对象持有属性时，通过 KVC 访问属性导致一些懒加载的触发</li><li>无法处理未添加到视图栈中的泄漏视图</li><li>检测结果输出分散</li></ul><p>对于检测到泄漏对象的交互处理，两者都提供了终端 log 输出和 alert 提示功能，MLeaksFinder 甚至可以直接通过断言中断应用。这种提示在开发阶段尚可接受，但是在提测阶段，强交互会给测试人员造成困扰。至于为什么在提测阶段还要集成泄漏监测工具，主要有两个原因：</p><ul><li>应用功能过多的情况下，开发人员无法兼顾到老页面，一些老页面的泄漏场景可以通过测试人员在测试时触发，收集之后再统一处理</li><li>在组件化开发环境下，开发人员可能并没有集成泄漏监测工具，这种情况下，需要在提测阶段统一收集没有解决的泄漏问题</li></ul><p>所以我目前对于监测输出的诉求有两点：</p><ul><li>开发时，通过终端日志提示开发者出现了内存泄漏</li><li>提测时，收集内存泄漏的信息并上传至效能后台，周会时统一分配处理</li></ul><p>下面就针对这些调研和需求，打造一个符合自身业务场景的泄漏监测轮子。</p><h2 id="监测入口"><a href="#监测入口" class="headerlink" title="监测入口"></a>监测入口</h2><p>和 MLeaksFinder 一样，我选择延迟 3s 的机制来判断对象是否泄漏，但是实现的细节略有差别。</p><p>首先，监测入口变更为 <code>viewDidDisappear:</code> 方法，我们只需在控制器被父控制器中移除或者被 Dismissed 时，触发监测动作即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)LeaksMonitor_viewDidDisappear:(<span class="hljs-type">BOOL</span>)animated &#123;<br>    [<span class="hljs-keyword">self</span> LeaksMonitor_viewDidDisappear:animated];<br>    <br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> isMovingFromParentViewController] &amp;&amp; ![<span class="hljs-keyword">self</span> isBeingDismissed]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    [[TDFLeaksMonitor shared] detectLeaksForObject:<span class="hljs-keyword">self</span>];<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><p>在我们的应用中，还有一种监测入口出现在变更根控制器时，由于直接设置根控制器不会触发 viewDidDisappear 方法，所以需要另外设置 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)LeaksMonitor_setRootViewController:(<span class="hljs-built_in">UIViewController</span> *)rootViewController &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.rootViewController &amp;&amp; ![<span class="hljs-keyword">self</span>.rootViewController isEqual:rootViewController]) &#123;<br>        [[TDFLeaksMonitor shared] detectLeaksForObject:<span class="hljs-keyword">self</span>.rootViewController];<br>    &#125;<br>    <br>    [<span class="hljs-keyword">self</span> LeaksMonitor_setRootViewController:rootViewController];<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，为了能够统一处理控制器及其持有对象，我们可以像 PLeakSniffer 一样，给每个对象包装一层代理 ：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">TDFLeakObjectProxy </span>: NSObject<br><span class="hljs-comment">// 持有 target 的对象弱引用</span><br><span class="hljs-variable">@property</span> (weak, nonatomic) id host;<br><span class="hljs-comment">// 被 host 持有的对象弱引用</span><br><span class="hljs-variable">@property</span> (weak, nonatomic, readonly) id target;<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p>只要 host 释放了而 target 没释放，则视 target 已泄漏，如果 host 未释放，则不检测 target。然后使用一个 collector 去收集这些对象对应的 proxy ，在收集完之后统一监测 collector 中的所有 proxy ，这样就可以在一个控制器监测完成后，统一上传监测出的泄漏点了 ：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- (<span class="hljs-keyword">void</span>)detectLeaksForObject:(id &lt;TDFLeakObjectProxyCollectable&gt;)<span class="hljs-built_in">object</span> &#123;<br>    <span class="hljs-comment">// 收集控制器关联的所有 proxy</span><br>    <span class="hljs-comment">// 收集之后再统一处理，避免对每一个对象都进行 3s 检测</span><br>    TDFLeakObjectProxyCollector *collector = [[TDFLeakObjectProxyCollector alloc] <span class="hljs-keyword">init</span>];<br>    TDFLeakContext *context = [[TDFLeakContext alloc] <span class="hljs-keyword">init</span>];<br>    context.host = <span class="hljs-built_in">object</span>;<br>    <br>    (<span class="hljs-keyword">void</span>)[<span class="hljs-built_in">object</span> LeaksMonitor_collectProxiesForCollector:collector withContext:context];<br>    <br>    <span class="hljs-comment">// 检测 3s 之后，collector 中的所有 proxy 是否正常</span><br>    [<span class="hljs-meta">self detectProxyCollector:collector</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="收集对象信息"><a href="#收集对象信息" class="headerlink" title="收集对象信息"></a>收集对象信息</h2><p>因为要对不同的类做特异化处理，所以这里我们先定义一个协议，通过这个协议中的 collect 方法去收集不同类实例化对象的 proxy ：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@protocol</span> TDFLeakObjectProxyCollectable &lt;NSObject&gt;<br>/**<br> 收集对象及其名下的所有成员变量对应的 proxy<br><br> <span class="hljs-keyword">@param</span> collector 收集器，存储 proxy<br> <span class="hljs-keyword">@param</span> ctx 上下文<br> */<br>- (void)LeaksMonitor_<span class="hljs-attribute">collectProxiesForCollector</span>:( TDFLeakObjectProxyCollector * _Nonnull )collector <span class="hljs-attribute">withContext</span>:( TDFLeakContext * _Nullable )ctx;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这里的关键点在于如何让 NSObject 实现此协议，主要有四个步骤 ：</p><ul><li>过滤系统类调用</li><li>向 collector 添加封装的 proxy</li><li>循环遍历对象对应的非系统类 &#x2F; 父类属性，找出 copy &#x2F; strong 类型属性，并获取其对应的成员变量值</li><li>向收集的所有成员变量对象发送 collect 方法</li></ul><p>NSObject 实现 collect 协议方法后，其子类就可以通过这个方法递归地收集名下需要监测的属性信息。比如对于集合类型 NSArray ，实现协议方法如下，表示收集自身和每个集合元素的信息，不过由于 NSArray 是系统类，所以其实例化对象并不会被收集进 collector ，如果要收集系统类的属性信息，只能通过让系统类实现协议并重载 collect 方法，手动向属性值发送 collect 消息实现，UIViewController 的 <code>childViewControllers</code>、<code>presentedViewController</code>、<code>view</code> 属性也同理 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)LeaksMonitor_collectProxiesForCollector:(TDFLeakObjectProxyCollector *)collector withContext:(TDFLeakContext *)ctx &#123;<br>    [<span class="hljs-variable language_">super</span> LeaksMonitor_collectProxiesForCollector:collector withContext:ctx];<br>    <br>    [<span class="hljs-keyword">self</span> enumerateObjectsUsingBlock:^(<span class="hljs-type">id</span>  _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-type">BOOL</span> * _Nonnull stop) &#123;<br>        <span class="hljs-keyword">if</span> ([obj conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">TDFLeakObjectProxyCollectable</span>)]) </span>&#123;<br>            [obj LeaksMonitor_collectProxiesForCollector:collector withContext:LM_CTX_D(ctx, <span class="hljs-string">@&quot;contains&quot;</span>)];<br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，直接调用属性的 getter 方法获取属性值，可能会触发属性懒加载，导致出现意料之外的问题 (比如调用 UIViewController 的 view 会触发 viewDidLoad)，所以要通过 <code>object_getIvar</code> 去获取属性对应的成员变量值。当然，这种处理方式会导致无法收集某些没有对应成员变量值的属性，比如关联对象、控制器的 view 等属性，权衡利弊之后，我还是选择忽略这种属性的监测。</p><p>除了收集必要的对象信息之外，我还记录了监测对象的引用路径信息，也就是上面 <code>LM_CTX_D</code> 宏做的事情。有些情况下，对象的引用路径能帮助我们发现，路径上的哪些操作导致了对象的泄漏，特别是在网页上浏览泄漏信息时，如果只有泄漏对象类和引用泄漏对象类两个信息，脱离了对象泄漏时的上下文环境，会增加修复的难度。有了引用路径信息后，输出的泄漏信息如下 ：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">[<br>  O : TDFV<span class="hljs-function"><span class="hljs-title">iewController</span>.view-&gt;</span>UIV<span class="hljs-function"><span class="hljs-title">iew</span>.subviews-&gt;</span>__NSA<span class="hljs-function"><span class="hljs-title">rrayM</span>(<span class="hljs-built_in">contains</span>)-&gt;</span>A.<span class="hljs-function"><span class="hljs-title">subviews</span>-&gt;</span>__NSA<span class="hljs-function"><span class="hljs-title">rrayM</span>(<span class="hljs-built_in">contains</span>)-&gt;</span>O<br>  TDFV<span class="hljs-function"><span class="hljs-title">iewController</span> : TDFViewController.childViewControllers-&gt;</span>TDFViewController<br>  __NSCFT<span class="hljs-function"><span class="hljs-title">imer</span> : TDFViewController.timer-&gt;</span>__NSCFTimer<br>]<br></code></pre></td></tr></table></figure><h2 id="过滤系统类"><a href="#过滤系统类" class="headerlink" title="过滤系统类"></a>过滤系统类</h2><p>系统类信息并不是我们应该关心的，过滤掉并不会影响到最终的监测结果。目前我尝试了两种方式来确定一个类是否为系统类：</p><ul><li>通过类所在 NSBundle 的路径</li><li>通过类所在地址</li></ul><p>先说第一种，这种方式逻辑较为简单，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">BOOL</span> LMIsSystemClass(Class cls) &#123;<br>    <span class="hljs-built_in">NSBundle</span> *bundle = [<span class="hljs-built_in">NSBundle</span> bundleForClass:cls];<br>    <span class="hljs-keyword">if</span> ([bundle isEqual:[<span class="hljs-built_in">NSBundle</span> mainBundle]]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *embededDirPath;<br>    <span class="hljs-keyword">if</span> (!embededDirPath) &#123;<br>        embededDirPath = [[<span class="hljs-built_in">NSBundle</span> mainBundle].bundleURL URLByAppendingPathComponent:<span class="hljs-string">@&quot;Frameworks&quot;</span>].absoluteString;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ![bundle.bundlePath hasPrefix:embededDirPath];<br>&#125;<br></code></pre></td></tr></table></figure><p>应用的主二进制文件，和开发者添加的 embeded frameworks 都会在固定的文件目录下，所以直接比对路径前缀即可。</p><p>接下来说说第二种，这种方式的实现步骤如下：</p><ul><li>遍历所有的 image ，通过 image 的名称判断是否为系统 image</li><li>缓存所有系统 image 的起始位置，也就是 mach_header 的地址</li><li>判断类是否为系统类时，使用 dladdr 函数获取类所在 image 的信息，通过 dli_fbase 字段获取起始地址</li><li>比对 image 的起始地址得知是否为系统类</li></ul><p>实际尝试下来后，发现第二种方式耗时会比第一种多，dladdr 函数占用了大部分时间，所以最终选择了第一种方式作为判断依据。</p><p>过滤系统类时，针对那种会自泄漏的对象，需要进行特殊处理，不予过滤。比如 NSTimer &#x2F; CADisplayLink 对象的常见内存泄漏场景，除了 target 强引用控制器造成循环引用域外，还有一种是打破了循环引用但没有在控制器销毁时执行 <code>invalidate</code> 操作，因为 NSTimer 由 RunLoop 持有，不手动停止的情况下，就会造成泄漏。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>基于延时的内存泄漏监测机制虽然适用于大部分视图、控制器和一般属性的泄漏场景，但是还有少部分情况，这种机制无法处理，比如单例对象和共享对象。</p><p>首先说下单例对象，假设有 singleton 属性，其 getter 方法返回 Singleton 单例，这时延时监测机制无法自动过滤这种情况，依然会认为 singleton 泄漏了。有一种检测属性返回值是否为单例的方法，就是向返回值对应类发送 init 或者 share 相关方法，通过方法返回值和属性返回值的对比结果来判断，但是事实上我们无法确定业务方的单例是否重写了 init，也无法获知具体的单例类方法，所以这种方案适用面比较局限。单例对象的处理，目前还是通过白名单的方式处理较为稳妥。</p><p>共享对象的应用场景就比较普遍了，比如现有 A，B 页面，A 页面持有模型 M ，在跳转至 B 页面时，会将 M 传递给 B ，B 强引用了 M ，当 B 销毁时， M 不会销毁，而 M 又是 B 某个属性的值，所以监测机制会判断 M 泄漏了，实际上 M 只是 A 传递给 B 的共享对象。在一个控制器做完检测就需要上传至效能后台的情况下，共享对象还没有很好的处理方法，后期考虑结合 FBRetainCycleDetector 查找泄漏对象的循环引用信息，然后一并上传至效能后台，方便排查这种情况。因为每次 pop 都使用 FBRetainCycleDetector 检测控制器会比较耗时、甚至会造成延迟释放和卡顿，所以先用延时机制找出潜在的泄漏对象，再使用 FBRetainCycleDetector 检测这些泄漏对象，能极大得减少需要处理的对象数量。最终网页呈现的效果如下：</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>像内存泄露这种问题，最好在应用初期就开始着手监测和解决，否则当应用功能代码逐渐增多后，回过头来处理这种问题费时费力，还是比较麻烦的。</p><p>本文基于 PLeakSniffer 和 MLeaksFinder 监测工具的基础上，结合团队业务情况，进行了一些的改造，添加了集合对象的处理、引用路径的记录、对象的统一检测等功能，优化了部分有问题的代码，在一定程度上提升了延时机制的可用性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Tree</title>
    <link href="/2020/01/17/Flutter-Tree/"/>
    <url>/2020/01/17/Flutter-Tree/</url>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/12/17/vh2TFclGnkx1mDC.png" alt="2020-12-17-5.47.46.png"></p><p>我们也可以看到上图中每个控件所形成的树结构中隐含了一些关系，例如在上图中，我们可以说 Text 组件是 Column 组件的子组件，Scaffold 是 AppBar 的父组件，这样的层级关系使得每个控件都清晰的连接到了一起，树结构由此而来（俄罗斯套娃）。</p><p>在 Flutter 中，Container、Text 等组件都属于 Widget，所以我们将这种树称为 Widget 树，也可以叫做控件树，它就表示了我们在 dart 代码中所写的控件的结构。</p><p><img src="https://i.loli.net/2020/12/17/aI3GmoWswkR1dHr.png" alt="2020-12-17-5.47.54.png"></p><p>然而，在 Flutter 体系结构中，真正做组件渲染在屏幕上这个任务的并非在 控件层（Widget）层，而是在渲染（Rendering）层，那么我们在代码中所写组件又是怎么通过渲染层显示的呢？Flutter 中又引入了 Element 树和 RenderingObject 树两棵树。</p><p>Element 是什么，我们可以把它称之为 Widget 另一种抽象。读者也可以把它看作一个更为实际控件，因为在我们的手机屏幕上显示的控件并非我们在代码中所写的 Widget，我们在代码中所使用的像 Container、Text 等这类组件和其属性只不过是我们想要构建的组件的配置信息，当我们第一次调用 <code>build()</code> 方法想要在屏幕上显示这些组件时，Flutter 会根据这些信息生成该 Widget 控件对应的 Element，同样地，Element 也会被放到相应的 Element 树当中。在 Flutter 中，一个 Widget 通过多次复用可以对应多个 Element 实例，Element 才是我们真正在屏幕上显示的元素。</p><blockquote><p>Element 与 Widget 另一个区别在于，Widget 天然是不可变的（immutable），它如要更新便需要重建，如果想要把可变状态与 Widget 关联起来，可以使用 StatefulWidget，StatefulWidget 通过使用StatefulWidget.createState 方法创建 State 对象，并将之扩充到 Element 以及合并到树中；</p></blockquote><p>这里，为了更为深刻的理解以上描述的含义，我们可以举一个更为形象的例子。Widget 作为大 Boss，他把近期的战略部署，即配置信息，写在纸上下发给经理人 Element，Element 看到详细的配置信息开始真正的开起活来了。我们还需要注意一点，大 Boss 随时会改变战略部署，然后不会在原有的纸上修改而是重新写下来，这时经理人为了减少工作量需要将新的计划与旧的计划比较来作出相应的更新措施。这也是 Flutter 框架层做的一大优化。下面又来了，Element 作为经理人也很体面，当然不会把活全干完，于是又找了一个 RenderObject 的员工来帮它做粗重的累活。</p><p>RenderObject 在 Flutter 当中做组件布局渲染的工作，其为了组件间的渲染搭配及布局约束也有对应的 RenderObject 树，我们也称之为渲染树。</p><p>熟悉了 Flutter 中的上述三颗树，相信读者会对组件的渲染过程有了一个清晰的认识，这对我们之后学习常用组件有很大的帮助，我们需要用不同的眼光去看待我们所建立的布局和控件，之后我们也会更加深入的去理解其中更不为人知的奥秘。</p><span id="more"></span><h2 id="组件渲染过程简述"><a href="#组件渲染过程简述" class="headerlink" title="组件渲染过程简述"></a>组件渲染过程简述</h2><p>从上文中，我们知道控件树中的每个控件都会实现一个 RenderObject 对象做渲染任务，并将所有的RenderObject 组成渲染树。Flutter 渲染组件的过程如下：</p><p><img src="https://i.loli.net/2020/12/17/X14JaTKv2iqyLZs.png" alt="2020-12-17-5.48.06.png"></p><p>Flutter 的渲染过程由用户的输入开始，当接受到用户输入的信号时，就会触发动画的进度更新，例如我们第一次渲染时的启动动画，或者我们在滚动手机屏幕时单个列表项复用时的移动动画。之后便需要开始视图数据的构建（build），这一步中 Flutter 创建了前文所描述的三棵视图树。</p><p>在这之后，视图才会进行布局（layout），计算各个部分的大小，然后进行绘制（paint），生成每个视图的视觉数据，这部分的任务主要就是由 RenderObject 所做。这里，Flutter 中的布局过程可用下图表示，在上述构建完成渲染树后，父渲染对象会将布局约束信息向下传递，子渲染对象根据自己的渲染情况返回 Size，Size 数据会向上传递，最终父渲染对象完成布局过程。</p><p><img src="https://i.loli.net/2020/12/17/T5KdizEHlDCPtUx.png" alt="2020-12-17-5.48.27.png"></p><p>最后一步进行“光栅化”（Rasterize），前一步得到合成的视图数据其实还是一份矢量描述数据，光栅化帮助把这份数据真正地生成一个一个的像素填充数据。在 Flutter 中，光栅化这个步骤被放在了 Engine 层中。</p><p>在日常开发学习中，我们只需要在代码层配置好我们的 Widget 树，了解各种 Widget 特性及使用方法，其余的工作都可以交给我们的框架层去实现。</p><h2 id="元素树详解"><a href="#元素树详解" class="headerlink" title="元素树详解"></a>元素树详解</h2><p>我们已经知道了各类控件的作用及其使用方法，这些 Widget 被我们开发人员配置了多个属性来定义它的展现形式，例如配置 Text 组件需要显示的字符串，配置输入框组件需要显示的内容。我们 Element 树会记录这些配置信息。熟悉 React 的读者可能了解过其中的 “虚拟 DOM” 这个概念，上述 Flutter 这种操作也正体现了这一概念。Widget 是不可变，它的改变就意味着要重建，而其重建也非常频繁，如果我们将更多的任务都交给它将会对性能造成很大的损伤，因此我们把 Widget 组件当作一个虚拟的组件树，而真正被渲染在屏幕上的其实是 Elememt 这棵树，它持有其对应 Widget 的引用，如果他对应的 Widget 发生改变，它就会被标记为 dirty Element，于是下一次更新视图时根据这个状态只更新被修改的内容，从而达到提升element-3845797性能的效果。</p><p>每次，当控件挂载到控件树上时，Flutter 调用其 createElement() 方法，创建其对应的 Element。Flutter 再将这个 Element 放到元素树上，并持有创建它控件的引用，如下图：</p><p><img src="https://i.loli.net/2020/12/17/Qk581zKSOLBUZfJ.png" alt="2020-12-17-5.48.46.png"></p><p>子控件也会创建相应 Element 被放在元素树上：</p><p><img src="https://i.loli.net/2020/12/17/7P6cIbrZfQWKBRj.png" alt="2020-12-17-5.48.53.png"></p><h3 id="Element-中的状态"><a href="#Element-中的状态" class="headerlink" title="Element 中的状态"></a>Element 中的状态</h3><p>我们上文提到了 Widget 的不可变性，相应的 Element 就有其可变性，正如我们前文所说的它被标记为 dirty Element 便是作为需要更新的状态，另外一个我们需要格外注意的是，有状态组件（statefulWidget）对应的 State 对象其实也被 Element 所管理，如下图所示。</p><p>Flutter 中的 Widget 一直在重建，每次重建之后，Element 都会采用相应的措施来确定是否我对应的新控件跟之前引用旧控件是否有所改变，如果没改变则只需要做更新操作，如果前后不同则会重创建。那么，Element 根据什么来确定控件是否改变呢？它会比较 Widget 以下两个属性：</p><ul><li>组件类型</li><li>Widget 的 Key （如果有）</li></ul><p>组件类型即前后控件的是否是同一个类所创建的，Key 即为每个控件的唯一标识。</p><h2 id="渲染树详解"><a href="#渲染树详解" class="headerlink" title="渲染树详解"></a>渲染树详解</h2><p>我们已经大致知道 Flutter 中的三棵重要的树及 Element 树的工作原理，其中第三棵渲染树的任务就是做组件的具体的布局渲染工作。</p><p>渲染树上每个节点都是一个继承自 RenderObject 类的对象，其由 Element 中的 renderObject 或  RenderObjectWidget 中的 createRenderObject 方法生成，该对象内部提供多个属性及方法来帮助框架层中的组件如何布局渲染。</p><blockquote><p>我们在本章之前已经介绍了 StatelessWidget 和 StatefulWidget 两种直接继承自 Widget 的类，在 Flutter 中，还有另一个类 RenderObjectWidget 也同样直接继承自 Widget，它没有 build 方法，可通过 createRenderObject 直接创建 RenderObject 对象放入渲染树中。Column 和 Row 等控件都间接继承自RenderObjectWidget。</p></blockquote><p>主要属性和方法如下：</p><ul><li>constraints 对象，从其父级传递给它的约束</li><li>parentData 对象，其父对象附加有用的信息。</li><li>performLayout 方法，计算此渲染对象的布局。</li><li>paint 方法，绘制该组件及其子组件。</li></ul><p>RenderObject 作为一个抽象类。每个节点需要实现它才能进行实际渲染。扩展 RenderOject 的两个最重要的类是RenderBox 和 RenderSliver。这两个类分别是应用了 Box 协议和 Sliver 协议这两种布局协议的所有渲染对象的父类，其还扩展了数十个和其他几个处理特定场景的类，并实现了渲染过程的细节，如 RenderShiftedBox 和 RenderStack 等等。</p><h3 id="布局约束"><a href="#布局约束" class="headerlink" title="布局约束"></a>布局约束</h3><p>在上面，我们介绍组件渲染流程时，我们了解到了 Flutter 中的控件在屏幕上绘制渲染之前需要先进行布局（layout）操作。其具体可分为两个线性过程：从顶部向下传递约束，从底部向上传递布局信息，其过程可用下图表示。</p><p><img src="https://i.loli.net/2020/12/17/UpYBTI5ahEFgeRP.png" alt="2020-12-17-5.49.10.png"></p><p>第一个线性过程用于传递布局约束。父节点给每个子节点传递约束，这些约束是每个子节点在布局阶段必须要遵守的规则。就好像父母告诉自己的孩子 ：“你必须遵守学校的规定，才可以做其他的事”。常见的约束包括规定子节点最大最小宽度或者子节点最大最小的高度。这种约束会向下延伸，子组件也会产生约束传递给自己的孩子，一直到叶子结点。</p><p>第二的线性过程用来传递具体的布局信息。子节点接受到来自父节点的约束后，会依据它产生自己具体的布局信息，如父节点规定我的最小宽度是 500 的单位像素，子节点按照这个规则可能定义自己的宽度为 500 个像素，或者低于 500 像素的任何一个值。这样，确定好自己的布局信息之后，将这些信息告诉父节点。父节点也会继续此操作向上传递一直到最顶部。</p><p>下面我们具体介绍有哪些具体的布局约束可在树中传递。Flutter 中有两种主要的布局协议：Box 盒子协议和 Sliver 滑动协议。这里我们先以盒子协议为例展开具体的介绍。</p><p>在盒子协议中，父节点传递给其子节点的约束为 BoxConstraints。该约束规定了允许每个子节点的最大和最小宽度和高度。如下图，父节点传入 Min Width 为 150，Max Width 为 300 的 BoxConstraints：</p><p><img src="https://i.loli.net/2020/12/17/DAj6H8GMX3cyPWs.png" alt="2020-12-17-5.49.18.png"></p><p>当子节点接受到该约束，便可以取得上图中绿色范围内的值，即宽度在 150 到 300 之间，高度大于 100，当取得具体的值之后再将取得具体的大小的值上传给父节点，从而达到父子的布局通信。</p><h3 id="自定义一个-Center-控件"><a href="#自定义一个-Center-控件" class="headerlink" title="自定义一个 Center 控件"></a>自定义一个 Center 控件</h3><p>之后更新，大家也可以看各组件的源码探究其如何应用上面提到的原理。</p><p>—2019.07.03 更新</p><p>现在，我们可以应用前文中提到的布局约束与渲染树相关的概念自己定义一个类似居中布局的组件 RenderObject 对象渲染在屏幕上。</p><p>所以我们称自己自定义组件为 CustomCenter：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>() &#123;<br>  <span class="hljs-selector-tag">runApp</span>(<span class="hljs-built_in">MaterialApp</span>(<br>    <span class="hljs-attribute">home</span>: <span class="hljs-built_in">Scaffold</span>(<br>      <span class="hljs-attribute">body</span>: <span class="hljs-built_in">Container</span>(<br>        <span class="hljs-attribute">color</span>: Colors.blue,<br>        <span class="hljs-attribute">constraints</span>: <span class="hljs-built_in">BoxConstraints</span>(<br>            <span class="hljs-attribute">maxWidth</span>: double.infinity,<br>            <span class="hljs-attribute">minWidth</span>: <span class="hljs-number">100.0</span>,<br>            <span class="hljs-attribute">maxHeight</span>: double.infinity,<br>            <span class="hljs-attribute">minHeight</span>: <span class="hljs-number">100.0</span>),<br>        <span class="hljs-attribute">child</span>: <span class="hljs-built_in">CustomCenter</span>(<br>          <span class="hljs-attribute">child</span>: <span class="hljs-built_in">Container</span>(<br>            <span class="hljs-attribute">color</span>: Colors.red,<br>          ),<br>        ),<br>      ),<br>    ),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们来实现我们的 CustomCenter：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomCenter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SingleChildRenderObjectWidget</span> </span>&#123;<br>  <span class="hljs-type">Stingy</span>(&#123;<span class="hljs-type">Widget</span> child&#125;) : <span class="hljs-keyword">super</span>(child: child);<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-type">RenderObject</span> createRenderObject(<span class="hljs-type">BuildContext</span> context) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement createRenderObject</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">RenderCustomCenter</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CustomCenter</code> 继承了 <code>SingleChildRenderObjectWidget</code>，表明这个 Widget 只能有一个子控件， 其中，<code>createRenderObject(...)</code> 方法用于真正创建并返回我们的 <code>RenderObject</code> 对象实例， 我们的 RenderObject 为 <code>RenderCustomCenter</code>，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenderCustomCenter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RenderShiftedBox</span> </span>&#123;<br>  RenderStingy() : <span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);<br><br>  <span class="hljs-comment">// 重写绘制方法</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> paint(PaintingContext context, Offset offset) &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement paint</span><br>    <span class="hljs-keyword">super</span>.paint(context, offset);<br>  &#125;<br><br>  <span class="hljs-comment">// 重写布局方法</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> performLayout() &#123;<br>    <span class="hljs-comment">// 布局子元素并向下传递布局约束</span><br>    child.layout(<br>        BoxConstraints(<br>            minHeight: <span class="hljs-number">0.0</span>,<br>            maxHeight: constraints.minHeight,<br>            minWidth: <span class="hljs-number">0.0</span>,<br>            maxWidth: constraints.minWidth),<br>        parentUsesSize: <span class="hljs-keyword">true</span>);<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;constraints: <span class="hljs-subst">$constraints</span>&#x27;</span>);<br><br>    <span class="hljs-comment">// 指定子元素的偏移位置</span><br>    <span class="hljs-keyword">final</span> BoxParentData childParentData = child.parentData;<br>    childParentData.offset = Offset((constraints.maxWidth - child.size.width)/<span class="hljs-number">2</span>,<br>        (constraints.maxHeight - child.size.height)/<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;childParentData: <span class="hljs-subst">$childParentData</span>&#x27;</span>);<br><br>    <span class="hljs-comment">// 定义自己（CustomCenter）的大小，这里选择约束对象的最大值</span><br>    size = Size(constraints.maxWidth, constraints.maxHeight);<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;size: <span class="hljs-subst">$size</span>&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RenderCustomCenter</code> 继承自 <code>RenderShiftedBox</code>，该类是继承自 <code>RenderBox</code>。<code>RenderShiftedBox</code> 满足盒子协议，并且提供了 <code>performLayout()</code> 方法的实现。我们需要在 <code>performLayout()</code> 方法中布局我们的子元素。??</p><p>我们在使用 <code>child.layout(...)</code> 方法布局 <em>child</em> 的时候传递了两个参数，第一个为 <em>child</em> 的布局约束，而另外一个参数是 <code>parentUserSize</code>， 该参数如果设置为 <code>false</code>，则意味着 <em>parent</em> 不关心 <em>child</em> 选择的大小，这对布局优化比较有用；因为如果 <em>child</em> 改变了自己的大小，<em>parent</em> 就不必重新 <code>layout</code> 了。但是在我们的例子中，我们的需要把 <em>child</em> 放置在 <em>parent</em> 的中心，就是 <em>child</em> 的<strong>大小（Size）一旦改变，则其对应的偏移量（Offset）</strong> 也会改变，于是 <em>parent</em> 需要重新布局，所以我们这里传递了一个 <code>true</code>。</p><p>当 <code>child.layout(...)</code> 完成了以后，<em>child</em> 就确定了自己的 <em>Layout Details</em>。然后我们就还可以为其设置偏移量来将它放置到我们想放的位置。在我们的例子中为 <strong>居中</strong>。</p><p>最后，和 <em>child</em> 根据 <em>parent</em> 传递过来的约束选择了一个尺寸一样，我们也需要为 <strong>CustomCenter</strong> 选择一个尺寸。</p><h2 id="应用视图的构建"><a href="#应用视图的构建" class="headerlink" title="应用视图的构建"></a>应用视图的构建</h2><p>Flutter App 入口的部分发生于如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">import <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-comment">// 这里的 MyApp是一个 Widget</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> =&gt; runApp(<span class="hljs-keyword">new</span> MyApp());<br></code></pre></td></tr></table></figure><p><code>runApp</code>函数接受一个 Widget类型的对象作为参数，也就是说在 Flutter的概念中，只存在 View，而其他的任何逻辑都只为 View的数据、状态改变服务，不存在 ViewController(或者叫 Activity）。接下来看 <code>runApp</code>做了什么：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala">void runApp(<span class="hljs-type">Widget</span> app) &#123;<br>  <span class="hljs-type">WidgetsFlutterBinding</span>.ensureInitialized()<br>    ..attachRootWidget(app)<br>    ..scheduleWarmUpFrame();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetsFlutterBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BindingBase</span> <span class="hljs-keyword">with</span> <span class="hljs-title">GestureBinding</span>, <span class="hljs-title">ServicesBinding</span>, <span class="hljs-title">SchedulerBinding</span>, <span class="hljs-title">PaintingBinding</span>, <span class="hljs-title">RendererBinding</span>, <span class="hljs-title">WidgetsBinding</span> </span>&#123;<br>  static <span class="hljs-type">WidgetsBinding</span> ensureInitialized() &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">WidgetsBinding</span>.instance == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">new</span> <span class="hljs-type">WidgetsFlutterBinding</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">WidgetsBinding</span>.instance;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>runApp</code> 中，传入的 widget 被挂载到根 widget 上。这个 <code>WidgetsFlutterBinding</code> 其实是一个单例，通过 mixin 来使用框架中实现的其他 binding 的 Service，比如手势、基础服务、队列、绘图等等。然后会调用 <code>scheduleWarmUpFrame</code> 这个方法，从这个方法注释可知，调用这个方法会主动构建视图数据。这样做的好处是因为 Flutter 依赖 Dart 的 MicroTask 来进行帧数据构建任务的 schedule，这里通过主动调用进行整个周期的 “热身”，这样最近的下次 VSync 信号同步时就有视图数据可提供，而不用等到 MicroTask 的 next Tick。</p><p>然后我们再来看 <code>attachRootWidget</code> 这个函数干了什么：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void attach<span class="hljs-constructor">RootWidget(Widget <span class="hljs-params">rootWidget</span>)</span> &#123;<br>    _renderViewElement = <span class="hljs-keyword">new</span> RenderObjectToWidgetAdapter&lt;RenderBox&gt;(<br>      container: renderView,<br>      debugShortDescription: &#x27;<span class="hljs-literal">[<span class="hljs-identifier">root</span>]</span>&#x27;,<br>      child: rootWidget<br>    ).attach<span class="hljs-constructor">ToRenderTree(<span class="hljs-params">buildOwner</span>, <span class="hljs-params">renderViewElement</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>attachRootWidget</code> 把 widget交给了 <code>RenderObjectToWidgetAdapter</code>这座桥梁，通过这座桥梁，Element 被创建，并且同时能持有 Widget 和 RenderObject的引用。然后我们从上文就知道后面发生的就是第一次的视图数据构建了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CocoaPods组件支持Carthage打包</title>
    <link href="/2019/12/03/CocoaPods%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81Carthage%E6%89%93%E5%8C%85/"/>
    <url>/2019/12/03/CocoaPods%E7%BB%84%E4%BB%B6%E6%94%AF%E6%8C%81Carthage%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>虽说 CocoaPods 有 <a href="https://github.com/CocoaPods/cocoapods-packager">cocoapods-packager</a> 这个插件可以生成二进制版本，但这个库的维护者似乎并不活跃，很多 issue 和 pr 过了一两年还堆积着没处理。于是我决定试试 Carthage ，不过不利用 Cartfile 生成依赖，还是用的 CocoaPods 那一套。</p><p>要让组件支持 Carthage ，工程里只需要有一个 <code>shared framework target</code> 即可。针对 CocoaPods 生成的工程，我们先在 Podfile 里面设置 <code>use_frameworks!</code> ，来满足 <code>framework target</code> 。</p><p>对于剩下的 <code>share</code> 部分，可以用 <a href="https://github.com/CocoaPods/CocoaPods/pull/5254">Add share schemes for development pods</a> 这个 pr 里面的方法解决：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">install! <span class="hljs-string">&#x27;cocoapods&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">share_schemes_for_development_pods</span> =&gt;</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>不过上面的那种方式把所有的 <code>development pods</code> 对应的 target 都 share 了，这里我们可以这样设置特定的 <code>development pods</code> ：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">install! <span class="hljs-string">&#x27;cocoapods&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">share_schemes_for_development_pods</span> =&gt;</span> [<span class="hljs-string">&#x27;PodA&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在 CocoaPods 1.4.0 版本中，<code>share_schemes_for_development_pods</code> 默认是 false 的，所以需要手动在 Podfile 里面去添加这一句。</p><p>最后执行一下 <code>pod install</code> ，然后再执行 <code>carthage build --no-skip-current --platform ios</code> 就可以打出 ios 版本的 dynamic framework 了。想利用 Carthage 打出 static framework 的可以查看 <a href="https://github.com/Carthage/Carthage/blob/master/Documentation/StaticFrameworks.md">Build static frameworks to speed up your app’s launch times</a>。</p><p>再进一步，我们可以把这个默认设置写入团队专有的 CocoaPods 插件中，比如 <code>cocoapods-xxx-plugin</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">Pod</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:HooksManager</span>.register(<span class="hljs-string">&#x27;cocoapods-xxx-plugin&#x27;</span>, <span class="hljs-symbol">:pre_install</span>) <span class="hljs-keyword">do</span> |<span class="hljs-params">context, _</span>|<br>first_target_definition = context.podfile.target_definition_list.select&#123; |<span class="hljs-params">d</span>| d.name != <span class="hljs-string">&#x27;Pods&#x27;</span> &#125;.first<br>development_pod = first_target_definition.name.split(<span class="hljs-string">&#x27;_&#x27;</span>).first <span class="hljs-keyword">unless</span> first_target_definition.<span class="hljs-literal">nil</span>?<br>    <br><span class="hljs-title class_">Pod</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:UI</span>.section(<span class="hljs-string">&quot;Auto set share scheme for development pod: \&#x27;<span class="hljs-subst">#&#123;development_pod&#125;</span>\&#x27;&quot;</span>) <span class="hljs-keyword">do</span><br><span class="hljs-comment"># carthage 需要 shared scheme 构建 framework</span><br>context.podfile.install!(<span class="hljs-string">&#x27;cocoapods&#x27;</span>, <span class="hljs-symbol">:share_schemes_for_development_pods</span> =&gt; [development_pod])<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">unless</span> development_pod.<span class="hljs-literal">nil</span>?<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在 Podfile 添加以下代码，让插件生效：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">plugin</span> <span class="hljs-string">&#x27;cocoapods-xxx-plugin&#x27;</span><br></code></pre></td></tr></table></figure><p>好处就是以后有更多相似配置的话都可以通过更改这个插件解决，而不用每次都去 Podfile 里面改 <code>pre_install</code>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AsyncDisplayKit</title>
    <link href="/2019/11/12/AsyncDisplayKit/"/>
    <url>/2019/11/12/AsyncDisplayKit/</url>
    
    <content type="html"><![CDATA[<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p><p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView&#x2F;CALayer 等 UI 对象的创建、设置属性和销毁。</p><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p><p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView&#x2F;CALayer，它具有和 UIView&#x2F;CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView&#x2F;CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView&#x2F;CALayer 去。</p><p>ASDK 仿照 QuartzCore&#x2F;UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习/深度学习路线与资料</title>
    <link href="/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/"/>
    <url>/2019/10/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E4%B8%8E%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<p>###吴恩达机器学习视频及资料</p><p><strong>docx</strong>：笔记的<strong>word</strong>版本</p><p><strong>markdown</strong>：笔记的<strong>markdown</strong>版本</p><p><strong>html</strong>：笔记的<strong>html</strong>版本</p><p><strong>images</strong>：笔记的图片</p><p><strong>ppt</strong>：课程的原版课件</p><p><strong>srt</strong>：课程的中英文字幕（<strong>mp4</strong>文件需要在百度云下载，大家可以用记事本或者字幕编辑软件来编辑字幕，共同完善，百度云链接：<a href="https://pan.baidu.com/s/1h8QjqBlOm0Exh7orm9teMQ">https://pan.baidu.com/s/1h8QjqBlOm0Exh7orm9teMQ</a> 密码：d3we，下载后解压）</p><p><strong>code</strong>：课程的<strong>python</strong>代码（有一部分是国外大牛写的）</p><p>机器学习视频下载链接：<a href="https://pan.baidu.com/s/1raoOPOg">https://pan.baidu.com/s/1raoOPOg</a> 密码：48m8，包含视频和字幕，下载后解压，建议用<strong>potplayer</strong>播放，此视频与<strong>mp4</strong>一致。</p><p>###吴恩达深度学习视频</p><p><strong>教程地址：</strong><a href="https://mooc.study.163.com/university/deeplearning_ai#/c">https://mooc.study.163.com/university/deeplearning_ai#/c</a></p><p><strong>有同学提供了一个离线视频的下载</strong>：链接：<a href="https://pan.baidu.com/s/1ciq3qHo0lgoD3MLRwfeqnA">https://pan.baidu.com/s/1ciq3qHo0lgoD3MLRwfeqnA</a> 密码：0kim</p><p>基础数学(高等数学，线性代数，概率论等)→机器学习(数学导向推荐李航的《统计学习方法》，技术导向推荐周志华的《机器学习》吴恩达机器学习)→吴恩达深度学习</p><span id="more"></span><h2 id="Part-1：从机器学习开始（两个月）"><a href="#Part-1：从机器学习开始（两个月）" class="headerlink" title="Part 1：从机器学习开始（两个月）"></a><strong>Part 1：从机器学习开始（两个月）</strong></h2><p>最好的入门教程，就是吴恩达讲授的机器学习。吴恩达这套课程发布很久了，虽然有些地方稍微过时，但相信我，现在没有任何公开的课程，能比吴恩达讲得更好。真的，课程结束时我几乎哭了出来。</p><p>这个课程可以说适合任何水平的学生，当然，你最好还是得知道两个矩阵如何相乘，以及对编程有一些基本的了解。</p><blockquote><p>这套课程可以前往Coursera学习，传送门：<br><a href="https://link.zhihu.com/?target=https://www.coursera.org/learn/machine-learning">https://www.coursera.org/learn/machine-learning</a><br>也可以上网易公开课收看，传送门：<br><a href="https://link.zhihu.com/?target=http://open.163.com/special/opencourse/machinelearning.html">http://open.163.com/special/opencourse/machinelearning.html</a></p></blockquote><p>如果你有时间，一定要听完全部的课程。如果时间紧张，至少要听完前五节课程，后面的可以暂时跳过。</p><p>吴恩达的机器学习课程深入讲解了经典的机器学习模型，如线性回归、逻辑回归、神经网络、支持向量机、PCA、无监督学习等等。大部分重要概念，都以简单易懂的方式进行了介绍。</p><p><strong>课程延伸</strong></p><p>当你学习到第五节课，也就是开始讲述神经网络时，建议开始查看与课程平行的外部资料。比方3bule1brown推出的神经网络讲解视频。推荐必看。</p><blockquote><p>YouTube传送门：<br><a href="https://link.zhihu.com/?target=https://youtu.be/aircAruvnKk?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi">https://youtu.be/aircAruvnKk?list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi</a><br>或者可以前往B站查看：<br><a href="https://link.zhihu.com/?target=http://space.bilibili.com/88461692/%23/">http://space.bilibili.com/88461692/#/</a></p></blockquote><p>以及，我觉得吴恩达在讲神经网络时有点快，所以建议补充阅读一些资料。比如有关神经网络和深度学习的在线书籍，免费的就很好了。</p><blockquote><p>传送门：<br><a href="https://link.zhihu.com/?target=http://neuralnetworksanddeeplearning.com/">http://neuralnetworksanddeeplearning.com/</a></p></blockquote><p><img src="https://pic2.zhimg.com/50/v2-7b911537b2b41c55d0e747ac8bb66fe8_hd.jpg" alt="img">![img]</p><p>作者Michael A. Nielsen以一种简单直观的方式，深入探究了神经网络的每个细节。建议阅读这本书的前两章，与吴恩达的课程并行。当你熟悉更多概念后，开始搞深度学习时，可以再看书中的其余部分。</p><p>如果你英文不好，这本《神经网络与深度学习》也有中文翻译版本，可以免费在线查看。</p><blockquote><p>传送门在此：<br><a href="https://link.zhihu.com/?target=https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/">https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/</a></p></blockquote><p><img src="https://pic4.zhimg.com/50/v2-e6bdd2af3b77f76caf90664e555c1904_hd.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-e6bdd2af3b77f76caf90664e555c1904_hd.jpg" alt="img"></p><p>这个部分的学习结束之后，你就能明白机器&#x2F;深度学习的许多概念。最后推荐阅读Christopher Olah的博客，很有意思。</p><blockquote><p>传送门：<a href="https://link.zhihu.com/?target=http://colah.github.io/">http://colah.github.io/</a></p></blockquote><p><img src="https://pic1.zhimg.com/50/v2-ebf3a89b9b6da8117ef31400cbf6da0c_hd.jpg" alt="img">![img]</p><h2 id="Part-2：涉足深度学习（1个月）"><a href="#Part-2：涉足深度学习（1个月）" class="headerlink" title="Part 2：涉足深度学习（1个月）"></a><strong>Part 2：涉足深度学习（1个月）</strong></h2><p>开始研究深度学习之前，最好重温一下大学数学。Ian Goodfellow传奇般的“花书”《深度学习》，简明扼要的概括了大部分重要主题。</p><p>建议大家尽可能深入地阅读线性代数、概率、信息理论的章节。每当读论文遇到深度学习概念时，都可以在书中找到参考。</p><p><img src="https://pic3.zhimg.com/50/v2-9338199c21e4765b1928658fc14bfadd_hd.jpg" alt="img">![img]以及，这本书有在线的版本。</p><blockquote><p>例如英文版在此：<br><a href="https://link.zhihu.com/?target=https://github.com/janishar/mit-deep-learning-book-pdf/blob/master/complete-book-bookmarked-pdf/deeplearningbook.pdf">https://github.com/janishar/mit-deep-learning-book-pdf/blob/master/complete-book-bookmarked-pdf/deeplearningbook.pdf</a>。<br>而中文翻译版本在此：<br><a href="https://link.zhihu.com/?target=https://github.com/exacity/deeplearningbook-chinese">https://github.com/exacity/deeplearningbook-chinese</a></p></blockquote><p><img src="https://pic3.zhimg.com/50/v2-7a8f7bbe0a7c1b6a40238c7723a1f0e9_hd.jpg" alt="img">![img]</p><p>关于深度学习的在线资料有很多，你可能会挑花了眼。</p><p>再一次，我觉得最好的选择，还是听吴恩达的《深度学习专项系列课程（Deep Learning Specialization）》。</p><blockquote><p>Coursera传送门：<br><a href="https://link.zhihu.com/?target=https://www.coursera.org/specializations/deep-learning">https://www.coursera.org/specializations/deep-learning</a><br>网易云课堂的传送门：<br><a href="https://link.zhihu.com/?target=https://mooc.study.163.com/smartSpec/detail/1001319001.htm/">https://mooc.study.163.com/smartSpec/detail/1001319001.htm/</a></p></blockquote><p>这门课程包括五大章节。其实不是免费的，你可以按照50美元&#x2F;月购买。当然，如果你负担不起，还能申请“助学金”。申请时请详细阐明理由，处理的时间大概需要15天左右。</p><p>当然不付费，大部分内容都是可以看的。以及视频的部分，在很多地方也能免费收看。</p><p>这五门课程主要讲的是：</p><p>1、神经网络和深度学习（4周）</p><p>2、改善深度神经网络（3周）</p><p>3、结构化机器学习项目（2周）</p><p>4、卷积神经网络（4周）</p><p>5、序列模型（3周）</p><p><img src="https://pic3.zhimg.com/50/v2-2ec23bc8f9e5feef617ab624237ed3fd_hd.jpg" alt="img">![img]</p><p>前三门课程涉及一般的神经网络和深度学习，第四、第五门课程涉及特定主题。如果你打算搞视觉，第四课必听；如果你搞NLP、音频等，第五课必听。但如果你需要听第五课，那么建议也把第四课好好听一下。</p><p>这里鼓励大家一下，课程里每周的内容，实际上一两天就能学完，所以不要被课程表吓倒。劳逸集合、提升效率。</p><p>学到这个地步，其实就可以再去<a href="https://link.zhihu.com/?target=http://neuralnetworksanddeeplearning.com/">http://neuralnetworksanddeeplearning.com/</a>，查看第三到第六章的内容，来强化你的概念。如果你有什么还没搞懂的，请前往Olah的博客。</p><p>以及，这时候你要开始看深度学习的论文了，从中学习知识。深度学习有个强烈的特点，那就是内容都非常新，阅读论文是跟上时代唯一的方法。不想被抛下，那么还是养成阅读论文的好习惯吧。</p><h2 id="Part-3：深度学习上手练（两个月）"><a href="#Part-3：深度学习上手练（两个月）" class="headerlink" title="Part 3：深度学习上手练（两个月）"></a><strong>Part 3：深度学习上手练（两个月）</strong></h2><p>学到这里，你应该对机器学习和深度学习中的大多数概念有了正确的理解，现在是时候投入沸腾的实际生活中了。</p><p>练手深度学习，最好的资源在fast.ai。</p><p><img src="https://pic1.zhimg.com/50/v2-43375e199f3fd6d70313bb24e66f2542_hd.jpg" alt="img">![img]</p><blockquote><p>传送门在此：<a href="https://link.zhihu.com/?target=http://course.fast.ai/">http://course.fast.ai/</a></p></blockquote><p>他们在流行的深度学习工具PyTorch上构建了一个库，只需要几行代码，就能实现世界级的性能。</p><p>fast.ai的理念有点不同。吴恩达等老师的教授方法是自上而下，先讲再做。而fast.ai倡导自下而上，先做再讲。</p><p>所以在他们的课程中，第一节就带你建立一个强大的图像分类器。自己训练模型的快感，刺激着你去完成其余的课程。</p><p><img src="https://pic2.zhimg.com/50/v2-51fe4a58e42ada297cf493ee19b26539_hd.jpg" alt="img">![img]</p><p>除此以外，还要推荐两门课。</p><p>斯坦福大学的CS231n和CS224n。CS231n专注于计算机视觉的深度学习，而CS224n专注于序列建模。</p><blockquote><p>CS231n，李飞飞等主讲。<br>官网传送门：<a href="https://link.zhihu.com/?target=http://cs231n.stanford.edu/">http://cs231n.stanford.edu/</a><br>CS224n，目前是Richard Socher主讲。<br>官网传送门：<a href="https://link.zhihu.com/?target=http://web.stanford.edu/class/cs224n/">http://web.stanford.edu/class/cs224n/</a></p></blockquote><p>此前的课程，网上也有中文字幕版本，大家可自行搜索。</p><p>到这里，为期五个月的机器&#x2F;深度学习入门就结束了。</p><p>希望大家都能稳扎稳打，夯实基础。</p><p>以及最后，兑现一个开头的承诺。如果你确实时间很紧张，必须尽快入门机器&#x2F;深度学习，那么请看——</p><h2 id="速成指南"><a href="#速成指南" class="headerlink" title="速成指南"></a><strong>速成指南</strong></h2><p><strong>我最多只有俩月</strong></p><p>1、完成吴恩达机器学习课程的前五周，要做编程练习。</p><p>2、看完3Blue1Brown的视频。</p><p>3、完成吴恩达的深度学习专项系列课程，做练习。</p><p>4、如果你想搞图像，看专项课程第四讲，搞NLP或序列数据，看第五讲。</p><p>5、搜索你感兴趣的开源实现。如果你还没想好用什么语言，推荐Keras。然后根据需要，再迁到TensorFlow或者PyTorch框架。</p><p><strong>我，只有一个月</strong></p><p>想要在30天完成入门超级困难。除非，你只是想了解机器学习的工作原理，然后应用到自己的项目中。</p><p>如果是这样的话，速成建议如下：</p><p>1、略读吴恩达机器学习课程第1-5周的课程，只看视频，掌握概念即可。第三周可以跳过MATLAB&#x2F;Octave课程。</p><p>2、看完3Blue1Brow的视频。</p><p>3、略读吴恩达深度学习专项系列课程的第一课，也就是神经网络和深度学习。</p><p>4、如果你想做图像处理项目，看一下Nielsen书中的第六章：<a href="https://link.zhihu.com/?target=http://neuralnetworksanddeeplearning.com/chap6.html">http://neuralnetworksanddeeplearning.com/chap6.html</a></p><p>如果你需要序列建模的一些想法，可以看看Olah的博客：<a href="https://link.zhihu.com/?target=http://colah.github.io/posts/2015-08-Understanding-LSTMs/">http://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p><p>5、Siraj Raval拍了很多有趣的视频，涉及大多数机器&#x2F;深度学习的主题。传送门在此：<a href="https://link.zhihu.com/?target=https://www.youtube.com/channel/UCWN3xxRkmTPmbKwht9FuE5A">https://www.youtube.com/channel/UCWN3xxRkmTPmbKwht9FuE5A</a></p><p>6、搜索跟你感兴趣的开源实现，随时调整以满足你的需求。如前所述，我推荐你先用带有TensorFlow后端的Keras语言。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cocoapods加载插件</title>
    <link href="/2019/09/23/cocoapod%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/"/>
    <url>/2019/09/23/cocoapod%E5%8A%A0%E8%BD%BD%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>CocoaPods 为开发者提供了插件注册功能，可以使用 <code>pod plugins create NAME</code> 命令创建插件，并在 Podfile 中通过 <code>plugin &#39;NAME&#39;</code> 语句引入插件。虽然在一般情况下很少使用这个功能，但在某些场景下，利用插件能比较方便快捷地解决问题。</p><h2 id="实现探索"><a href="#实现探索" class="headerlink" title="实现探索"></a>实现探索</h2><p>首先，由于 <code>pod install</code> 过程会涉及到插件的加载，所以直接查看 <code>installer.rb</code> 文件:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># Runs the registered callbacks for the plugins post install hooks.</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_plugins_post_install_hooks</span><br>  context = <span class="hljs-title class_">PostInstallHooksContext</span>.generate(sandbox, aggregate_targets)<br>  <span class="hljs-title class_">HooksManager</span>.run(<span class="hljs-symbol">:post_install</span>, context, plugins)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># Runs the registered callbacks for the plugins pre install hooks.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [void]</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_plugins_pre_install_hooks</span><br>  context = <span class="hljs-title class_">PreInstallHooksContext</span>.generate(sandbox, podfile, lockfile)<br>  <span class="hljs-title class_">HooksManager</span>.run(<span class="hljs-symbol">:pre_install</span>, context, plugins)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># Ensures that all plugins specified in the &#123;#podfile&#125; are loaded.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [void]</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ensure_plugins_are_installed!</span><br>  <span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;claide/command/plugin_manager&#x27;</span><br><br>  loaded_plugins = <span class="hljs-title class_">Command</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:PluginManager</span>.specifications.map(&amp;<span class="hljs-symbol">:name</span>)<br><br>  podfile.plugins.keys.each <span class="hljs-keyword">do</span> |<span class="hljs-params">plugin</span>|<br>    <span class="hljs-keyword">unless</span> loaded_plugins.<span class="hljs-keyword">include</span>? plugin<br>      <span class="hljs-keyword">raise</span> <span class="hljs-title class_">Informative</span>, <span class="hljs-string">&quot;Your Podfile requires that the plugin `<span class="hljs-subst">#&#123;plugin&#125;</span>` be installed. Please install it and try installation again.&quot;</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>其中 <code>run_plugins_pre_install_hooks</code> 和 <code>run_plugins_post_install_hooks</code> 分别执行了插件注册的 <code>pre_install</code> 和 <code>pod_install</code> 方法， <code>ensure_plugins_are_installed</code> 则确认插件是否已被安装。</p><p>接下来看下 <code>Command::PluginManager</code> ，这个类在 <code>claide/command/plugin_manager</code> 文件内，属于 <code>claide</code> gem :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Array&lt;Gem::Specification&gt;] Loads plugins via RubyGems looking</span><br><span class="hljs-comment">#         for files named after the `PLUGIN_PREFIX_plugin` and returns the</span><br><span class="hljs-comment">#         specifications of the gems loaded successfully.</span><br><span class="hljs-comment">#         Plugins are required safely.</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">self</span>.load_plugins(plugin_prefix)<br>  loaded_plugins[plugin_prefix] |<span class="hljs-params"></span>|=<br>    plugin_gems_for_prefix(plugin_prefix).map <span class="hljs-keyword">do</span> |<span class="hljs-params">spec, paths</span>|<br>      spec <span class="hljs-keyword">if</span> safe_activate_and_require(spec, paths)<br>    <span class="hljs-keyword">end</span>.compact<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># <span class="hljs-doctag">@group</span> Helper Methods</span><br><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Array&lt;[Gem::Specification, Array&lt;String&gt;]&gt;]</span><br><span class="hljs-comment">#         Returns an array of tuples containing the specifications and</span><br><span class="hljs-comment">#         plugin files to require for a given plugin prefix.</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">self</span>.plugin_gems_for_prefix(prefix)<br>  glob = <span class="hljs-string">&quot;<span class="hljs-subst">#&#123;prefix&#125;</span>_plugin<span class="hljs-subst">#&#123;<span class="hljs-title class_">Gem</span>.suffix_pattern&#125;</span>&quot;</span><br>  <span class="hljs-title class_">Gem</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:Specification</span>.latest_specs(<span class="hljs-literal">true</span>).map <span class="hljs-keyword">do</span> |<span class="hljs-params">spec</span>|<br>    matches = spec.matches_for_glob(glob)<br>    [spec, matches] <span class="hljs-keyword">unless</span> matches.empty?<br>  <span class="hljs-keyword">end</span>.compact<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># Activates the given spec and requires the given paths.</span><br><span class="hljs-comment"># If any exception occurs it is caught and an</span><br><span class="hljs-comment"># informative message is printed.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">@param</span>  [Gem::Specification] spec</span><br><span class="hljs-comment">#         The spec to be activated.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">@param</span>  [String] paths</span><br><span class="hljs-comment">#         The paths to require.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Bool] Whether activation and requiring succeeded.</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">self</span>.safe_activate_and_require(spec, paths)<br>  spec.activate<br>  paths.each &#123; |<span class="hljs-params">path</span>| <span class="hljs-keyword">require</span>(path) &#125;<br>  <span class="hljs-literal">true</span><br><span class="hljs-keyword">rescue</span> <span class="hljs-title class_">Exception</span> =&gt; exception <span class="hljs-comment"># rubocop:disable RescueException</span><br>  message = <span class="hljs-string">&quot;\n---------------------------------------------&quot;</span><br>  message &lt;&lt; <span class="hljs-string">&quot;\nError loading the plugin `<span class="hljs-subst">#&#123;spec.full_name&#125;</span>`.\n&quot;</span><br>  message &lt;&lt; <span class="hljs-string">&quot;\n<span class="hljs-subst">#&#123;exception.<span class="hljs-keyword">class</span>&#125;</span> - <span class="hljs-subst">#&#123;exception.message&#125;</span>&quot;</span><br>  message &lt;&lt; <span class="hljs-string">&quot;\n<span class="hljs-subst">#&#123;exception.backtrace.join(<span class="hljs-string">&quot;\n&quot;</span>)&#125;</span>&quot;</span><br>  message &lt;&lt; <span class="hljs-string">&quot;\n---------------------------------------------\n&quot;</span><br>  warn message.ansi.yellow<br>  <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>以上代码调用几个的 <code>Gem::Specification</code> 方法如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 获取最新 spec 集合</span><br><span class="hljs-comment"># Return the latest specs, optionally including prerelease specs if prerelease is true.</span><br>latest_specs(prerelease = <span class="hljs-literal">false</span>) <br><br><span class="hljs-comment"># 获取 gem 中匹配的文件路径</span><br><span class="hljs-comment"># Return all files in this gem that match for glob.</span><br>matches_for_glob(glob) <br><br><span class="hljs-comment"># 激活 spec，注册并将其 lib 路径添加到 $LOAD_PATH （$LOAD_PATH 环境变量存储 require 文件时查找的路径）</span><br><span class="hljs-comment"># Activate this spec, registering it as a loaded spec and adding it&#x27;s lib paths to $LOAD_PATH. Returns true if the spec was activated, false if it was previously activated. Freaks out if there are conflicts upon activation.</span><br><span class="hljs-built_in">activate</span>()<br></code></pre></td></tr></table></figure><p>可以看到在 <code>loaded_plugins[plugin_prefix]</code> 为空的情况下，程序会执行 <code>plugin_gems_for_prefix</code> 方法，<code>plugin_gems_for_prefix</code> 方法通过 <code>latest_specs</code> 获取了最新的 spec ，并通过 spec 的 <code>matches_for_glob</code> 方法对文件进行匹配，当 spec 中存在匹配 <code>&quot;#&#123;prefix&#125;_plugin#&#123;Gem.suffix_pattern&#125;&quot;</code> 格式的文件时，则视其为 CocoaPods 插件。在拿到插件及其匹配文件后，<code>safe_activate_and_require</code> 方法将文件加入 $LOAD_PATH 中并 require 之。</p><p>另外 <code>CLAide::Command</code> 类会在 <code>run</code> 类方法中加载所有插件，然后根据解析后的信息，执行对应的命令:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># <span class="hljs-doctag">@param</span>  [Array, ARGV] argv</span><br><span class="hljs-comment">#         A list of (remaining) parameters.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Command] An instance of the command class that was matched by</span><br><span class="hljs-comment">#         going through the arguments in the parameters and drilling down</span><br><span class="hljs-comment">#         command classes.</span><br><span class="hljs-comment">#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">self</span>.run(argv = [])<br>  plugin_prefixes.each <span class="hljs-keyword">do</span> |<span class="hljs-params">plugin_prefix</span>|<br>    <span class="hljs-title class_">PluginManager</span>.load_plugins(plugin_prefix)<br>  <span class="hljs-keyword">end</span><br><br>  argv = <span class="hljs-variable constant_">ARGV</span>.coerce(argv)<br>  command = parse(argv)<br>  <span class="hljs-variable constant_">ANSI</span>.disabled = !command.ansi_output?<br>  <span class="hljs-keyword">unless</span> command.handle_root_options(argv)<br>    command.validate!<br>    command.run<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">rescue</span> <span class="hljs-title class_">Object</span> =&gt; exception<br>  handle_exception(command, exception)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>对于通过 <code>pod plugin create</code> 命令创建的插件来说，lib 目录下都会自动生成一个 <code>cocoapods_plugin.rb</code> 文件，这个文件就是用来标识此 gem 为 CocoaPods 插件的。如果想手动创建 CocoaPods 插件，需要满足以下两个条件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Handles plugin related logic logic for the `Command` class.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Plugins are loaded the first time a command run and are identified by the</span><br><span class="hljs-comment"># prefix specified in the command class. Plugins must adopt the following</span><br><span class="hljs-comment"># conventions:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># - Support being loaded by a file located under the</span><br><span class="hljs-comment"># `lib/#&#123;plugin_prefix&#125;_plugin` relative path.</span><br><span class="hljs-comment"># - Be stored in a folder named after the plugin.</span><br><br><span class="hljs-comment"># - 支持通过 `lib/#&#123;plugin_prefix&#125;_plugin` 路径的文件加载</span><br><span class="hljs-comment">#   (也就是说，如果要对外暴露插件内部存的方法，需要在此文件中 require 之，比如自定义的 Podfile DSL 文件)</span><br><span class="hljs-comment"># - 保存在以插件命名的文件夹中</span><br></code></pre></td></tr></table></figure><p>在 CocoaPods 上下文中，以上的 <code>plugin_prefix</code> 如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable language_">self</span>.plugin_prefixes = <span class="hljs-string">%w(claide cocoapods)</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果需要外部 gem 以插件的形式提供某些功能，可以通过和 CocoaPods 一样的方式实现，即规定特定的命名规则，然后通过 <code>Gem::Specification</code> 提供的方法获取满足条件的 gem ，再 require 入口文件:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">spec = Gem::Specification.find_by_name(<span class="hljs-string">&#x27;naruto&#x27;</span>)<br>spec.activate<br>matches = spec.matches_for_glob(<span class="hljs-string">&#x27;naruto&#x27;</span>)<br>matches.each <span class="hljs-keyword">do</span> |<span class="hljs-built_in">path</span>|<br>  <span class="hljs-built_in">require</span>(<span class="hljs-built_in">path</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cocoaPods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机深林</title>
    <link href="/2019/09/18/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/"/>
    <url>/2019/09/18/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/</url>
    
    <content type="html"><![CDATA[<ul><li>要点<ul><li>说名随机森林每棵决策树的建立过程</li><li>知道为什么需要随机有放回(Bootstrap)的抽样</li><li>说明随机森林的超参数</li></ul></li><li>应用<ul><li>泰坦尼克号乘客生存预测</li></ul></li></ul><h2 id="1、-什么是集成学习方法"><a href="#1、-什么是集成学习方法" class="headerlink" title="1、 什么是集成学习方法"></a>1、 什么是集成学习方法</h2><p>集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是<strong>生成多个分类器&#x2F;模型</strong>，各自独立地学习和作出预测。<strong>这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。</strong></p><h2 id="2、-什么是随机森林"><a href="#2、-什么是随机森林" class="headerlink" title="2、 什么是随机森林"></a>2、 什么是随机森林</h2><p>在机器学习中，<strong>随机森林是一个包含多个决策树的分类器</strong>，并且其输出的类别是由个别树输出的类别的众数而定。</p><p><img src="/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97t/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97.png" alt="随机森林"></p><p>例如, 如果你训练了5个树, 其中有4个树的结果是True, 1个数的结果是False, 那么最终投票结果就是True</p><p><img src="/%E9%9A%8F%E6%9C%BA%E6%B7%B1%E6%9E%97/%E6%8A%95%E7%A5%A8.png" alt="投票"></p><h2 id="3、-随机森林原理过程"><a href="#3、-随机森林原理过程" class="headerlink" title="3、 随机森林原理过程"></a>3、 随机森林原理过程</h2><p>学习算法根据下列算法而建造每棵树：</p><ul><li>用N来表示训练用例（样本）的个数，M表示特征数目。<ul><li>1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）</li><li>2、随机去选出m个特征, m &lt;&lt;M，建立决策树</li></ul></li><li>采取bootstrap抽样1</li></ul><h3 id="3-1-为什么采用BootStrap抽样"><a href="#3-1-为什么采用BootStrap抽样" class="headerlink" title="3.1 为什么采用BootStrap抽样"></a>3.1 为什么采用BootStrap抽样</h3><ul><li>为什么要随机抽样训练集？　　<ul><li>如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的</li></ul></li><li>为什么要有放回地抽样？<ul><li>如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。</li></ul></li></ul><h3 id="3-2-API"><a href="#3-2-API" class="headerlink" title="3.2 API"></a>3.2 API</h3><ul><li><p>class sklearn.ensemble.RandomForestClassifier(n_estimators&#x3D;10, criterion&#x3D;’gini’, max_depth&#x3D;None, bootstrap&#x3D;True, random_state&#x3D;None, min_samples_split&#x3D;2)</p><ul><li>随机森林分类器</li><li>n_estimators：integer，optional（default &#x3D; 10）森林里的树木数量120,200,300,500,800,1200</li><li>criteria：string，可选（default &#x3D;“gini”）分割特征的测量方法</li><li>max_depth：integer或None，可选（默认&#x3D;无）树的最大深度 5,8,15,25,30</li><li>max_features&#x3D;”auto”,每个决策树的最大特征数量<ul><li>If “auto”, then <code>max_features=sqrt(n_features)</code>.</li><li>If “sqrt”, then <code>max_features=sqrt(n_features)</code> (same as “auto”).</li><li>If “log2”, then <code>max_features=log2(n_features)</code>.</li><li>If None, then <code>max_features=n_features</code>.</li></ul></li><li>bootstrap：boolean，optional（default &#x3D; True）是否在构建树时使用放回抽样</li><li>min_samples_split:节点划分最少样本数</li><li>min_samples_leaf:叶子节点的最小样本数</li></ul></li><li><p>超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf</p></li></ul><h3 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机森林去进行预测</span><br>rf = RandomForestClassifier()<br><br>param = &#123;<span class="hljs-string">&quot;n_estimators&quot;</span>: [<span class="hljs-number">120</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">500</span>,<span class="hljs-number">800</span>,<span class="hljs-number">1200</span>], <span class="hljs-string">&quot;max_depth&quot;</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>]&#125;<br><br><span class="hljs-comment"># 超参数调优</span><br>gc = GridSearchCV(rf, param_grid=param, cv=<span class="hljs-number">2</span>)<br><br>gc.fit(x_train, y_train)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;随机森林预测的准确率为：&quot;</span>, gc.score(x_test, y_test))<br></code></pre></td></tr></table></figure><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ul><li>在当前所有算法中，具有极好的准确率</li><li>能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维</li><li>能够评估各个特征在分类问题上的重要性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AppDelegate组件解耦</title>
    <link href="/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/"/>
    <url>/2019/09/16/AppDelegate%E7%BB%84%E4%BB%B6%E8%A7%A3%E8%80%A6/</url>
    
    <content type="html"><![CDATA[<p>在没有实行组件化的项目中，经常会在 AppDelegate 看到各类初始化代码，这一部分代码一般用以配置某些 key 以及 secret ，或者开启某些服务，常见的有第三方推送、统计分析、IM服务等。当然，也有可能是开启一些自身的服务，比如 log 日志、 数据库初始化等。当一个 App 达到一定体量后， 未经整理的 AppDelegate 可能会变得臃肿。那么在实行组件化之后，该如何处理这部分代码呢？</p><h2 id="不管理组件生命周期"><a href="#不管理组件生命周期" class="headerlink" title="不管理组件生命周期"></a>不管理组件生命周期</h2><p>不对组件生命周期进行管理，那么只能继续将这些初始化代码放在主工程的 AppDelegate 中，而针对上文所说的 AppDelegate 臃肿的问题，也可以通过简单的封装来优化。</p><p>但是，这种做法会引发组件独立性问题。比如存在能独立运行的组件 A、B，B 依赖 A， A 生效需要在 App Launch 时调用配置代码 Code-A。如果采用上述做法，那么组件 A 所在示例工程的 AppDelegate 中，需要调用 Code-A 进行配置，而组件 B 因为依赖了 组件 A ，要使组件 B 能成功运行，也需要在 B 的示例工程添加 Code-A 进行配置。同样主工程的 AppDelegate 中也存在一份 Code-A 配置代码。可以看到，这种重复手动配置的做法是比较繁琐和难看的，这也是为什么要对组件生命周期进行管理的原因。</p><h2 id="现有实现管理方案"><a href="#现有实现管理方案" class="headerlink" title="现有实现管理方案"></a>现有实现管理方案</h2><p>从组件和主工程的关系切入，既然组件需要在 App 生命周期的某些阶段处理特定的事务，那么就提供特定的回调方法供组件使用。 App 生命周期各个阶段产生的事件，可以通过让 AppDelegate 遵守 UIApplicationDelegate 协议并实现不同的代理方法进行捕获。</p><p>要想把当前阶段 App 产生的事件分发给各个组件，最简单的方案就是如 <a href="http://limboy.me/tech/2016/03/10/mgj-components.html">limboy</a> 所说，在 AppDelegate 的各个代理方法里，手动调一遍组件的对应方法，如果组件实现了对应的代理方法，就执行：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (<span class="hljs-symbol">BOOL</span>)application:(<span class="hljs-symbol">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-symbol">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-symbol">MGJApp</span> startApp];<br><br>    [[<span class="hljs-symbol">ModuleManager</span> sharedInstance] loadModuleFromPlist:[[<span class="hljs-symbol">NSBundle</span> mainBundle] pathForResource:@<span class="hljs-string">&quot;modules&quot;</span> ofType:@<span class="hljs-string">&quot;plist&quot;</span>]];<br>    <span class="hljs-symbol">NSArray</span> *modules = [[<span class="hljs-symbol">ModuleManager</span> sharedInstance] allModules];<br>    for (id&lt;<span class="hljs-symbol">ModuleProtocol</span>&gt; module in modules) &#123;<br>        if ([module respondsToSelector:<span class="hljs-symbol">_cmd</span>]) &#123;<br>            [module application:application didFinishLaunchingWithOptions:launchOptions];<br>        &#125;<br>    &#125;<br><br>    [self trackLaunchTime];<br>    return <span class="hljs-symbol">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这种方式缺点也很明显，组件需要依赖主工程的 AppDelegate 是否实现了 UIApplicationDelegate 的代理方法，如果没有的话，即使组件方实现了对应的代理方法，依然无法捕获到事件。</p><p>再来看下 <a href="http://www.jianshu.com/u/d8a653fc1cb1">caojun</a> 的处理方案 <a href="https://github.com/mdsb100/YTXModule">YTXModule</a>。 这个方案主要思路是通过 runtime method swizzling，替换 AppDelegate 中实现的 UIApplicationDelegate 代理方法，然后在 swizzled method 中，执行事件分发。 YTXModule 提供了一些宏定义，精简了方法替换流程：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIApplication</span> (<span class="hljs-title">YTXModule</span>)</span><br>- (<span class="hljs-type">void</span>)module_setDelegate:(<span class="hljs-type">id</span>&lt;<span class="hljs-built_in">UIApplicationDelegate</span>&gt;) delegate<br>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> delegateOnceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;delegateOnceToken, ^&#123;<br>        SWIZZLE_DELEGATE_METHOD(applicationDidFinishLaunching:);<br>        ...<br>    &#125;);<br>    [<span class="hljs-keyword">self</span> module_setDelegate:delegate];<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">YTXModule</span></span><br>...<br>+ (<span class="hljs-type">BOOL</span>)ytxmodule_application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;   <br>    DEF_APPDELEGATE_METHOD_CONTAIN_RESULT(application, launchOptions);<br>&#125;<br>...<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这里需要注意的是，由于 method swizzling 是在不同类型载体（AppDelegate对象 &lt;-&gt; YTXModule类）间交换的方法，所以会造成在 <code>+ytxmodule_applicationDidFinishLaunching:</code> 中调用 <code>self</code> 时，获取的并不是 YTXModule类，而是 AppDelegate对象，因为方法替换实际上替换了 IMP，并没有改变实参，参照 <code>objc_msgSend(id self, SEL op, ... )</code> 的参数排列，可以明确第一个参数是消息接收者，也就是 AppDelegate对象。通过上述分析可以知道，如果直接进行方法替换，不做特殊处理，使用以下代码将会抛出 <code>unrecognized selector </code>异常 ：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">+ (BOOL)ytxmodule_application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions<br>&#123;<br>// self is AppDelegate<span class="hljs-built_in"> instance</span><br><span class="hljs-built_in"></span>    [self ytxmodule_application:application didFinishLaunchingWithOptions:launchOptions];<br>&#125;<br></code></pre></td></tr></table></figure><p>而以下代码，是可以正常运行的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">BOOL</span>)ytxmodule_application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br> [YTXModule ytxmodule_application:application didFinishLaunchingWithOptions:launchOptions];<br>&#125;<br></code></pre></td></tr></table></figure><p>所以 caojun 在方法替换时，给 AppDelegate 添加了相同命名的实例方法，规避了这个异常 ：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">void Swizzle(<span class="hljs-keyword">Class</span> <span class="hljs-keyword">class</span>, SEL originalSelector, <span class="hljs-keyword">Method</span> <span class="hljs-title function_">swizzledMethod</span>)<br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="hljs-comment">    SEL swizzledSelector = method_getName(swizzledMethod);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    BOOL didAddMethod =</span><br><span class="hljs-comment">    class_addMethod(class,</span><br><span class="hljs-comment">                    originalSelector,</span><br><span class="hljs-comment">                    method_getImplementation(swizzledMethod),</span><br><span class="hljs-comment">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if (didAddMethod &amp;&amp; originalMethod) &#123;</span><br><span class="hljs-comment">        class_replaceMethod(class,</span><br><span class="hljs-comment">                            swizzledSelector,</span><br><span class="hljs-comment">                            method_getImplementation(originalMethod),</span><br><span class="hljs-comment">                            method_getTypeEncoding(originalMethod));</span><br><span class="hljs-comment">    &#125;</span> <span class="hljs-title function_">else</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="hljs-comment">    &#125;</span><br>    // 这一步给 <span class="hljs-title function_">AppDelegate</span> 添加相同命名的实例方法，并且其 <span class="hljs-title function_">IMP</span> 是 <span class="hljs-title function_">AppDelegate</span> 自身方法的原实现<br>    <span class="hljs-title function_">class_addMethod</span><span class="hljs-params">(<span class="hljs-keyword">class</span>,</span><br><span class="hljs-params">                    swizzledSelector,</span><br><span class="hljs-params">                    method_getImplementation(swizzledMethod)</span>,<br>                    <span class="hljs-title function_">method_getTypeEncoding</span><span class="hljs-params">(swizzledMethod)</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽说这种方案也能实现事件的分发，但是在不同类型载体间使用 method swizzling 还是应该避免的，对其他开发者不是很友好。并且这种方案也存在依赖 YTXModule 是否替换了 UIApplicationDelegate 的代理方法问题，如果没有，组件方是无法捕获事件的。</p><span id="more"></span><h2 id="一种更加优雅的方案"><a href="#一种更加优雅的方案" class="headerlink" title="一种更加优雅的方案"></a>一种更加优雅的方案</h2><blockquote><p>分发、代理</p></blockquote><p>看到这两个关键词，可以直接联想到 runtime 的另一重要组成部分，消息转发。以下是我结合消息转发实现的组件生命周期管理方案。</p><p>先看下 UML 类图：</p><p><a href="https://dmanager.github.io/assets/images/2017-10-25-zu-jian-sheng-ming-zhou-qi/1509178037666.jpg"><img src="https://dmanager.github.io/assets/images/2017-10-25-zu-jian-sheng-ming-zhou-qi/1509178037666.jpg" alt="img"></a></p><p>首先是 TDFModule ，模块基类，所有想要捕获 App 生命周期事件的模块都需要创建一个继承 TDFModule 的类，并且遵守 TDFModuleProtocol 协议：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 模块子类必须遵守此协议</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">TDFModuleProtocol</span> &lt;<span class="hljs-title">UIApplicationDelegate</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 模块优先级</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> - TDFModulePriorityVeryLow: 极底</span><br><span class="hljs-comment"> - TDFModulePriorityLow: 低</span><br><span class="hljs-comment"> - TDFModulePriorityMedium: 中</span><br><span class="hljs-comment"> - TDFModulePriorityHigh: 高</span><br><span class="hljs-comment"> - TDFModulePriorityVeryHigh: 极高</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteger</span>, TDFModulePriority) &#123;<br>    TDFModulePriorityVeryLow = <span class="hljs-number">0</span>,<br>    TDFModulePriorityLow = <span class="hljs-number">1</span>,<br>    TDFModulePriorityMedium = <span class="hljs-number">2</span>,<br>    TDFModulePriorityHigh = <span class="hljs-number">3</span>,<br>    TDFModulePriorityVeryHigh = <span class="hljs-number">4</span>,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TDFModule</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)module;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 在 load 中调用，以注册模块</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">void</span>)registerModule;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 模块优先级</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> 主工程模块的调用最先进行，剩余附属模块，</span><br><span class="hljs-comment"> 内部会根据优先级，依次调用 UIApplicationDelegate 代理</span><br><span class="hljs-comment"> 默认是 TDFModulePriorityMedium</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @return 优先级</span><br><span class="hljs-comment"> */</span><br>+ (TDFModulePriority)priority;<br><span class="hljs-keyword">@end</span><br><br><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TDFModule</span></span><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">TDFModuleProtocol</span>)]) </span>&#123;<br>            <span class="hljs-keyword">@throw</span> [<span class="hljs-built_in">NSException</span> exceptionWithName:<span class="hljs-string">@&quot;TDFModuleRegisterProgress&quot;</span> reason:<span class="hljs-string">@&quot;subclass should confirm to &lt;TDFModuleProtocol&gt;.&quot;</span> userInfo:<span class="hljs-literal">nil</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>+ (<span class="hljs-keyword">instancetype</span>)module &#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> alloc] init];<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)registerModule &#123;<br>    [TDFModuleManager addModuleClass:<span class="hljs-keyword">self</span>];<br>&#125;<br><br>+ (TDFModulePriority)priority &#123;<br>    <span class="hljs-keyword">return</span> TDFModulePriorityMedium;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类需要在 <code>+load</code> 方法中调用 <code>registerModule</code> 才能让模块具备捕获 App 事件的能力。因为 TDFModuleProtocol 直接遵守的 UIApplicationDelegate 协议，子类可以和 AppDelegate 一样，直接实现自己感兴趣的代理方法即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TDFAModule</span> : <span class="hljs-title">TDFModule</span> &lt;<span class="hljs-title">TDFModuleProtocol</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TDFAModule</span></span><br>+ (<span class="hljs-type">void</span>)load &#123;<br>    [<span class="hljs-keyword">self</span> registerModule];<br>&#125;<br><br>+ (TDFModulePriority)priority &#123;<br>    <span class="hljs-keyword">return</span> TDFModulePriorityHigh;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@, %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]), <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)applicationWillEnterForeground:(<span class="hljs-built_in">UIApplication</span> *)application &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@, %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]), <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>&#125;<br><br>- (<span class="hljs-type">void</span>)applicationDidBecomeActive:(<span class="hljs-built_in">UIApplication</span> *)application &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@, %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]), <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>&#125;<br><br>- (<span class="hljs-type">void</span>)applicationWillTerminate:(<span class="hljs-built_in">UIApplication</span> *)application &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@, %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]), <span class="hljs-built_in">NSStringFromSelector</span>(_cmd));<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>以上就是一个简单的使用示例。</p><p>接下来是 TDFModuleManager ，模块管理类。这个单例类主要负责模块的储存，以及在 UIApplication 的 <code>-setDelegate:</code> 中，把原来 delegate 替换成自己的 delegate proxy 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TDFModuleManager</span> : <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@package</span><br>    TDFApplicationDelegateProxy *_proxy;<br>&#125;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) TDFApplicationDelegateProxy *proxy;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSArray</span> &lt;TDFModule *&gt; *modules;<br><br>+ (<span class="hljs-keyword">instancetype</span>)shared;<br>+ (<span class="hljs-type">void</span>)addModuleClass:(Class)cls;<br>+ (<span class="hljs-type">void</span>)removeModuleClass:(Class)cls;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSMutableArray</span> <span class="hljs-keyword">const</span> * TDFModuleClassArray = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TDFModuleManager</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)shared &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-keyword">static</span> TDFModuleManager *singleton = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        singleton = [[<span class="hljs-keyword">self</span> alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> singleton;<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)addModuleClass:(Class)cls &#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(cls &amp;&amp; [cls isSubclassOfClass:[TDFModule <span class="hljs-keyword">class</span>]]);<br><br>    <span class="hljs-keyword">if</span> (!TDFModuleClassArray) &#123;<br>        TDFModuleClassArray = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (![TDFModuleClassArray containsObject:cls]) &#123;<br>        [TDFModuleClassArray addObject:cls];<br>    &#125;<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)removeModuleClass:(Class)cls &#123;<br>    [TDFModuleClassArray removeObject:cls];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)generateRegistedModules &#123;<br>    [<span class="hljs-keyword">self</span>.mModules removeAllObjects];<br><br>    [TDFModuleClassArray sortUsingDescriptors:@[[[<span class="hljs-built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="hljs-string">@&quot;priority&quot;</span> ascending:<span class="hljs-literal">NO</span>]]];<br><br>    <span class="hljs-keyword">for</span> (Class cls <span class="hljs-keyword">in</span> TDFModuleClassArray) &#123;<br>        TDFModule *module = [cls module];<br>        <span class="hljs-built_in">NSAssert</span>(module, <span class="hljs-string">@&quot;module can&#x27;t be nil of class %@&quot;</span>, <span class="hljs-built_in">NSStringFromClass</span>(cls));<br><br>        <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span>.mModules containsObject:module]) &#123;<br>            [<span class="hljs-keyword">self</span>.mModules addObject:module];<br>        &#125;<br>    &#125;<br>&#125;<br><br>- (TDFApplicationDelegateProxy *)proxy &#123;<br>    <span class="hljs-keyword">if</span> (!_proxy) &#123;<br>        _proxy = [[TDFApplicationDelegateProxy alloc] init];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> _proxy;<br>&#125;<br><br>- (<span class="hljs-built_in">NSArray</span>&lt;TDFModule *&gt; *)modules &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">NSArray</span>&lt;TDFModule *&gt; *)<span class="hljs-keyword">self</span>.mModules;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMutableArray</span>&lt;TDFModule *&gt; *)mModules &#123;<br>    <span class="hljs-keyword">if</span> (!_mModules) &#123;<br>        _mModules = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> _mModules;<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> MCDSwizzleInstanceMethod(Class cls, SEL originalSelector, Class targetCls, SEL swizzledSelector) &#123;<br>    Method originalMethod = class_getInstanceMethod(cls, originalSelector);<br>    Method swizzledMethod = class_getInstanceMethod(targetCls, swizzledSelector);<br>    <span class="hljs-type">BOOL</span> didAddMethod = class_addMethod(cls, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));<br>    <span class="hljs-keyword">if</span> (didAddMethod) &#123;<br>        class_replaceMethod(cls, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        method_exchangeImplementations(originalMethod, swizzledMethod);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIApplication</span> (<span class="hljs-title">TDFModule</span>)</span><br>+ (<span class="hljs-type">void</span>)load &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        MCDSwizzleInstanceMethod(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(setDelegate:), <span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(mcd_setDelegate:));<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)mcd_setDelegate:(<span class="hljs-type">id</span> &lt;<span class="hljs-built_in">UIApplicationDelegate</span>&gt;)delegate &#123;<br>    TDFModuleManager.shared.proxy.realDelegate = delegate;<br>    [TDFModuleManager.shared generateRegistedModules];<br><br>    [<span class="hljs-keyword">self</span> mcd_setDelegate:(<span class="hljs-type">id</span> &lt;<span class="hljs-built_in">UIApplicationDelegate</span>&gt;)TDFModuleManager.shared.proxy];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>最后是这个方案的重点，也就是 TDFApplicationDelegateProxy 类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TDFApplicationDelegateProxy</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">id</span> &lt;<span class="hljs-built_in">UIApplicationDelegate</span>&gt; realDelegate;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TDFApplicationDelegateProxy</span></span><br>- (Protocol *)targetProtocol &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">UIApplicationDelegate</span>);</span><br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isTargetProtocolMethod:(SEL)selector &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> outCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> objc_method_description *methodDescriptions = protocol_copyMethodDescriptionList([<span class="hljs-keyword">self</span> targetProtocol], <span class="hljs-literal">NO</span>, <span class="hljs-literal">YES</span>, &amp;outCount);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; outCount; idx++) &#123;<br>        <span class="hljs-keyword">if</span> (selector == methodDescriptions[idx].name) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>        &#125;<br>    &#125;<br>    free(methodDescriptions);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.realDelegate respondsToSelector:aSelector]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (TDFModule *module <span class="hljs-keyword">in</span> [TDFModuleManager shared].modules) &#123;<br>        <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> isTargetProtocolMethod:aSelector] &amp;&amp; [module respondsToSelector:aSelector]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> [<span class="hljs-variable language_">super</span> respondsToSelector:aSelector];<br>&#125;<br><br>- (<span class="hljs-type">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> isTargetProtocolMethod:aSelector] &amp;&amp; [<span class="hljs-keyword">self</span>.realDelegate respondsToSelector:aSelector]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.realDelegate;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;<br>    <span class="hljs-keyword">struct</span> objc_method_description methodDescription = protocol_getMethodDescription([<span class="hljs-keyword">self</span> targetProtocol], aSelector, <span class="hljs-literal">NO</span>, <span class="hljs-literal">YES</span>);<br><br>    <span class="hljs-keyword">if</span> (methodDescription.name == <span class="hljs-literal">NULL</span> &amp;&amp; methodDescription.types == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] instanceMethodSignatureForSelector:<span class="hljs-keyword">@selector</span>(doNothing)];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:methodDescription.types];;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *allModules = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObjects:<span class="hljs-keyword">self</span>.realDelegate, <span class="hljs-literal">nil</span>];<br>    [allModules addObjectsFromArray:[TDFModuleManager shared].modules];<br>    <br>    <span class="hljs-comment">// BOOL 型返回值做特殊 | 处理</span><br>    <span class="hljs-keyword">if</span> (anInvocation.methodSignature.methodReturnType[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>        <span class="hljs-type">BOOL</span> realReturnValue = <span class="hljs-literal">NO</span>;<br>        <br>        <span class="hljs-keyword">for</span> (TDFModule *module <span class="hljs-keyword">in</span> allModules) &#123;<br>            <span class="hljs-keyword">if</span> ([module respondsToSelector:anInvocation.selector]) &#123;<br>                [anInvocation invokeWithTarget:module];<br>                <br>                <span class="hljs-type">BOOL</span> returnValue = <span class="hljs-literal">NO</span>;<br>                [anInvocation getReturnValue:&amp;returnValue];<br>                <br>                realReturnValue = returnValue || realReturnValue;<br>            &#125;<br>        &#125;<br>        <br>        [anInvocation setReturnValue:&amp;realReturnValue];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (TDFModule *module <span class="hljs-keyword">in</span> allModules) &#123;<br>            <span class="hljs-keyword">if</span> ([module respondsToSelector:anInvocation.selector]) &#123;<br>                [anInvocation invokeWithTarget:module];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)doNothing &#123;&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>先说 <code>-respondsToSelector:</code> ，由于系统内部会调用这个方法，判断是否实现了对应的 UIApplicationDelegate 代理方法，所以这里结合 AppDelegate 以及所有注册的 Module 判断是否有相应实现。</p><p>当 <code>-respondsToSelector:</code> 返回 YES 后，程序来到消息转发第二步 Fast forwarding path ，对应方法 <code>-forwardingTargetForSelector:</code>，在这一步，我们判断转发的方法是否为 UIApplicationDelegate 的代理方法，如果不是，并且 realDelegate（也就是 AppDelegate） 能响应，就直接把消息转发给 realDelegate。</p><p>如果在上一步中没有把消息转发给 realDelegate，那么就到了消息转发的最后一步 Normal forwarding path ，对应方法 <code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code>，在这一步我们首先根据协议直接返回代理方法的签名，然后在 <code>-forwardInvocation:</code> 方法中，按照优先级，依次把消息转发给注册的模块。</p><p>在不做额外操作的前提下， <code>-forwardInvocation:</code> 中只有最后一次调用的返回值会成为实际返回值，当实现类似 <code>- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options</code> 等返回 BOOL 值的代理方法时，就会出现问题。所以这里通过判断返回值是否为 BOOL 类型，去执行不同的操作。如果为 BOOL 类型，则对所有返回值执行逻辑或操作，并将结果设置成实际返回值。</p><p>总结起来，流程如下：</p><p><a href="https://dmanager.github.io/assets/images/2017-10-25-zu-jian-sheng-ming-zhou-qi/1509083789825.jpg"><img src="https://dmanager.github.io/assets/images/2017-10-25-zu-jian-sheng-ming-zhou-qi/1509083789825.jpg" alt="img"></a></p><p>经过上面几步，就可以把 App 的事件分发给各个组件了，而且组件对事件的捕获是不依赖于外界（AppDelegate）实现的，只要进行注册就可以了，个人认为还是比较优雅的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS AppDelegate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>carsh定位总结</title>
    <link href="/2019/09/09/carsh%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/"/>
    <url>/2019/09/09/carsh%E5%AE%9A%E4%BD%8D%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="Crash-日志的渠道"><a href="#Crash-日志的渠道" class="headerlink" title="Crash 日志的渠道"></a>Crash 日志的渠道</h3><ul><li><strong>苹果收集的 Crash 日志</strong></li><li><ul><li>用户手机上 设置 -&gt; 隐私 -&gt; 分析 里面的，可以连接电脑 Xcode 导出。</li><li>在 Xcode -&gt; Window -&gt; Organizer -&gt; Crashes 里面可以查看</li></ul></li><li><strong>自己应用内收集的</strong></li><li><ul><li>接入一些 APM 产品， 如 EMAS、mPaaS、phabricator 等。</li><li>接入 PLCrashReporter 、 KSCrash 等 SDK 进行收集，上报到自建平台统计</li></ul></li></ul><p>![image-20220909155818088](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220909155818088.png)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>App瘦身</title>
    <link href="/2019/09/02/App%E7%98%A6%E8%BA%AB/"/>
    <url>/2019/09/02/App%E7%98%A6%E8%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-分析当前ipa的组成"><a href="#1-分析当前ipa的组成" class="headerlink" title="1 分析当前ipa的组成"></a>1 分析当前ipa的组成</h2><p>一般一个ipa会包含：</p><p>1） 资源文件</p><ul><li>本地文件：数据、配置、数据库等等</li><li>字体文件</li><li>图片资源</li></ul><ol start="2"><li>源代码</li></ol><p>通过生成linkmap文件，分析源代码生成的编译文件的大小。在Build Settings中Write Link Map File设置为Yes (记住release时候不要设置为Yes)。</p><p>编译之后会在build目录中生成两个LinkMap文件： XXX-LinkMap-normal-i386和XXX-LinkMap-normal-x86_64，分别代表在模拟器中32位和64位指令集生成的LinkMap文件。关于LinkMap的文件详细结构解释可以参考：<a href="http://blog.cnbang.net/tech/2296/">http://blog.cnbang.net/tech/2296/</a></p><p>LinkMap会包含每个可执行文件的偏移量及大小，所以可以很方便的知道每个可执行文件的大小。可以使用LinkMap分析工具：<a href="https://github.com/huanxsd/LinkMap">https://github.com/huanxsd/LinkMap</a></p><p><img src="https://images2017.cnblogs.com/blog/746857/201709/746857-20170906191955007-1995207350.png" alt="img"></p><h2 id="2-资源瘦身"><a href="#2-资源瘦身" class="headerlink" title="2 资源瘦身"></a>2 资源瘦身</h2><h3 id="无用的图片文件"><a href="#无用的图片文件" class="headerlink" title="无用的图片文件"></a>无用的图片文件</h3><p>查找无用的图片文件，使用LSUnusedResources（<a href="https://github.com/tinymind/LSUnusedResources%EF%BC%89">https://github.com/tinymind/LSUnusedResources）</a></p><p><img src="https://github.com/tinymind/LSUnusedResources/raw/master/LSUnusedResourcesExample.gif" alt="img"></p><h3 id="无损压缩图片"><a href="#无损压缩图片" class="headerlink" title="无损压缩图片"></a>无损压缩图片</h3><p>使用ImageOptim（<a href="https://github.com/ImageOptim/ImageOptim%EF%BC%89%E8%BF%9B%E8%A1%8Cpng%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9">https://github.com/ImageOptim/ImageOptim）进行png文件的无损压缩</a></p><p><img src="https://images2017.cnblogs.com/blog/746857/201709/746857-20170906192458647-804731014.png" alt="img"></p><h3 id="WebP图片压缩"><a href="#WebP图片压缩" class="headerlink" title="WebP图片压缩"></a>WebP图片压缩</h3><p>WebP是Google提供的一种图片编码格式，通常情况下WebP格式的图片是原始JPG&#x2F;PNG图片的1&#x2F;3，所以对于重度依赖图片显示的应用，转换使用WebP可以节省大量的网络传输数据和时间。对于APP瘦身，使用WebP格式可能是一种方式，可以使用WebP格式的图片替代现有的图片资源，可以一定程度的节省空间。</p><p>使用WebP转换工具（<a href="https://developers.google.com/speed/webp/docs/precompiled%EF%BC%89%E5%B0%9D%E8%AF%95%E8%BD%AC%E6%8D%A2%E4%BA%86%E5%87%A0%E5%BC%A0%E8%BE%83%E5%A4%A7%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%8C%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://developers.google.com/speed/webp/docs/precompiled）尝试转换了几张较大的图片，效果如下：</a></p><p><img src="https://images2017.cnblogs.com/blog/746857/201709/746857-20170906192710054-1516701797.png" alt="img"></p><p>iOS原生并不支持WebP格式加载，需要引入SDWebImage&#x2F;WebP，详细可以参考：<a href="http://blog.devzeng.com/blog/ios-webp-usage.html">http://blog.devzeng.com/blog/ios-webp-usage.html</a></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">`<span class="hljs-built_in">NSString</span> *path = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:``<span class="hljs-string">@&quot;logo&quot;</span>` `ofType:``<span class="hljs-string">@&quot;webp&quot;</span>``];``<span class="hljs-built_in">NSData</span> *data = [[<span class="hljs-built_in">NSData</span> alloc] initWithContentsOfFile:path];``<span class="hljs-built_in">UIImage</span> *img = [<span class="hljs-built_in">UIImage</span> sd_imageWithWebPData:data];``<span class="hljs-keyword">self</span>.imageView.image = img;`<br></code></pre></td></tr></table></figure><p>使用WebP格式的图片，似乎就抛弃了iOS @2x @3x按照设备加载对应图片的机制，所以应该还可以删除所有@2x图片，不过加载速度比原生较慢。</p> <span id="more"></span><h2 id="3-代码瘦身"><a href="#3-代码瘦身" class="headerlink" title="3 代码瘦身"></a>3 代码瘦身</h2><h3 id="AppCode代码静态检查"><a href="#AppCode代码静态检查" class="headerlink" title="AppCode代码静态检查"></a>AppCode代码静态检查</h3><p>AppCode提供了非常强大的代码静态检查工具，使用Inspect Code，可以找到很多代码优化的地方。可以参考这篇介绍：<a href="https://blog.jetbrains.com/objc/2014/01/appcode-inspections-for-your-code-perfection/">AppCode inspections for your code perfection</a></p><h3 id="清除无用代码"><a href="#清除无用代码" class="headerlink" title="清除无用代码"></a>清除无用代码</h3><p>AppCode搜索出来的无用的Class，会有误报需要仔细检查每一个报错的代码。</p><p>使用Fui（<a href="https://github.com/dblock/fui%EF%BC%89%E6%9F%A5%E6%89%BE%E5%8F%91%E7%8E%B0%E4%B8%8B%E5%88%97%E6%97%A0%E7%94%A8%E6%96%87%E4%BB%B6%EF%BC%8C%E5%90%8C%E6%A0%B7%E9%9C%80%E8%A6%81double">https://github.com/dblock/fui）查找发现下列无用文件，同样需要double</a> check避免误删</p><p><strong>清除无用的Import</strong></p><p>Fui（<a href="https://github.com/dblock/fui%EF%BC%89%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E6%9F%A5%E6%89%BE%E6%97%A0%E7%94%A8%E7%9A%84import%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B9%9F%E6%8F%90%E4%BE%9B[xcfui](https://github.com/jcavar/xcfui)">https://github.com/dblock/fui）可以用于查找无用的import，同时也提供[xcfui](https://github.com/jcavar/xcfui)</a> 可以和Xcode集成。</p><p><strong>清除无用的Method</strong></p><p>\1. 基于AppCode的扫描定期做清理</p><p>\2. 这篇文章提供了一个很好的思路可以一键删除无用方法：<a href="http://www.jianshu.com/p/a53480ad0364">http://www.jianshu.com/p/a53480ad0364</a></p><p><strong>查找相似的代码</strong></p><p>使用SameCodeFinder (<a href="https://github.com/startry/SameCodeFinder)%E5%8F%AF%E4%BB%A5%E6%9F%A5%E6%89%BE%E5%88%B0%E7%9B%B8%E4%BC%BC%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97%E4%BB%A3%E8%A1%A8%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%B7%E6%98%8E%E8%B7%9D%E7%A6%BB%EF%BC%8C%E6%95%B0%E5%AD%97%E8%B6%8A%E5%B0%8F%E8%AF%B4%E6%98%8E%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E8%B6%8A%E7%B1%BB%E4%BC%BC%E3%80%82">https://github.com/startry/SameCodeFinder)可以查找到相似的代码，最后一位数字代表两个文件的海明距离，数字越小说明两个文件越类似。</a></p><p><strong>清理其他无用的代码</strong> </p><p>\1. 已经下线的陈旧代码，AB试验已经下线的代码</p><p>\2. 通过转H5、Hybrid或者RN实现的Native功能，可以定期清理</p><p>\3. 一些非核心Hybrid或者RN模块，可以考虑不要打包进入APP，通过动态下发的方式获取</p><p>\4. 代码的重构，UI组件、业务逻辑的重用等等</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-一些参考文章"><a href="#4-一些参考文章" class="headerlink" title="4 一些参考文章"></a>4 一些参考文章</h2><ul><li>iOS可执行文件瘦身：<a href="http://blog.cnbang.net/tech/2544/">http://blog.cnbang.net/tech/2544/</a></li><li>iOS APP瘦身实践：<a href="http://www.jianshu.com/p/c94dedef90b7%EF%BC%8C%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E9%85%8D%E7%BD%AE%E4%BC%98%E5%8C%96%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">http://www.jianshu.com/p/c94dedef90b7，资源优化、编译器配置优化、可执行文件优化</a></li><li>滴滴出行iOS端瘦身实践: <a href="http://gmtc.geekbang.org/#schedule">http://gmtc.geekbang.org/#schedule</a>, 提供了查找无用图片的工具、WebP图片压缩、基于clang plugin实现查找无用代码（<a href="https://github.com/kangwang1988/XcodeZombieCode%EF%BC%89%E3%80%81%E6%9F%A5%E6%89%BE%E7%B1%BB%E4%BC%BC%E4%BB%A3%E7%A0%81%EF%BC%88https://github.com/startry/SameCodeFinder%EF%BC%89">https://github.com/kangwang1988/XcodeZombieCode）、查找类似代码（https://github.com/startry/SameCodeFinder）</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=2651112856&idx=1&sn=b2c74c62a10b4c9a4e7538d1ad7eb739">基于clang插件的一种iOS包大小瘦身方案</a></li><li><a href="http://jaq.alibaba.com/community/art/show?articleid=229">减小ipa体积之删除frameWork中无用mach-O文件</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cocoaPods忽略警告</title>
    <link href="/2019/08/30/CocoaPods%E5%BF%BD%E7%95%A5%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A/"/>
    <url>/2019/08/30/CocoaPods%E5%BF%BD%E7%95%A5%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%BC%96%E8%AF%91%E8%AD%A6%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>为了减少组件化后的工程集成时间，我们一般都会将三方库放到私有 GitLab 中，这也有利于开发者根据自家业务，对三方库进行定制包装。但是如果有些三方库更新较慢，以至于让新版本的 Xcode 产生很多警告，这就比较烦了，因为大部分情况下，更改三方库并不是一个明智的选择。</p><p>Podfile 提供了 <code>inhibit_all_warnings!</code> 以屏蔽所有 pod target 的警告，但其中也包括了非三方组件。同时，Podfile 提供了 <code>inhibit_warnings</code> 去针对单个 pod 的编译警告进行控制，比如：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pod <span class="hljs-string">&#x27;SSZipArchive&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">inhibit_warnings</span> =&gt;</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>以上代码只会屏蔽 SSZipArchive 组件的警告，这比较符合我们的诉求。不过 <code>inhibit_warnings</code> 只会禁止当前 pod 的警告，并不会一同处理依赖组件的警告，这就要求我们在 Podfile 中显式依赖所有三方组件，并且设置 <code>inhibit_warnings</code>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">def add<span class="hljs-constructor">_files_to_build_phases(<span class="hljs-params">native_target</span>, <span class="hljs-params">test_native_targets</span>)</span><span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>flags = compiler<span class="hljs-constructor">_flags_for_consumer(<span class="hljs-params">consumer</span>, <span class="hljs-params">arc</span>)</span><br>  regular_file_refs = project<span class="hljs-constructor">_file_references_array(<span class="hljs-params">files</span>, &#x27;<span class="hljs-params">source</span>&#x27;)</span><br>  native_target.add<span class="hljs-constructor">_file_references(<span class="hljs-params">regular_file_refs</span>, <span class="hljs-params">flags</span>)</span><span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span><span class="hljs-keyword">end</span><br><br>def compiler<span class="hljs-constructor">_flags_for_consumer(<span class="hljs-params">consumer</span>, <span class="hljs-params">arc</span>)</span><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><span class="hljs-keyword">if</span> target.inhibit_warnings?<br>    flags &lt;&lt; &#x27;-w -Xanalyzer -analyzer-disable-all-checks&#x27;<br>  <span class="hljs-keyword">end</span><br>  flags<span class="hljs-operator"> * </span><span class="hljs-character">&#x27; &#x27;</span><span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator"></span><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>可以看到，在添加文件至对应 target 时，<code>-w -Xanalyzer -analyzer-disable-all-checks</code> 同时被添加到了文件的 compiler flags （在Target -&gt; Build Phases -&gt; Compile Sources 中可见）。结合 Installer 的 install! 代码：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">install!</span></span><br>  prepare<br>  resolve_dependencies<br>  download_dependencies<br>  validate_targets<br>  generate_pods_project<br>  <span class="hljs-keyword">if</span> installation_options.integrate_targets?<br>    integrate_user_project<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-title class_">UI</span>.section <span class="hljs-string">&#x27;Skipping User Project Integration&#x27;</span><br>  <span class="hljs-keyword">end</span><br>  perform_post_install_actions<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_dependencies</span></span><br>  <span class="hljs-title class_">UI</span>.section <span class="hljs-string">&#x27;Downloading dependencies&#x27;</span> <span class="hljs-keyword">do</span><br>    install_pod_sources<br>    run_podfile_pre_install_hooks<br>    clean_pod_sources<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>generate_pods_project</code> 方法执行了 PodTargetInstaller 的 install! 操作，将文件添加到了 pod target ，那么只能在其之前的 <code>pre_install</code> 设置相关属性了。从上面的代码还可以看出，执行 <code>pre_install</code> 前就已经 <code>resolve_dependencies</code> 了，也就是说我们可以拿到 Analyzer 分析的完整结果 AnalysisResult :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Hash&#123;TargetDefinition =&gt; Array&lt;Specification&gt;&#125;] the</span><br><span class="hljs-comment">#         specifications grouped by target.</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">attr_accessor</span> <span class="hljs-symbol">:specs_by_target</span><br><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Array&lt;Specification&gt;] the specifications of the resolved</span><br><span class="hljs-comment">#         version of Pods that should be installed.</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">attr_accessor</span> <span class="hljs-symbol">:specifications</span><br><br><span class="hljs-comment"># <span class="hljs-doctag">@return</span> [Array&lt;AggregateTarget&gt;] The aggregate targets created for each</span><br><span class="hljs-comment">#         &#123;TargetDefinition&#125; from the &#123;Podfile&#125;.</span><br><span class="hljs-comment">#</span><br><span class="hljs-built_in">attr_accessor</span> <span class="hljs-symbol">:targets</span><br></code></pre></td></tr></table></figure><p>上面列出了此次需要涉及到的 AnalysisResult 属性。这里要注意的是 <code>targets</code> 属性是不包含 Pods Target 的，它只包含了 Podfile 里面声明的 target ，一般为组件本身，以及组件Tests。如果不确定要设置哪个 target ，可以手动设置 <code>inhibit_warnings</code> ，然后通过以下代码打印出 hash :</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coq">...<br>pod &#x27;SSZipArchive&#x27;, :inhibit_warnings =&gt; true<br>...<br><br>pre_install <span class="hljs-built_in">do</span> |<span class="hljs-type">installer</span>|<br><span class="hljs-type">require</span> &#x27;pp&#x27;<br>  installer.analysis_result.specs_by_target.each_key <span class="hljs-built_in">do</span> |<span class="hljs-type">target_definition</span>|<br>  <span class="hljs-type">pp</span> target_definition.to_hash<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这里我们对所有涉及到的 target 都进行设置。接着看下 CocoaPods Core 代码中 Podfile 是如何设置 <code>inhibit_warnings</code> 的 :</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pod</span>(<span class="hljs-params">name = <span class="hljs-literal">nil</span>, *requirements</span>)<br>  ...<br>  current_target_definition.store_pod(name, *requirements)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">store_pod</span>(<span class="hljs-params">name, *requirements</span>)<br>...<br>  parse_inhibit_warnings(name, requirements)<br>  ...<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_inhibit_warnings</span>(<span class="hljs-params">name, requirements</span>)<br>...<br>  set_inhibit_warnings_for_pod(pod_name, should_inhibit)<br>...<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment"># Inhibits warnings for a specific pod during compilation.</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_inhibit_warnings_for_pod</span>(<span class="hljs-params">pod_name, should_inhibit</span>)<br>  hash_key = <span class="hljs-keyword">case</span> should_inhibit<br>             <span class="hljs-keyword">when</span> <span class="hljs-literal">true</span><br>               <span class="hljs-string">&#x27;for_pods&#x27;</span><br>             <span class="hljs-keyword">when</span> <span class="hljs-literal">false</span><br>               <span class="hljs-string">&#x27;not_for_pods&#x27;</span><br>             <span class="hljs-keyword">when</span> <span class="hljs-literal">nil</span><br>               <span class="hljs-keyword">return</span><br>             <span class="hljs-keyword">else</span><br>               <span class="hljs-keyword">raise</span> <span class="hljs-title class_">ArgumentError</span>, <span class="hljs-string">&quot;Got `<span class="hljs-subst">#&#123;should_inhibit.inspect&#125;</span>`, should be a boolean&quot;</span><br>             <span class="hljs-keyword">end</span><br>  raw_inhibit_warnings_hash[hash_key] |<span class="hljs-params"></span>|= []<br>  raw_inhibit_warnings_hash[hash_key] &lt;&lt; pod_name<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>找到了设置 inhibit_warnings 的 public 方法 <code>set_inhibit_warnings_for_pod</code>。</p><p>由于我们的三方库集中放在 cocoapods-repos 的 group 下，最终的 <code>pre_install</code> 长这样 :</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">pre_install <span class="hljs-keyword">do</span> |installer|<br>  installer.analysis_result.specs_by_target.each_key <span class="hljs-keyword">do</span> |target_definition|<br>    installer.analysis_result.specifications.<span class="hljs-keyword">each</span> <span class="hljs-keyword">do</span> |spec|<br>      <span class="hljs-keyword">source</span> = spec.attributes_hash[<span class="hljs-string">&#x27;source&#x27;</span>]<br>      <span class="hljs-keyword">source</span> &amp;&amp;= <span class="hljs-keyword">source</span>[<span class="hljs-string">&#x27;git&#x27;</span>]<br>      <span class="hljs-keyword">next</span> unless <span class="hljs-keyword">source</span> &amp;&amp; <span class="hljs-keyword">source</span>.<span class="hljs-keyword">include</span>?(<span class="hljs-string">&#x27;cocoapods-repos&#x27;</span>)<br><br>      targets = (Array(target_definition) + target_definition.children)<br>      targets.<span class="hljs-keyword">each</span> <span class="hljs-keyword">do</span> |target|<br>        target.set_inhibit_warnings_for_pod(spec.root.name, <span class="hljs-keyword">true</span>)<br>      end<br>    end<br>  end<br>end<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>量化交易</title>
    <link href="/2019/08/30/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    <url>/2019/08/30/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1、-量化交易介绍"><a href="#1、-量化交易介绍" class="headerlink" title="1、 量化交易介绍"></a>1、 量化交易介绍</h2><p><strong>股票的量化投资：</strong>可以说是一种价值投资，我们所做的也是去挖掘市场中的价值股票，而并非去预测股票涨跌来进行投资等等（至少目前机构不会采取这种方式指导投资），这需要大家明确的一个问题。</p><p>量化回测框架提供<strong>完整的数据</strong>，以及<strong>回测机制进行策略评估研究</strong>，并能够实时进行模拟交易。为实盘交易提供选择。</p><p><img src="/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/%E9%87%8F%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="image"></p><span id="more"></span><h3 id="1-1流程包含的内容"><a href="#1-1流程包含的内容" class="headerlink" title="1.1流程包含的内容"></a>1.1流程包含的内容</h3><ul><li>获取数据：<ul><li>公司财务、新闻数据</li><li>基本行情数据</li></ul></li><li>数据分析挖掘：<ul><li>数据处理，标准化，去极值，中性化分组回测，行业分布</li></ul></li><li>构建策略:<ul><li>多因子策略</li></ul></li><li>回测、策略分析:<ul><li>评估分析策略可行性</li></ul></li><li>模拟交易:<ul><li>接入实时行情，实时获取成交回报</li><li>实时监控，实时归因分析</li></ul></li><li>实盘交易:<ul><li>接入真实券商账户</li></ul></li></ul><h3 id="1-2-分析结果"><a href="#1-2-分析结果" class="headerlink" title="1.2 分析结果"></a>1.2 分析结果</h3><p>我们最终想要的结果就是在回测当中表现的较好的分析方法和策略。比如：<br><img src="/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/%E7%BB%93%E6%9E%9C.png" alt="image_2"></p><h2 id="2、回测框架介绍"><a href="#2、回测框架介绍" class="headerlink" title="2、回测框架介绍"></a>2、回测框架介绍</h2><p><img src="/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/%E4%BA%91%E7%AB%AF%E6%A1%86%E6%9E%B6.png" alt="im"></p><ul><li><p>2.1、RiceQuant平台<a href="https://www.ricequant.com/algorithms">https://www.ricequant.com/algorithms</a> </p></li><li><p>wind平台获取全面数据<a href="https://www.wind.com.cn/NewSite/data.html">https://www.wind.com.cn/NewSite/data.html</a></p><blockquote></blockquote></li></ul><h2 id="3、Alpha和Beta"><a href="#3、Alpha和Beta" class="headerlink" title="3、Alpha和Beta"></a>3、Alpha和Beta</h2><p>每个投资策略的收益率可以分解成为两部分:</p><ul><li>一部分与市场完全相关，整个市场的平均收益率乘以一个贝塔系数。贝塔可以称为这个投资组合的系统风险</li><li>另一部分和整个市场无关的叫做阿尔法(Alpha)</li></ul><p><img src="/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/alpha%E4%B8%8Ebeta.png" alt="alpha_beta"></p><blockquote><p>1、Alpha很难得，Beta很容易。<br>2、Alpha就是精选个股，跑赢市场。<br>3、Beta就是有市场行情时跟上，有风险时候躲避</p></blockquote><h4 id="3-1-多因子策略的优势"><a href="#3-1-多因子策略的优势" class="headerlink" title="3.1 多因子策略的优势"></a>3.1 多因子策略的优势</h4><ul><li>多元因子，阿尔法收益的来源丰富，多因子持续稳定</li><li><strong>根据市场环境的变化选取最优因子和权重，模型可修改</strong></li></ul><h4 id="3-2-FF五因子模型"><a href="#3-2-FF五因子模型" class="headerlink" title="3.2  FF五因子模型"></a>3.2  FF五因子模型</h4><p>市场资产组合、市值因子(SMB)、账面市值比因子(HML)、盈利因子和成长因子<br><img src="/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/%E5%A4%9A%E5%9B%A0%E5%AD%90%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90.png"></p><h2 id="4、多因子策略流程"><a href="#4、多因子策略流程" class="headerlink" title="4、多因子策略流程"></a>4、多因子策略流程</h2><ul><li><h2 id="1、单因子有效性分析-因子IC分析-：因子暴露值和-股票下期的实际回报值的相关系数-IC分析平台-alphalens-https-github-com-quantopian-alphalens"><a href="#1、单因子有效性分析-因子IC分析-：因子暴露值和-股票下期的实际回报值的相关系数-IC分析平台-alphalens-https-github-com-quantopian-alphalens" class="headerlink" title="1、单因子有效性分析- 因子IC分析 ：因子暴露值和 股票下期的实际回报值的相关系数  - IC分析平台 alphalens https://github.com/quantopian/alphalens"></a><strong>1、单因子有效性分析</strong><br>- 因子IC分析 ：因子暴露值和 股票下期的实际回报值的相关系数<br>  - IC分析平台 alphalens <a href="https://github.com/quantopian/alphalens">https://github.com/quantopian/alphalens</a></h2><ul><li>因子收益率分析：确定因子的方向</li></ul></li><li><strong>2、多因子相关性分析</strong><ul><li>相关性分析还是使用斯皮尔曼秩相关系数</li><li>IC分析值建立表格，筛选出数值</li></ul></li><li><strong>3、多因子合成</strong></li></ul><p>先从上百个因子当中分析出对股票收益率有效的部分因子（这个数量可以根据筛选的严格程度去做）</p><ul><li>在每个大类因子当中去做筛选，每个大类因子中筛选出有效的N个因子</li><li><pre><code class="hljs">                                                                                                                                                                  例如筛选出20个有效因子</code></pre></li><li>2、合并相关性强的因子<ul><li><strong>最终得出有效的，相关性弱的因子，数量不多，一般在10个左右</strong></li></ul></li></ul><!--more--><h2 id="5、策略评价指标"><a href="#5、策略评价指标" class="headerlink" title="5、策略评价指标"></a>5、策略评价指标</h2><ul><li><p><strong>2.3 收益指标</strong></p><ul><li>回测收益率</li><li>年化收益率</li><li>基准收益率<br>相同条件下，一个简单的买入并持有基准合约策略的收益率（默认基准合约为沪深300指数，这里假设指数可交易，最小交易单位为1）。</li></ul></li><li><p>2.4 风险指标<br>风险指标指的是在获得收益的时候，承担一些风险值</p><ul><li>最大回撤</li></ul><blockquote><p>最大回撤越小越好，最大回撤最好保持10~30%之间</p></blockquote><ul><li>夏普比率</li></ul></li></ul><blockquote><p>举例而言，假如国债的回报是4%，而您的投资组合预期回报是16%，您的投资组合的标准偏差是5%，那么用16%－4%,可以得出12%（代表您超出无风险投资的回报），再用12%÷5%＝2.4，代表投资者风险每增长1%，换来的是2.4%的多余收益。夏普比率越大，说明单位风险所获得的风险回报越高。</p></blockquote><blockquote><p>最终夏普比率越高越好，达到1.5以上已经是很好的结果</p></blockquote><h2 id="6、-打分法选股"><a href="#6、-打分法选股" class="headerlink" title="6、 打分法选股"></a>6、 打分法选股</h2><h2 id="7、1、MACD策略交易信号分析"><a href="#7、1、MACD策略交易信号分析" class="headerlink" title="7、1、MACD策略交易信号分析"></a>7、1、MACD策略交易信号分析</h2><p><img src="/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/%E8%B6%8B%E5%8A%BF%E8%BF%BD%E8%B8%AA%E7%AD%96%E7%95%A5.png" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>量化交易</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>swift小总结</title>
    <link href="/2019/08/10/swift%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2019/08/10/swift%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="1、混编方式"><a href="#1、混编方式" class="headerlink" title="1、混编方式"></a>1、<a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c">混编方式</a></h3><p>1、SWIFT_OBJC_BRIDGING_HEADER方式适用简单项目</p><ul><li><p>简单的项目可以直接使用<code>projectName--Bridging-Header.h</code>文件的方式，将需要暴露给swift的oc类包含进去。</p></li><li><p>Swift 访问 Objective-C</p><p>只需要在桥接文件中（Bridging-Header.h）中导入需要暴露给 Swift 模块的 Objective-C 类，即可在 Swift 中访问相应 Objective-C 的类和方法</p></li><li><p>Objective-C 访问 Swift</p><p>在 Objective-C 类中导入 <code>ProductName-Swift.h</code>，即可访问 Swift 中暴露给 Objective-C 的类和方法</p></li></ul><p>2、含三方库，业务分库的较复杂的项目</p><ul><li><p>Swift 访问 Objective-C</p><p>用 Swift Module 系统，需要用到的 Objective-C 类用 import xxx 进行引用，即可在 Swift 中访问相应的 Objective-C 的类和方法</p></li><li><p>Objective-C 访问 Swift</p><p>在 Objective-C 类中导入 <code>ProductName-Swift.h</code>，即可访问 Swift 中暴露给 Objective-C 的类和方法</p><span id="more"></span><p>补充</p><ul><li><p>纯swift构成的pod，使用时直接<code>@import module</code>就行</p></li><li><p>oc和swift混合构成的pod</p><ul><li>pod中oc类中使用swift类，需要通过<code>SWIFT_OBJC_INTERFACE_HEADER_NAME</code>头文件中先导入需要暴露(<em><code>public</code></em>)给oc使用的swift类, 然后oc中引用<code>#import &quot;YourPodModule-Swift.h&quot;</code>, <code>#import &quot;YourPodModule-Swift.h&quot;</code>无法直接在主工程引入</li><li><em><code>podfile</code>*中配置*<code>use_modular_headers!</code></em>, 主工程通过<code>@import module</code>导入含swift的pod即可访问暴露给外部的swift类。iOS头文件引入变迁<code>#include-&gt;#import-&gt;pch-&gt;@import</code>, <code>@import</code>接解决了编译时间和引用泛滥的问题，建议项目中大量使用。</li></ul></li></ul></li></ul><p>3、继承</p><ul><li><pre><code class="hljs">1、使是继承自NSObject的类，也需要显式添加@objc才能访问。在此之前是默认添加的。2、swift的类如果想通过动态性动态生成，比如`Class cls = NSClassFromString(clsName);`@objc(HSAShortVideoDetailViewController)<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-number">4</span><span class="hljs-operator">、</span>[<span class="hljs-keyword">@objc</span>的一些规则](https:<span class="hljs-comment">//github.com/apple/swift-evolution/blob/master/proposals/0160-objc-inference.md)</span><br><br><span class="hljs-operator">-</span> ```<br>  <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">protocol</span> p &#123;<br>      <span class="hljs-keyword">func</span> name()<br>  &#125;<br>  <br>  <span class="hljs-keyword">extension</span> p &#123;<br>      <span class="hljs-keyword">func</span> bar() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;bar&quot;</span>)<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">class</span> C: <span class="hljs-type">NSObject</span>, p &#123;<br>      <br>     <span class="hljs-keyword">func</span> name() &#123;<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name<span class="hljs-subst">\n</span>&quot;</span>)<br>      &#125;<br>      <br>     <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> aaa() &#123;<br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;aaa&quot;</span>)<br>      &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">let</span> c <span class="hljs-operator">=</span> <span class="hljs-type">C</span>()<br>  <br>  <span class="hljs-built_in">print</span>(c.responds(to: <span class="hljs-type">Selector</span>(<span class="hljs-string">&quot;name&quot;</span>)))  <span class="hljs-comment">// true</span><br>  <span class="hljs-built_in">print</span>(c.responds(to: <span class="hljs-type">Selector</span>(<span class="hljs-string">&quot;bar&quot;</span>)))   <span class="hljs-comment">// false</span><br>  <span class="hljs-built_in">print</span>(c.responds(to: <span class="hljs-type">Selector</span>(<span class="hljs-string">&quot;aaa&quot;</span>)))   <span class="hljs-comment">// true</span><br>  <br>  <br>  ## <span class="hljs-keyword">@objc</span> 并不改变访问级别，默认是<span class="hljs-type">Internal</span>; 下面的例子中编译时不允许访问，运行时可访问<br>  # pod中定义的swift <span class="hljs-keyword">class</span><br>  <span class="hljs-keyword">class</span> HSACleanScreenView: <span class="hljs-type">UIView</span> &#123;<br>      <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> queryBlessInfo() &#123;&#125;<br>  &#125;<br>  <br>  # 主工程<br>  <span class="hljs-keyword">if</span> ([_cleanSreenView respondsToSelector:<span class="hljs-meta">@selector</span>(queryBlessInfo)]) &#123;<br>      [_cleanSreenView performSelector:<span class="hljs-meta">@selector</span>(queryBlessInfo)];<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>5、<a href="https://www.jessesquires.com/blog/2016/06/04/avoiding-objc-in-swift/">避免@objc的滥用</a></p><ul><li><p>swift中调用oc，c类型的函数需要传递block作为参数时。 作为参数时，的修饰生命周期： <code>@escaping &amp; @nonescaping</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// HVSLiveCleanScreenView</span><br><span class="hljs-keyword">let</span> block: <span class="hljs-keyword">@convention(block)</span> ()-&gt;() <span class="hljs-operator">=</span> &#123;<br>         <span class="hljs-keyword">self</span>.toSendWishMainPageAction(sender: sender)<br>     &#125;<br> <span class="hljs-type">NotificationCenter</span>.default.post(name: <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span>(rawValue: <span class="hljs-string">&quot;HSACallLoginNotification&quot;</span>), object: [<span class="hljs-string">&quot;callback&quot;</span> : block])<br> <br> <span class="hljs-comment">// 类型转换</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getAuthorizationData</span>() -&gt; [<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>] &#123;<br>     <span class="hljs-keyword">var</span> data: [<span class="hljs-type">String</span>: <span class="hljs-type">AnyObject</span>] <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>: <span class="hljs-type">AnyObject</span>]()<br>     data[<span class="hljs-string">&quot;callback&quot;</span>] <span class="hljs-operator">=</span> &#123;<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Its NOT crashing&quot;</span>)<br>     &#125; <span class="hljs-keyword">as</span> (<span class="hljs-keyword">@convention(block)</span> ()-&gt;<span class="hljs-type">Void</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">AnyObject</span><br>     <span class="hljs-keyword">return</span> data<br> &#125;<br> <br> <span class="hljs-comment">// swift调用带c函数作为参数的</span><br> <span class="hljs-type">CGFloat</span> myCFunction(<span class="hljs-type">CGFloat</span> (callback)(<span class="hljs-type">CGFloat</span> x, <span class="hljs-type">CGFloat</span> y)) &#123;<br>     <span class="hljs-keyword">return</span> callback(<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>);<br> &#125;<br> <span class="hljs-keyword">let</span> swiftCallback : <span class="hljs-keyword">@convention(c)</span> (<span class="hljs-type">CGFloat</span>, <span class="hljs-type">CGFloat</span>) -&gt; <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> &#123; (x, y) -&gt; <span class="hljs-type">CGFloat</span> <span class="hljs-keyword">in</span><br>     <span class="hljs-keyword">return</span> x <span class="hljs-operator">+</span> y<br> &#125; <br> myCFunction( swiftCallback )<br></code></pre></td></tr></table></figure></li></ul><p>6、oc头文件中包含swift类时使用前行声明</p><ul><li><pre><code class="hljs">// MyObjcClass.h @class MySwiftClass; @protocol MySwiftProtocol; @interface MyObjcClass : NSObject - (MySwiftClass *)returnSwiftClassInstance; - (id &lt;MySwiftProtocol&gt;)returnInstanceAdoptingSwiftProtocol; // ... @end<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><br><span class="hljs-number">7</span>、 oc调用swift闭包<br><br>- ```<br>   @objc public var <span class="hljs-name">tapBlock</span>: <span class="hljs-function">(<span class="hljs-params">()</span> -&gt;</span> ())?<br>   <br>   typealias BlockType = <span class="hljs-function"><span class="hljs-params">(String, String)</span> -&gt;</span> ()<br>   @objc public var <span class="hljs-name">tapBlock</span>: BlockType?<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>8、NS_STRING_ENUM</p><p>尽量利用swift的优秀特性，比如一些有意义的key，直接用string，容易出错还无法进行类型检查</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-comment">#objectiv-c</span><br><br><span class="hljs-comment">## .h文件</span><br>typedef NSString * THJStringDicKey NS_STRING_ENUM;<br>FOUNDATION_EXTERN THJStringDicKey <span class="hljs-keyword">const</span> THJStringDicKeyTitle;<br>FOUNDATION_EXTERN THJStringDicKey <span class="hljs-keyword">const</span> THJStringDicKeyBody;<br>FOUNDATION_EXTERN THJStringDicKey <span class="hljs-keyword">const</span> THJStringDicKeyHeader;<br><span class="hljs-comment">## .m文件</span><br>THJStringDicKey <span class="hljs-keyword">const</span> THJStringDicKeyTitle  = @<span class="hljs-string">&quot;title&quot;</span>;<br>THJStringDicKey <span class="hljs-keyword">const</span> THJStringDicKeyBody   = @<span class="hljs-string">&quot;body&quot;</span>;<br>THJStringDicKey <span class="hljs-keyword">const</span> THJStringDicKeyHeader = @<span class="hljs-string">&quot;header&quot;</span>;<br><br><span class="hljs-comment">#swift</span><br><span class="hljs-keyword">let</span> dic:  [THJStringDicKey:<span class="hljs-built_in">String</span>] = [.title:<span class="hljs-string">&quot;title&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li><a href="https://www.codenong.com/jsa3e58ba1e6e8/">关于<code>@convention</code> swiftGG</a></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li><p>oc中使用swift枚举</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">WishShareType</span>: <span class="hljs-title class_">Int</span> &#123;<br>    <span class="hljs-keyword">case</span> video<br>    <span class="hljs-keyword">case</span> live<br>    <br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">name</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> &#123;<br>        <span class="hljs-keyword">case</span> .video:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;video&quot;</span><br>        <span class="hljs-keyword">case</span> .live:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;live&quot;</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;video&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// swift中WishShareTypeLive这样来使用</span><br></code></pre></td></tr></table></figure></li><li><p>swift中使用oc枚举</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_ENUM</span>(<span class="hljs-type">NSInteger</span>, <span class="hljs-type">HSAShortVideoLeftMenuTapActionType</span>) &#123;<br>    <span class="hljs-type">HSAShortVideoLeftMenuActionHotMenu</span>,   // 热门菜品<br>    <span class="hljs-type">HSAShortVideoLeftMenuActionCoupon</span>,    // 优惠券<br>&#125;;<br>  <br><span class="hljs-title">let</span> <span class="hljs-keyword">type</span>: <span class="hljs-type">HSAShortVideoLeftMenuTapActionType</span> = .actionCoupon<br><span class="hljs-title">let</span> <span class="hljs-keyword">type</span> = <span class="hljs-type">HSAShortVideoLeftMenuTapActionType</span>.actionCoupon<br></code></pre></td></tr></table></figure><p>注意：swfit使用<code>Enum.init(rawValue:)</code>生成oc类型的枚举，如果传入的值不在定义范围不会返回悔nil，执行时可能会出现无法预测的异常</p></li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a><a href="https://www.jessesquires.com/blog/2017/06/05/protocol-composition-in-swift-and-objc/">协议</a></h3><ul><li><p>oc使用swift协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AlertViewProtocol</span> &#123;<br>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">submit</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">row</span>: <span class="hljs-type">Int</span>) <span class="hljs-comment">//必须实现的协议</span><br>  <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">optional</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">cancel</span>() <span class="hljs-comment">//不必实现的协议</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>swift使用oc的协议</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs leaf">@objc public var delegate: HVSLiveChatRoomViewDelegate?<br>if delegate?.responds(to: <span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">selector</span><span class="hljs-params">(<span class="hljs-variable">HVSLiveChatRoomViewDelegate</span>.<span class="hljs-variable">showWishMainPage</span>(<span class="hljs-variable">_</span>:)</span></span>)) ?? false &#123;<br>          delegate!.showWishMainPage!(sendWishVc)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h3><ul><li><p>swift2.2版本之前可以通过<code>Selector(&quot;functionToExecute:&quot;)</code>的方式来生成，但该方式无法在编译器发现方法是否被实现，会导致<a href="https://learnappmaking.com/unrecognized-selector-sent-to-instance-swift-development/">unrecognized selector sent to instance </a>错误。swift2.2后使用<code>#selector(functionToExecute(_:))</code>或<code>Selector(Target.functionToExecute)</code>, 之前的<code>Selector(&quot;&quot;)</code>方式被废弃</p></li><li><p><code>__FUNCTION__</code> &#x3D;&gt;<code>#function</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;%@&quot;</span>, #function)</span></span> <span class="hljs-comment">// swift2.2之后替换为`#function`</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="关于responds"><a href="#关于responds" class="headerlink" title="关于responds"></a>关于<code>responds</code></h3><ul><li><pre><code class="hljs">## oc中使用## swift中判断func responds(to aSelector: Selector!) -&gt; Bool## 动态判断，不确定类型的前提下，如遵循协议的swift对象是否实现了协议内的方法if delegate?.responds(to: #selector(HVSLiveChatRoomViewDelegate.showWishMainPage(_:))) ?? false &#123;     delegate!.showWishMainPage!(sendWishVc)&#125; <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 循环引用<br><br>- block循环引用处理<br><br></code></pre></td></tr></table></figure>wishVc.animationBlock = &#123; [weak self], [weak obj] animView in     animView.show(superView: self!, belowView: self!.wishButton, replace: self?.runingWishAimationView) &#125;<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>weakproxy<br><br></code></pre></td></tr></table></figure>// NSTimer 还可以通过weakProxy来解循环引用timer = Timer.init(timeInterval: 1.0, target: FRWWeakProxy.init(target: self), selector: #selector(downTime), userInfo: nil, repeats: true)     RunLoop.main.add(timer, forMode: .common)     // wkWebView引起的循环引用因为协议的原因无法通过weakProxy来作转换 open func add(_ scriptMessageHandler: WKScriptMessageHandler, name: String)  let userContentController = WKUserContentController.init() userContentController.addUserScript(userScript) userContentController.add(self, name: _CardAppNative)  // 解决办法 1、 目前通过主动调用clean来主动解开循环 func clean() &#123;     webView.configuration.userContentController.removeScriptMessageHandler(forName: _CardAppNative) &#125;  2、 如果是控制器可以通过*`viewWillDisappear:`*来控制解开循环的时机，或则通过自定义`WKScriptMessageHandler`来解决<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 第三方库<br><br>- masonry<br><br></code></pre></td></tr></table></figure>  giftContentView.mas_makeConstraints &#123; (make) in      //  Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value      //  make?.left.mas_offset()(contentBeginX)      make?.left.offset()(contentBeginX)      make?.right.equalTo()(self.contentView)?.offset()(-contentEndX)      make?.top.mas_equalTo()(12)      make?.height.mas_equalTo()(contentHeight)  &#125;    oc中可以直接使用`mas_offset()`方式设置，但是swift中这里会导致crash，主要原因是因为swift不支持宏  导致`#define mas_offset(...)          valueOffset(MASBoxValue((__VA_ARGS__)))`失效，实际返回nil;  使用时尽量不适用带`mas_`的方法进行设置<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-bullet">- </span>Reactive-C<br><br></code></pre></td></tr></table></figure>// 同样因为宏在swfit中无法使用，`RAC(TARGET, ...)`等宏无法使用，需要直接调用对应代码model.rac_values(forKeyPath: &quot;buttonStatus&quot;, observer: self).take(untilReplacement: self.rac_signal(for: #selector(self.prepareForReuse))).subscribeNext &#123; [weak self] (obj) in    self?.changeActionButtonStyle()&#125;<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 通知<br><br>- 对于oc中通知的key的使用：宏定义和全部变量定义<br><br>- 通知使用oc中早先定义的key时``<br><br></code></pre></td></tr></table></figure>## 宏定义#define kHSANotificateToPlayInlineWishAnimationKey @&quot;notificateToPlayInlineWishAnimation&quot;NSNotification.Name(rawValue: kHSANotificateToPlayInlineWishAnimationKey)## 全局变量</code></pre></li></ul><h2 id="2、其他问题"><a href="#2、其他问题" class="headerlink" title="2、其他问题"></a>2、其他问题</h2><h3 id="2-1-Framework-targets-不支持-Bridging-Header"><a href="#2-1-Framework-targets-不支持-Bridging-Header" class="headerlink" title="2.1 Framework targets 不支持 Bridging-Header"></a>2.1 Framework targets 不支持 Bridging-Header</h3><p>  通常来讲混编的时候需要在工程中创建 Swift 文件时候，Xcode 会问询是否创建 Bridging-Header 文件，点击是，系统会帮你创建一个 Bridging-Header，你可以将需要引用的 Objective-C 模块的头文件放在里面，然后你可以在 Swift 模块用 Objective-C 的类。但是编译器是不允许在 Framework 中创建 Bridging-header，因此在二&#x2F;三方库中，我们不能使用桥接文件的方式进行混编 Objective-C 代码的引用，需要用 Swift Module 进行模块间的引用。</p><h3 id="2-2-模块引用"><a href="#2-2-模块引用" class="headerlink" title="2.2 模块引用"></a>2.2 模块引用</h3><p>  引用其他 Objective-C 二方库需要增加命名空间（Namespace），否则会报错找不到文件 Swift 的命名空间是以模块划分的，一个模块表示一个命名空间。开发时，默认添加到主 target 的内容是同处于同一个命名空间的；如果用 Cocoapods 导入的第三方库，是以一个单独的 target 存在，不会存在命名冲突。但如果以源码的方式导入工程，很可能发生命名冲突，所以为了安全起见，第三方库都会使用命名空间这种方式来防止冲突。</p><h3 id="2-3-C-混编"><a href="#2-3-C-混编" class="headerlink" title="2.3 C++ 混编"></a>2.3 C++ 混编</h3><p>  Objective-C 是 C++ 的超集，就如同 Objective-C 是 C 的超集，在OS X 上同时被 GCC 和 Clang 支持编译，.mm 是 Objective-C++ 的默认后缀名，Xcode 的编译器可以识别。在.mm 文件中，Objective-C 代码和 C++ 代码都可以正常编译运行。在消息业务模块中中引用了 WCDB 这个 Objective-C++ 的库，因此在引用的时候要将引用到的 WCDB.h 头文件中的类文件的 .h 改成 .mm。</p><h3 id="2-4-链接错误"><a href="#2-4-链接错误" class="headerlink" title="2.4 链接错误"></a>2.4 链接错误</h3><p>  我们将上述工作做完后引入到宿主工程中，进行编译的时候会出现链接错误，不要担心，那是因为宿主工程中缺少 Swift 的某些系统库，在宿主工程中建立一个 Swift 文件方可解决。</p><h3 id="2-5-Swift-调用-Objective-C"><a href="#2-5-Swift-调用-Objective-C" class="headerlink" title="2.5 Swift 调用 Objective-C"></a>2.5 Swift 调用 Objective-C</h3><p>  将 Swift 模块文件中，用import xxx 的形式进行模块的引用，包括 Objective-C 的二&#x2F;三方库</p><h3 id="2-6-Objective-C-调用-Swift"><a href="#2-6-Objective-C-调用-Swift" class="headerlink" title="2.6 Objective-C 调用 Swift"></a>2.6 Objective-C 调用 Swift</h3><ul><li>Swift 类中将需要暴露给 Objective-C 模块引用的类，用 public 申明</li><li>Swift 类中需要暴露给 Objective-C 的方法要用关键字 @objc</li><li>在 Objective-C 类中引用 ProductName-Swift.h 头文件即可引用暴露给 Objective-C 的 Swift 的类和方法</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NSBlockOperation</title>
    <link href="/2019/05/16/NSBlockOperation/"/>
    <url>/2019/05/16/NSBlockOperation/</url>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们可能会用到 NSBlockOperation 来做一些多线程的操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>queue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br><span class="hljs-type">NSBlockOperation</span> <span class="hljs-operator">*</span>operation <span class="hljs-operator">=</span> [<span class="hljs-type">MyBlockOperation</span> blockOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;];<br>[queue addOperation:operation];<br></code></pre></td></tr></table></figure><p>因为其使用简单，所以也被广泛使用。</p><p>但这个方法也有一个缺点，当 operation 开始执行后，[operation cancel]; 并不能及时取消。</p><p>同时，blockOperationWithBlock 没有 operation 的回调参数。有些同学想要通过 operation.isCancelled 进行任务的及时取消，不太清楚应该怎么做，要是使用不当甚至会引入 循环引用 问题。</p><p>下面，我们通过几个面试题来一步步了解清楚这个问题。</p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>下面的代码输出什么？</p><ul><li>cancelled</li><li>finish</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>queue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br><span class="hljs-type">NSBlockOperation</span> <span class="hljs-operator">*</span>operation <span class="hljs-operator">=</span> [<span class="hljs-type">NSBlockOperation</span> blockOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (operation.isCancelled) &#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;cancelled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;finish&quot;</span>);<br>    &#125;<br>&#125;];<br>[queue addOperation:operation];<br>dispatch_after(dispatch_time(<span class="hljs-type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="hljs-number">1.0</span> <span class="hljs-operator">*</span> <span class="hljs-type">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), <span class="hljs-operator">^</span>&#123;<br>    [operation cancel];<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>答案</strong></p><ul><li>finish</li></ul><p><strong>分析</strong></p><p>初始化时传入了一个 block，block 中含有 operation 对象的访问，即发生了对象的捕获。但是现在是对象的创建过程中，operation 还没有被初始化出来，block这时捕获的是 operation 当前的值，即 operation &#x3D; nil。</p><span id="more"></span><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>下面的代码输出什么？</p><ul><li>cancelled</li><li>finish</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>queue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br>__block <span class="hljs-type">NSBlockOperation</span> <span class="hljs-operator">*</span>operation <span class="hljs-operator">=</span> [<span class="hljs-type">NSBlockOperation</span> blockOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (operation.isCancelled) &#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;cancelled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;finish&quot;</span>);<br>    &#125;<br>&#125;];<br>[queue addOperation:operation];<br>dispatch_after(dispatch_time(<span class="hljs-type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="hljs-number">1.0</span> <span class="hljs-operator">*</span> <span class="hljs-type">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), <span class="hljs-operator">^</span>&#123;<br>    [operation cancel];<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>答案</strong></p><ul><li>cancelled</li></ul><p><strong>分析</strong></p><p>这次加入了 <code>__block</code> 修饰符，捕获变为了指针引用，所以这次 [operation cancel]; 生效了。<br>简单来说就是：</p><p>未使用 <code>__block</code> 修饰符，捕获的是当前值。</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span>(^<span class="hljs-built_in">block</span>)(<span class="hljs-type">void</span>) = ^&#123;<br>    i = <span class="hljs-number">1</span>;<br>    printf(<span class="hljs-string">&quot;%d&quot;</span>, i); <span class="hljs-comment">// 1</span><br>&#125;;<br>i = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">block</span>();<br></code></pre></td></tr></table></figure><p>上面这个问题已经有很多文章了，这里不深入说明。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta">NSString *<span class="hljs-built_in">str</span> = @<span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">void</span>(^block)(<span class="hljs-keyword">void</span>) = ^&#123;<br>    NSLog(@<span class="hljs-string">&quot;%@&quot;</span>, <span class="hljs-built_in">str</span>); <span class="hljs-comment">// 0</span><br>&#125;;<br><span class="hljs-built_in">str</span> = @<span class="hljs-string">&quot;1&quot;</span>;<br>block();<br></code></pre></td></tr></table></figure><p>部分同学可能对这个有疑问。其实，两种捕获的原理都是对变量的 “值引用” 进行捕获，捕获的是当前对象的值。之后的修改，不会影响到 block 内部的值。</p><h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>下面的代码输出什么？</p><ul><li>cancelled, -[MyBlockOperation dealloc]</li><li>只有 cancelled</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyBlockOperation</span> : <span class="hljs-title">NSBlockOperation</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyBlockOperation</span></span><br>- (<span class="hljs-type">void</span>)dealloc &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __FUNCTION__);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>__block MyBlockOperation *operation = [MyBlockOperation blockOperationWithBlock:^&#123;<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (operation.isCancelled) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;cancelled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;finish&quot;</span>);<br>    &#125;<br>&#125;];<br>[queue addOperation:operation];<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">1.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>    [operation cancel];<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>答案</strong></p><ul><li>只有 cancelled</li></ul><p><strong>分析</strong></p><p>刚刚分析了 <code>__block</code> 修饰符，捕获变为了指针引用。现在 operation 对象持有 block ，同时 block 通过指针引用捕获了 operation 对象，所以发生了循环引用。</p><p>那可能有些同学就要说了，加上 <code>__weak</code> 不就好了？</p><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p>下面的代码输出什么？</p><ul><li>cancelled, -[MyBlockOperation dealloc]</li><li>只有 cancelled</li><li>只有 -[MyBlockOperation dealloc]</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyBlockOperation</span> : <span class="hljs-title">NSBlockOperation</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyBlockOperation</span></span><br>- (<span class="hljs-type">void</span>)dealloc &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __FUNCTION__);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>__block __<span class="hljs-keyword">weak</span> MyBlockOperation *operation = [MyBlockOperation blockOperationWithBlock:^&#123;<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (operation.isCancelled) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;cancelled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;finish&quot;</span>);<br>    &#125;<br>&#125;];<br>[queue addOperation:operation];<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">1.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>    [operation cancel];<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>答案</strong></p><ul><li>只有 -[MyBlockOperation dealloc]</li></ul><p>这里加入了 __weak 修饰符，对象创建后，发现引用计数为 0 就被释放了，所以 block 不执行。这部分属于内存管理的知识点。</p><p>那么我们要怎么做，才能既捕获到 operation 又不会导致循环引用呢？</p><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><p>下面的代码输出什么？</p><ul><li>cancelled, -[MyBlockOperation dealloc]</li><li>只有 cancelled</li><li>只有 -[MyBlockOperation dealloc]</li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sas">NSOperationQueue <span class="hljs-comment">*queue = [[NSOperationQueue alloc] init];</span><br>__block __weak MyBlockOperation <span class="hljs-comment">*wkOp;</span><br>MyBlockOperation <span class="hljs-comment">*operation = [MyBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="hljs-comment">    sleep(2);</span><br>    <span class="hljs-keyword">if</span> (wkOp.isCancelled) &#123;<br>        NS<span class="hljs-meta">Log</span>(@<span class="hljs-string">&quot;cancelled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        NS<span class="hljs-meta">Log</span>(@<span class="hljs-string">&quot;finish&quot;</span>);<br>    &#125;<br>&#125;];<br>wkOp = operation;<br>[queue addOperation:operation];<br>dispatch_after(dispatch_<span class="hljs-meta">time</span>(DISPATCH_TIME_NOW, (int64_t)(1.0 <span class="hljs-comment">* NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="hljs-comment">    [operation cancel];</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>答案</strong></p><ul><li>cancelled, -[MyBlockOperation dealloc]</li></ul><p><strong>分析</strong></p><p>为了让 block 访问到初始化之后的值，wkOp 用了 <code>__block</code> 修饰符；同时，为了避免循环引用问题，wkOp 还用了 <code>__weak</code> 修饰符。</p><p>operation 初始化后被赋值，这里会有一个隐式的 <code>__strong</code> 修饰，即这里会对 operation 进行强引用，引用计数 +1 。wkOp 为弱引用对象，wkOp &#x3D; operation; 只是用一个弱引用指针指向 operation ，引用计数不变。与之前不同的是，此时的 operation 的引用计数大于 0，所以不会被立刻释放。</p><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><p>为了日常使用方便封装一下就更香了～</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyBlockOperation</span> : <span class="hljs-title">NSBlockOperation</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)blockOperationWithBlock:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">void</span>))block <span class="hljs-built_in">NS_UNAVAILABLE</span>;<br>+ (<span class="hljs-keyword">instancetype</span>)blockOperationWithOperationBlock:(<span class="hljs-type">void</span> (^)(MyBlockOperation *))block;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyBlockOperation</span></span><br>- (<span class="hljs-type">void</span>)dealloc &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __FUNCTION__);<br>&#125;<br><br>+ (<span class="hljs-keyword">instancetype</span>)blockOperationWithOperationBlock:(<span class="hljs-type">void</span> (^)(MyBlockOperation *))block;<br>&#123;<br>    __block __<span class="hljs-keyword">weak</span> MyBlockOperation *wkOp;<br>    MyBlockOperation *op = [<span class="hljs-variable language_">super</span> blockOperationWithBlock:^&#123;<br>        !block ?: block(wkOp);<br>    &#125;];<br>    wkOp = op;<br>    <span class="hljs-keyword">return</span> op;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>MyBlockOperation *operation = [MyBlockOperation blockOperationWithOperationBlock:^(MyBlockOperation *op)&#123;<br>    sleep(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (op.isCancelled) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;cancelled&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;finish&quot;</span>);<br>    &#125;<br>&#125;];<br>[queue addOperation:operation];<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">1.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>    [operation cancel];<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>组件化方案比较</title>
    <link href="/2019/04/17/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83/"/>
    <url>/2019/04/17/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h4 id="组件化第一步－剥离公共库和产品基础库"><a href="#组件化第一步－剥离公共库和产品基础库" class="headerlink" title="组件化第一步－剥离公共库和产品基础库"></a>组件化第一步－剥离公共库和产品基础库</h4><h4 id="组件化第二步－独立业务模块单独成库"><a href="#组件化第二步－独立业务模块单独成库" class="headerlink" title="组件化第二步－独立业务模块单独成库"></a>组件化第二步－独立业务模块单独成库</h4><ul><li>模块间解耦</li><li>模块重用</li><li>提高团队协作开发效率</li><li>单元测试</li></ul><p> iOS 上绝大部分的路由工具都是基于 URL 匹配的，或者是根据命名约定，用 runtime 方法进行动态调用</p><p>缺点是需要维护字符串表，或者依赖于命名约定，无法在编译时暴露出所有问题，需要在运行时才能发现错误</p><h2 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h2><p>A-&gt;中间-&gt;B</p><p>通过分类给组件来封装一层target对象来给外界提供服务，然后调用者通过依赖中间件来使用服务；中间件是通过runtime来调用组件的服务，达到的解耦。然后，通过实现中间件的category添加新接口来提供服务给调用者，这样使用者只需要依赖中间件，而组件则不需要依赖中间件。</p><p>利用 category 为路由工具添加新接口，在接口中通过字符串硬编码获取对应的类，再用 runtime 创建实例，动态调用实例的方法</p><span id="more"></span><p>下图是 <a href="https://github.com/casatwy/CTMediator">CTMediator</a>的组件化方案架构图：</p><p>![image-20220917165703491](&#x2F;Users&#x2F;xushuanghui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220917165703491.png)</p><p>这就要求target类名要加前缀Target_ ：目标模块对外服务的分类名，方法名要加前缀Action_：目标模块调用具体的VC ，params:设置回调。同时必须要有并且只有一个参数，参数类型必须是字典NSDictionary，还必须要要有返回参数，返回参数必须是指针类型，不能为int、float等C语言类型。</p><p>优点：</p><ul><li>利用 category 可以明确声明接口，进行编译检查</li><li>内存中不需要维护映射表。不需要注册。</li><li>实现方式轻量</li></ul><p>缺点：</p><ul><li>需要在 mediator 和 target 中重新添加每一个接口，模块化时代码较为繁琐</li><li>在 category 中仍然引入了字符串硬编码，内部使用字典传参，一定程度上也存在和 URL 路由相同的问题</li><li>无法保证所使用的模块一定存在，target 模块在修改后，使用者只有在运行时才能发现错误</li><li>过于依赖 runtime 特性，无法应用到纯 Swift 上。在 Swift 中扩展 mediator 时，无法使用纯 Swift 类型的参数</li><li>可能会创建过多的 target 类</li><li>使用 runtime 相关的接口调用任意类的任意方法，需要注意别被苹果的审核误伤。参考：<a href="https://stackoverflow.com/questions/42662028/are-performselector-and-respondstoselector-banned-by-app-store">Are performSelector and respondsToSelector banned by App Store?</a></li></ul><h4 id="字典传参的问题"><a href="#字典传参的问题" class="headerlink" title="字典传参的问题"></a>字典传参的问题</h4><p>字典传参时无法保证参数的数量和类型，只能依赖调用约定，就和字符串传参一样，一旦某一方做出修改，另一方也必须修改。</p><p>相比于 URL 路由，target-action 通过 category 的接口把字符串管理的问题缩小到了 mediator 内部，不过并没有完全消除，而且在其他方面仍然有很多改进空间。上面的8个指标中其实只能满足第2个”支持模块单独编译”，另外在和接口相关的第3、5、6点上，比 URL 路由要有改善。</p><h2 id="URL-router"><a href="#URL-router" class="headerlink" title="URL router"></a>URL router</h2><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">// 注册某个URL</span><br>[<span class="hljs-title class_">URLRouter</span> <span class="hljs-variable">registerURL</span>:@<span class="hljs-string">&quot;app://editor&quot;</span> <span class="hljs-variable">handler</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSDictionary</span> *<span class="hljs-params">userInfo</span>) &#123;<br>    <span class="hljs-title class_">UIViewController</span> <span class="hljs-operator">*</span><span class="hljs-variable">editorViewController</span> <span class="hljs-operator">=</span> [[<span class="hljs-title class_">EditorViewController</span> <span class="hljs-variable">alloc</span>] initWithParam:<span class="hljs-variable">userInfo</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">editorViewController</span>;<br>&#125;];<br><span class="hljs-comment">// 调用路由</span><br>[<span class="hljs-title class_">URLRouter</span> <span class="hljs-variable">openURL</span>:@<span class="hljs-string">&quot;app://editor/?debug=true&quot;</span> <span class="hljs-variable">completion</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSDictionary</span> *<span class="hljs-params">info</span>) &#123;<br><br>&#125;];<br></code></pre></td></tr></table></figure><p>App 启动时实例化各组件模块或者使用class注册，然后组件向<code>ModuleManager</code>注册<code>Url</code></p><p>当组件A需要调用组件B时，向<code>ModuleManager</code>传递URL，参数可以拼接在URL后面或者放在字典里传递，类似 <code>openURL</code>。然后由<code>ModuleManager</code>负责调度组件B，最后完成目标</p><p>URL router 的优点：</p><ul><li>极高的动态性，适合经常开展运营活动的 app，例如电商</li><li>方便地统一管理多平台的路由规则</li><li>易于适配 URL Scheme</li></ul><p>URL router 的缺点：</p><ul><li><p>传参方式有限，并且无法利用编译器进行参数类型检查，因此所有的参数都是通过字符串转换而来</p><p>只适用于界面模块，不适用于通用模块</p><p>参数的格式不明确，是个灵活的 dictionary，也需要有个地方可以查参数格式。</p><p>依赖于字符串硬编码，难以管理，蘑菇街做了个后台专门管理。</p><p>无法保证所使用的的模块一定存在</p><p>解耦能力有限，url 的”注册”、”实现”、”使用”必须用相同的字符规则，一旦任何一方做出修改都会导致其他方的代码失效，并且重构难度大</p></li></ul><h3 id="改进-protocol-class"><a href="#改进-protocol-class" class="headerlink" title="改进:protocol-class"></a>改进:protocol-class</h3><p>实现思路是将 protocol 和对应的类进行字典匹配，之后就可以用 protocol 获取 class，再动态创建实例。</p><p>组件化的方案，就是通过protocol定义服务接口，组件通过实现该接口来提供接口定义的服务，具体实现就是把protocol和class做一个映射，同时在内存中保存一张映射表，使用的时候，就通过protocol找到对应的class来获取需要的服务。</p><p>下图是protocol-class的架构图：</p><img src="/Users/xushuanghui/Library/Application Support/typora-user-images/image-20220917163221354.png" alt="image-20220917163221354" style="zoom:50%;" /><p>注册：[ModuleManager registerClass:ClassA forProtocol:ProtocolA]</p><p>调用：[ModuleManager classForProtocol:ProtocolA]</p><p>优点：</p><ul><li>利用接口调用，实现了参数传递时的类型安全</li><li>直接使用模块的 protocol 接口，无需再重复封装</li></ul><p>缺点：</p><ul><li>由框架来创建所有对象，创建方式有限，例如不支持外部传入参数，再调用自定义初始化方法</li><li>用 OC runtime 创建对象，不支持 Swift</li><li>只做了 protocol 和 class 的匹配，不支持更复杂的创建方式和依赖注入</li><li>无法保证所使用的 protocol 一定存在对应的模块，也无法直接判断某个 protocol 是否能用于获取模块</li></ul><p>相比直接 protocol-class 匹配的方式，protocol-block 的方式更加易用。例如 Swinject。</p><h2 id="Protocol-Router"><a href="#Protocol-Router" class="headerlink" title="Protocol Router"></a>Protocol Router</h2><p>ZIKRouter 进行了进一步的改进,<strong>并不是直接对 protocol 和 class 进行匹配，而是将 protocol 和 router 子类或者 router 对象进行匹配，在 router 子类中再提供创建模块的实例的方式。</strong>这时，模块的创建职责就从 BeeHive 单例上转到了每个单独的 router 上，从集约型变成了离散型。</p><p>大部分组件化方案都会带来一个问题，就是减弱甚至抛弃编译检查，因为模块已经变得高度动态化了。<br>当调用一个模块时，怎么能保证这个模块一定存在？直接引用类时，如果类不存在，编译器会给出引用错误，但是动态组件就无法在静态时检查了。</p><ul><li>可以在 router 上添加许多通用的扩展接口，例如创建模块、依赖注入、界面跳转、界面移除，甚至增加 URL 路由支持</li><li>在每个 router 子类中可以进行更详细的依赖注入和自定义操作</li><li>可以自定义创建对象的方式，例如自定义初始化方法、工厂方法，在重构时可以直接搬运现有的创建代码，无需在原来的类上增加或修改接口，减少模块化过程中的工作量</li><li>可以让多个 protocol 和同一个模块进行匹配</li><li>可以让模块进行接口适配，允许外部做完适配后，为 router 添加新的 protocol，解决编译依赖的问题</li><li>返回的对象只需符合 protocol，不再和某个单一的类绑定。因此可以根据条件，返回不同的对象，例如适配不同系统版本时，返回不同的控件，让外部只关注接口</li></ul><p><strong>优势</strong></p><p>1、优势：保证所使用的 protocol 一定存在，在编译阶段就能防止使用不存在的模块。这个功能可以让你更安全、更简单地管理所使用的路由接口，不必再用其他复杂的方式进行检查和维护。</p><p>2、当使用了错误的 protocol 时，会产生编译错误</p><ul><li><strong>只有被声明为可路由的 protocol 才能用于路由，否则会产生编译错误</strong></li><li><strong>可路由的 protocol 必定有一个对应的模块存在</strong></li></ul><h3 id="一、路由声明"><a href="#一、路由声明" class="headerlink" title="一、路由声明"></a>一、路由声明</h3><p>怎么才能声明一个 protocol 是可以用于路由的呢？</p><p>要实现第一个机制，关键就是要为 protocol 添加特殊的属性或者类型，使用时，如果 protocol 不符合特定类型，就产生编译错误</p><h4 id="1-1、Objective-C：protocol-继承链"><a href="#1-1、Objective-C：protocol-继承链" class="headerlink" title="1.1、Objective-C：protocol 继承链"></a>1.1、Objective-C：protocol 继承链</h4><p>在 Objective-C 中，可以要求 protocol 必须继承自某个特定的父 protocol，并且通过宏定义 + protocol 限定，对 protocol 的父 protocol 继承链进行静态检查。</p><p>例如 ZIKRouter 中获取 router 类的方法是这样的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@protocol</span> ZIKViewRoutable<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@interface</span> <span class="hljs-built_in">ZIKViewRouter</span>()<br><span class="hljs-variable">@property</span> (nonatomic, class, readonly) ZIKViewRouterType *(^toView)(Protocol&lt;ZIKViewRoutable&gt; *viewProtocol);<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p><code>toView</code>用类属性的方式提供，以方便链式调用，这个 block 接收一个<code>Protocol&lt;ZIKViewRoutable&gt; *</code>类型的 protocol，返回对应的 router 类。</p><p><code>Protocol&lt;ZIKViewRoutable&gt; *</code>表示这个 protocol 必须继承自<code>ZIKViewRoutable</code>。普通 protocol 的类型是<code>Protocol *</code>，所以如果传入<code>@protocol(EditorViewProtocol)</code>就会产生编译警告。</p><p>而如果用宏定义再给 protocol 变量加上一个 protocol 限定，进行一次类型转换，就可以利用编译器检查 protocol 的继承链：</p><h4 id="1-2、Swift：条件扩展"><a href="#1-2、Swift：条件扩展" class="headerlink" title="1.2、Swift：条件扩展"></a>1.2、Swift：条件扩展</h4><p>Swift 中不支持宏定义，也不能随意进行类型转换，因此需要换一种方式来进行编译检查。</p><p>可以用 struct 的泛型传递 protocol，然后用条件扩展为特定泛型的 struct 添加初始化方法，从而让没有声明过的泛型类型不能直接创建 struct。</p><p>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 用 RoutableView 的泛型来传递 protocol</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RoutableView</span>&lt;<span class="hljs-title class_">Protocol</span>&gt; &#123;<br>    <span class="hljs-comment">// 禁止默认的初始化方法</span><br>    <span class="hljs-keyword">@available</span>(<span class="hljs-operator">*</span>, unavailable, message: <span class="hljs-string">&quot;Protocol is not declared as routable&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() &#123; &#125;<br>&#125;<br><span class="hljs-comment">// 泛型为 EditorViewProtocol 的扩展</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">RoutableView</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Protocol</span> == <span class="hljs-title class_">EditorViewProtocol</span> &#123;<br>    <span class="hljs-comment">// 允许初始化</span><br>    <span class="hljs-keyword">init</span>() &#123; &#125;<br>&#125;<br><span class="hljs-comment">// 泛型为 EditorViewProtocol 时可以初始化</span><br><span class="hljs-type">RoutableView</span>&lt;<span class="hljs-type">EditorViewProtocol</span>&gt;()<br><br><span class="hljs-comment">// 没有声明过的泛型无法初始化，会产生编译错误</span><br><span class="hljs-type">RoutableView</span>&lt;<span class="hljs-type">UndeclaredProtocol</span>&gt;()<br></code></pre></td></tr></table></figure><h3 id="二、-路由检查"><a href="#二、-路由检查" class="headerlink" title="二、 路由检查"></a>二、 路由检查</h3><p>通过路由声明，我们做到了在编译时对所使用的 protocol 做出限制。下一步就是保证声明过的 protocol 必定有对应的模块，类似于程序在 link 阶段，会检查头文件中声明过的类必定有对应的实现。</p><p>这一步是无法直接在编译阶段实现的，不过可以参考 iOS 在启动时检查动态库的方式，我们可以在启动阶段实现这个功能。</p><h4 id="2-1-Objective-C-protocol-遍历"><a href="#2-1-Objective-C-protocol-遍历" class="headerlink" title="2.1 Objective-C: protocol 遍历"></a>2.1 Objective-C: protocol 遍历</h4><p>在 app 以 DEBUG 模式启动时，我们可以遍历所有继承自 ZIKViewRoutable 的 protocol，在注册表中检查是否有对应的 router，如果没有，就给出断言错误。</p><p>另外，还可以让 router 同时注册创建模块时用到类：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EditorViewRouter</span>.</span></span>register<span class="hljs-constructor">View(EditorViewController.<span class="hljs-params">self</span>)</span><br></code></pre></td></tr></table></figure><h4 id="2-2-Swift-符号遍历"><a href="#2-2-Swift-符号遍历" class="headerlink" title="2.2 Swift: 符号遍历"></a>2.2 Swift: 符号遍历</h4><h3 id="自动推断返回值类型"><a href="#自动推断返回值类型" class="headerlink" title="自动推断返回值类型"></a>自动推断返回值类型</h3><p>还有最后一个问题，在 BeeHive 中使用<code>[[BeeHive shareInstance] createService:@protocol(EditorViewProtocol)]</code>获取模块时，返回值是一个<code>id</code>类型，使用者需要手动指定返回变量的类型，在 Swift 中更是需要手动类型转换，而这一步是可能出错的，并且编译器无法检查。要实现最完备的类型检查，就不能忽视这个问题。</p><p>有没有一种方式能让返回值的类型和 protocol 的类型对应呢？</p><p><strong>OC 中的泛型在这时候就发挥作用了。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>block</title>
    <link href="/2019/04/17/block/"/>
    <url>/2019/04/17/block/</url>
    
    <content type="html"><![CDATA[<p><strong>block本质是什么</strong></p><p>Block 本质上是一个 Objective-C 的对象，它内部也有一个 <code>isa</code> 指针，它是一个封装了函数及函数调用环境的 Objective-C 对象</p><ol><li><strong>NSGlobalBlock</strong>、<strong>NSStackBlock</strong>、<strong>NSMallocBlock</strong></li></ol><p>当一个 <code>__NSStackBlock__</code> 类型 Block 做 <code>copy</code> 操作后就会将这个 Block 从栈上复制到堆上，而堆上的这个 Block 类型就是 <code>__NSMallocBlock__</code> 类型。在 ARC 环境下，编译器会根据情况，自动将 Block 从栈上 <code>copy</code> 到堆上。具体会进行 <code>copy</code> 的情况有如下 4 种：</p><ul><li><p>block 作为函数的返回值时；</p></li><li><p>block 赋值给 __strong 指针，或者赋值给 block 类型的成员变量时；</p></li><li><p>block 作为 Cocoa API 中方法名含有 usingBlock 的方法参数时；</p></li><li><p>block 作为 GCD API 的方法参数时</p></li><li><p><strong>__block 的作用</strong></p></li></ul><p>简单来说，<code>__block</code> 作用是允许 <code>block</code> 内部访问和修改外部变量，在 ARC 环境下还可以用来防止循环引用；</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini">__block int <span class="hljs-attr">age</span> = <span class="hljs-number">10</span><span class="hljs-comment">;</span><br>void (^exampleBlock)(void) = ^&#123;<br>    // block<br>    NSLog(@&quot;1.age is: %d&quot;, age)<span class="hljs-comment">;</span><br>    <span class="hljs-attr">age</span> = <span class="hljs-number">16</span><span class="hljs-comment">;</span><br>    NSLog(@&quot;2.age is: %d&quot;, age)<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br>exampleBlock()<span class="hljs-comment">;</span><br>NSLog(@&quot;3.age is: %d&quot;, age)<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure><p><code>__block</code> 主要用来解决 <code>block</code> 内部无法修改 <code>auto</code> 变量值的问题，为什么加上 <code>__block</code> 修饰之后，<code>auto</code> 变量值就能修改了呢？</p><p>这是因为，加上 <code>__block</code> 修饰之后，编译器会将 <code>__block</code> 变量包装成一个结构体 <code>__Block_byref_age_0</code> ，结构体内部 <code>*__forwarding</code> 是指向自身的指针，并且结构体内部还存储着外部 <code>auto</code> 变量。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__Block_byref_val_0</span> &#123;<br>    <span class="hljs-type">void</span> *__isa; <span class="hljs-comment">// isa指针</span><br>    __Block_byref_val_0 *__forwarding; <br>    <span class="hljs-type">int</span> __flags;<br>    <span class="hljs-type">int</span> __size; <span class="hljs-comment">// Block结构体大小</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">// 捕获到的变量</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce62d5b6e4f2412d884dda868637316b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="block_struct.jpg" style="zoom:50%;" /><p>从上图可以看到，如果 <code>block</code> 是在栈上，那么这个 <code>__forwarding</code> 指针就是指向它自己，当这个 <code>block</code> 从栈上复制到堆上后，栈上的 <code>__forwarding</code> 指针指向的是复制到堆上的 <code>__block</code> 结构体。堆上的 <code>__block</code> 结构体中的 <code>__forwarding</code> 指向的还是它自己，即 <code>age-&gt;__forwarding</code> 获取到堆上的 <code>__block</code> 结构体，<code>age-&gt;__forwarding-&gt;age</code> 会把堆上的 <code>age</code> 赋值为 16 。因此不管是栈上还是堆上的 <code>__block</code> 结构体，最终使用到的都是堆上的 <code>__block</code> 结构体里面的数据。</p><ul><li><strong>__weak 的作用</strong></li></ul><p>简单来说是为了防止循环引用。使 <code>block</code> 对象对 <code>self</code> 弱引用</p><ul><li><p><strong>__strong 的作用</strong> 简单来说，是防止 Block 内部引用的外部 <code>weak</code> 变量被提前释放，进而在 Block 内部无法获取 <code>weak</code> 变量以继续使用的情况；</p></li><li><p>思考题</p></li></ul><p><code>Block</code> 内修改外部 <code>NSMutableString</code> 、<code>NSMutableArray</code> 、<code>NSMutableDictionary</code> 对象，是否需要添加 <code>__block</code> 修饰？</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">NSMutableArray *mutableArray = <span class="hljs-selector-attr">[[NSMutableArray alloc]</span> init];<br><span class="hljs-selector-attr">[mutableArray addObject:@<span class="hljs-string">&quot;1&quot;</span>]</span>;<br>void (^exampleBlock)(void) = ^&#123;<br>    <span class="hljs-comment">// block</span><br>    <span class="hljs-selector-attr">[mutableArray addObject:@<span class="hljs-string">&quot;2&quot;</span>]</span>;<br>&#125;;<br><span class="hljs-built_in">exampleBlock</span>();<br><span class="hljs-built_in">NSLog</span>(@&quot;mutableArray: %@&quot;, mutableArray);<br>复制代码<br></code></pre></td></tr></table></figure><p>打印日志：</p><blockquote><p>mutableArray: ( 1, 2 )</p></blockquote><p>答案是：不需要。因为在 <code>block</code> 内部，我们只是使用了对象 <code>mutableArray</code> 的内存地址，往其中添加内容。并没有修改其内存地址，因此不需要使用 <code>__block</code> 也可以正确执行。当我们只是使用局部变量的内存地址，而不是对其内存地址进行修改时，我们无需对其添加 <code>__block</code> ，如果添加了 <code>__block</code> 系统会自动创建相应的结构体，这种情况冗余且低效。</p><ul><li>Block 数据结构</li></ul><p>Block 内部数据结构图如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ab0ef1f0a6d49e9b1f6228dfcbf2447~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="block_layout.jpg"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> Block_descriptor &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> reserved;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">void</span> (*<span class="hljs-keyword">copy</span>)(<span class="hljs-type">void</span> *dst, <span class="hljs-type">void</span> *src);<br>    <span class="hljs-type">void</span> (*dispose)(<span class="hljs-type">void</span> *);<br>&#125;;<br><br><span class="hljs-keyword">struct</span> Block_layout &#123;<br>    <span class="hljs-type">void</span> *isa;<br>    <span class="hljs-type">int</span> flags;<br>    <span class="hljs-type">int</span> reserved; <br>    <span class="hljs-type">void</span> (*invoke)(<span class="hljs-type">void</span> *, ...);<br>    <span class="hljs-keyword">struct</span> Block_descriptor *descriptor;<br>    <span class="hljs-comment">/* Imported variables. */</span><br>&#125;;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>Block_layout</code> 结构体成员含义如下：</p><blockquote><p><code>isa:</code> 指向所属类的指针，也就是 block 的类型</p><p><code>flags:</code> 按 bit 位表示一些 block 的附加信息，比如判断 block 类型、判断 block 引用计数、判断 block 是否需要执行辅助函数等；</p><p><code>reserved:</code> 保留变量；</p><p><code>invoke:</code> block 函数指针，指向具体的 block 实现的函数调用地址，block 内部的执行代码都在这个函数中；</p><p><code>descriptor:</code> 结构体 Block_descriptor，block 的附加描述信息，包含 copy&#x2F;dispose 函数，block 的大小，保留变量；</p><p><code>variables:</code> 因为 block 有闭包性，所以可以访问 block 外部的局部变量。这些 variables 就是复制到结构体中的外部局部变量或变量的地址；</p></blockquote><p><code>Block_descriptor</code> 结构体成员含义如下：</p><blockquote><p><code>reserved:</code> 保留变量；</p><p><code>size:</code> block 的大小；</p><p><code>copy:</code> 函数用于捕获变量并持有引用；</p><p><code>dispose:</code> 析构函数，用来释放捕获的资源；</p></blockquote><p>调用copy,把NSStackBlock变成NSMallocBlock</p><p>原因：栈中的代码在作用域结束之后内存就会被销毁，可能block内存销毁之后才去调用它</p><p><strong>什么情况下ARC会自动将block进行一次copy操作？</strong></p><p>1、block作为函数返回值时 2、 将block赋值给__strong指针时 3、block作为方法参数时</p><p><strong>Block</strong></p><p>1、解决block循环引用的思路就是中介者模式。<br>2、Block的本质就是对象<br>3、当Block捕获到外界变量时，他就会从全局block变成堆block</p><ul><li><p>_NSConcreteGlobalBlock 跟全局变量一样,设置在程序的数据区域data中</p></li><li><p>_NSConcreteStackBlock栈上(前面讲的都是栈上的 block)</p></li><li><p>_NSConcreteMallocBlock 堆上</p></li><li><p>通过<code>__block</code>修饰<code>int</code> <code>a</code>,block体中对这个变量的引用是指针拷贝,它会作为block结构体构造参数传入到结构体中且复制这个变量的指针引用，从而达到可以修改变量的作用.</p></li><li><p>| <code>__TestClass__testMethods_block_copy_0</code>    | 从栈复制到堆时      |<br>| <code>__TestClass__testMethods_block_dispose_0</code> | 堆上的Block被废弃时 |</p></li><li><h5 id="什么时候栈上的Block会被复制到堆呢？"><a href="#什么时候栈上的Block会被复制到堆呢？" class="headerlink" title="什么时候栈上的Block会被复制到堆呢？"></a>什么时候栈上的Block会被复制到堆呢？</h5><ul><li>调用block的copy函数时。</li><li>Block作为函数返回值返回时。</li><li>将Block赋值给附有Block类型成员变量时。<br>将栈block复制到堆以后，block结构体的isa成员变量变成了_NSConcreteMallocBlock。</li></ul></li></ul><h5 id="什么时候Block被废弃呢？"><a href="#什么时候Block被废弃呢？" class="headerlink" title="什么时候Block被废弃呢？"></a>什么时候Block被废弃呢？</h5><ul><li>堆上的Block被释放后,谁都不再持有Block时调用dispose函数。</li></ul><p>ARC下bl<br>因为block0持有__block变量，所以也会把这个__block变量复制到堆上</p><h3 id="strong、-weak修饰解决循环引用"><a href="#strong、-weak修饰解决循环引用" class="headerlink" title="__strong、__weak修饰解决循环引用"></a><code>__strong</code>、<code>__weak</code>修饰解决循环引用</h3><p>首先因为block捕获变量的时候 结构体构造时传入了self,造成了默认的引用关系,<br>所以一般在block外部对操作对象会加上<code>__weak</code>,在Block内部使用<code>__strong</code>修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有,</p><p><strong>被__block修饰的对象类型<br>当__block变量在栈上时，不会对指向的对象产生强引用<br>当__block变量被copy到堆时<br>会调用__block变量内部的copy函数<br>copy函数内部会调用_Block_object_assign函数<br>_Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）</strong></p><p>如果__block变量从堆上移除<br>会调用__block变量内部的dispose函数<br>dispose函数内部会调用_Block_object_dispose函数<br>_Block_object_dispose函数会自动释放指向的对象（release）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sarsa算法</title>
    <link href="/2019/04/01/Sarsa%E7%AE%97%E6%B3%95/"/>
    <url>/2019/04/01/Sarsa%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Sarsa-更新行为准则"><a href="#Sarsa-更新行为准则" class="headerlink" title="Sarsa 更新行为准则"></a>Sarsa 更新行为准则</h2><p><a href="https://morvanzhou.github.io/static/results/ML-intro/s3.png"><img src="https://morvanzhou.github.io/static/results/ML-intro/s3.png" alt="Sarsa"></a></p><p>同样, 我们会经历正在写作业的状态 s1, 然后再挑选一个带来最大潜在奖励的动作 a2, 这样我们就到达了 继续写作业状态 s2, 而在这一步, 如果你用的是 Q learning, 你会观看一下在 s2 上选取哪一个动作会带来最大的奖励, 但是在真正要做决定时, 却不一定会选取到那个带来最大奖励的动作, Q-learning 在这一步只是估计了一下接下来的动作值. 而 Sarsa 是实践派, 他说到做到, 在 s2 这一步估算的动作也是接下来要做的动作. 所以 Q(s1, a2) 现实的计算值, 我们也会稍稍改动, 去掉maxQ, 取而代之的是在 s2 上我们实实在在选取的 a2 的 Q 值. 最后像 Q learning 一样, 求出现实和估计的差距 并更新 Q 表里的 Q(s1, a2).</p><h2 id="对比-Sarsa-和-Q-learning-算法"><a href="#对比-Sarsa-和-Q-learning-算法" class="headerlink" title="对比 Sarsa 和 Q-learning 算法"></a>对比 Sarsa 和 Q-learning 算法</h2><p><a href="https://morvanzhou.github.io/static/results/ML-intro/s4.png"><img src="https://morvanzhou.github.io/static/results/ML-intro/s4.png" alt="Sarsa"></a></p><p>从算法来看, 这就是他们两最大的不同之处了. 因为 Sarsa 是说到做到型, 所以我们也叫他 on-policy, 在线学习, 学着自己在做的事情. 而 Q learning 是说到但并不一定做到, 所以它也叫作 Off-policy, 离线学习. 而因为有了 maxQ, Q-learning 也是一个特别勇敢的算法.</p><p><a href="https://morvanzhou.github.io/static/results/ML-intro/s5.png"><img src="https://morvanzhou.github.io/static/results/ML-intro/s5.png" alt="Sarsa"></a></p><p>为什么说他勇敢呢, 因为 Q learning 机器人 永远都会选择最近的一条通往成功的道路, 不管这条路会有多危险. 而 Sarsa 则是相当保守, 他会选择离危险远远的, 拿到宝藏是次要的, 保住自己的小命才是王道. 这就是使用 Sarsa 方法的不同之处.</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://morvanzhou.github.io/static/results/reinforcement-learning/3-1-1.png"><img src="https://morvanzhou.github.io/static/results/reinforcement-learning/3-1-1.png" alt="Sarsa 算法更新"></a></p><p>整个算法还是一直不断更新 Q table 里的值, 然后再根据新的值来判断要在某个 state 采取怎样的 action. 不过于 Qlearning 不同之处:</p><ul><li>他在当前 <code>state</code> 已经想好了 <code>state</code> 对应的 <code>action</code>, 而且想好了 下一个 <code>state_</code> 和下一个 <code>action_</code> (Qlearning 还没有想好下一个 <code>action_</code>)</li><li>更新 <code>Q(s,a)</code> 的时候基于的是下一个 <code>Q(s_, a_)</code> (Qlearning 是基于 <code>maxQ(s_)</code>)</li></ul><p>这种不同之处使得 Sarsa 相对于 Qlearning, 更加的胆小. 因为 Qlearning 永远都是想着 <code>maxQ</code> 最大化, 因为这个 <code>maxQ</code> 而变得贪婪, 不考虑其他非 <code>maxQ</code> 的结果. 我们可以理解成 Qlearning 是一种贪婪, 大胆, 勇敢的算法, 对于错误, 死亡并不在乎. 而 Sarsa 是一种保守的算法, 他在乎每一步决策, 对于错误和死亡比较铭感. 这一点我们会在可视化的部分看出他们的不同. 两种算法都有他们的好处, 比如在实际中, 你比较在乎机器的损害, 用一种保守的算法, 在训练时就能减少损坏的次数.</p><h2 id="算法的代码形式"><a href="#算法的代码形式" class="headerlink" title="算法的代码形式"></a>算法的代码形式</h2><p>首先我们先 import 两个模块, <code>maze_env</code> 是我们的环境模块, 已经编写好了, <code>maze_env</code> 模块，我们可以不深入研究, 如果你对编辑环境感兴趣, 可以去看看如何使用 python 自带的简单 GUI 模块 <code>tkinter</code> 来编写虚拟环境.<code>maze_env</code> 就是用 <code>tkinter</code> 编写的. 而 <code>RL_brain</code> 这个模块是 RL 的大脑部分, 我们下节会讲.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> maze_env <span class="hljs-keyword">import</span> Maze<br><span class="hljs-keyword">from</span> RL_brain <span class="hljs-keyword">import</span> SarsaTable<br></code></pre></td></tr></table></figure><p>下面的代码, 我们可以根据上面的图片中的算法对应起来, 这就是整个 Sarsa 最重要的迭代更新部分啦.</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">update</span>():<br>    for episode in <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        # 初始化环境<br>        observation = env.<span class="hljs-built_in">reset</span>()<br><br>        # Sarsa 根据 state 观测选择行为<br>        action = RL.<span class="hljs-built_in">choose_action</span>(<span class="hljs-built_in">str</span>(observation))<br><br>        while True:<br>            # 刷新环境<br>            env.<span class="hljs-built_in">render</span>()<br><br>            # 在环境中采取行为, 获得下一个 state_ (obervation_), reward, 和是否终止<br>            observation_, reward, done = env.<span class="hljs-built_in">step</span>(action)<br><br>            # 根据下一个 state (obervation_) 选取下一个 action_<br>            action_ = RL.<span class="hljs-built_in">choose_action</span>(<span class="hljs-built_in">str</span>(observation_))<br><br>            # 从 (s, a, r, s, a) 中学习, 更新 Q_tabel 的参数 ==&gt; Sarsa<br>            RL.<span class="hljs-built_in">learn</span>(<span class="hljs-built_in">str</span>(observation), action, reward, <span class="hljs-built_in">str</span>(observation_), action_)<br><br>            # 将下一个当成下一步的 state (observation) and action<br>            observation = observation_<br>            action = action_<br><br>            # 终止时跳出循环<br>            if done:<br>                break<br><br>    # 大循环完毕<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;game over&#x27;</span>)<br>    env.<span class="hljs-built_in">destroy</span>()<br><br>if __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    env = <span class="hljs-built_in">Maze</span>()<br>    RL = <span class="hljs-built_in">SarsaTable</span>(actions=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(env.n_actions)))<br><br>    env.<span class="hljs-built_in">after</span>(<span class="hljs-number">100</span>, update)<br>    env.<span class="hljs-built_in">mainloop</span>()<br></code></pre></td></tr></table></figure><h2 id="代码主结构"><a href="#代码主结构" class="headerlink" title="代码主结构"></a>代码主结构</h2><p>和之前定义 Qlearning 中的 <code>QLearningTable</code> 一样, 因为使用 tabular 方式的 <code>Sarsa</code> 和 <code>Qlearning</code> 的相似度极高,</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SarsaTable</span>:<br>    <span class="hljs-comment"># 初始化 (与之前一样)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, actions, learning_rate=<span class="hljs-number">0.01</span>, reward_decay=<span class="hljs-number">0.9</span>, e_greedy=<span class="hljs-number">0.9</span></span>):<br><br>    <span class="hljs-comment"># 选行为 (与之前一样)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">choose_action</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, observation</span>):<br><br>    <span class="hljs-comment"># 学习更新参数 (有改变)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">learn</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, s, a, r, s_</span>):<br><br>    <span class="hljs-comment"># 检测 state 是否存在 (与之前一样)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_state_exist</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, state</span>)<span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><p>我们甚至可以定义一个 主class <code>RL</code>, 然后将 <code>QLearningTable</code> 和 <code>SarsaTable</code> 作为 主class <code>RL</code> 的衍生, 这个主 <code>RL</code> 可以这样定义. 所以我们将之前的 <code>__init__</code>, <code>check_state_exist</code>, <code>choose_action</code>, <code>learn</code> 全部都放在这个主结构中, 之后根据不同的算法更改对应的内容就好了. 所以还没弄懂这些功能的朋友们, 请回到之前的教程再看一遍.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RL</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, action_space, learning_rate=<span class="hljs-number">0.01</span>, reward_decay=<span class="hljs-number">0.9</span>, e_greedy=<span class="hljs-number">0.9</span></span>):<br>        ... <span class="hljs-comment"># 和 QLearningTable 中的代码一样</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_state_exist</span>(<span class="hljs-params">self, state</span>):<br>        ... <span class="hljs-comment"># 和 QLearningTable 中的代码一样</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">choose_action</span>(<span class="hljs-params">self, observation</span>):<br>        ... <span class="hljs-comment"># 和 QLearningTable 中的代码一样</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">learn</span>(<span class="hljs-params">self, *args</span>):<br>        <span class="hljs-keyword">pass</span> <span class="hljs-comment"># 每种的都有点不同, 所以用 pass</span><br></code></pre></td></tr></table></figure><p>如果是这样定义父类的 <code>RL</code> class, 通过继承关系, 那之子类 <code>QLearningTable</code> class 就能简化成这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QLearningTable</span>(<span class="hljs-title class_ inherited__">RL</span>):   <span class="hljs-comment"># 继承了父类 RL</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, actions, learning_rate=<span class="hljs-number">0.01</span>, reward_decay=<span class="hljs-number">0.9</span>, e_greedy=<span class="hljs-number">0.9</span></span>):<br>        <span class="hljs-built_in">super</span>(QLearningTable, self).__init__(actions, learning_rate, reward_decay, e_greedy)    <span class="hljs-comment"># 表示继承关系</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">learn</span>(<span class="hljs-params">self, s, a, r, s_</span>):   <span class="hljs-comment"># learn 的方法在每种类型中有不一样, 需重新定义</span><br>        self.check_state_exist(s_)<br>        q_predict = self.q_table.loc[s, a]<br>        <span class="hljs-keyword">if</span> s_ != <span class="hljs-string">&#x27;terminal&#x27;</span>:<br>            q_target = r + self.gamma * self.q_table.loc[s_, :].<span class="hljs-built_in">max</span>()<br>        <span class="hljs-keyword">else</span>:<br>            q_target = r<br>        self.q_table.loc[s, a] += self.lr * (q_target - q_predict)<br></code></pre></td></tr></table></figure><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>有了父类的 <code>RL</code>, 我们这次的编写就很简单, 只需要编写 <code>SarsaTable</code> 中 <code>learn</code> 这个功能就完成了. 因为其他功能都和父类是一样的. 这就是我们所有的 <code>SarsaTable</code> 于父类 <code>RL</code> 不同之处的代码. 是不是很简单.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SarsaTable</span>(<span class="hljs-variable constant_">RL</span>):   <span class="hljs-comment"># 继承 RL class</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, actions, learning_rate=<span class="hljs-number">0.01</span>, reward_decay=<span class="hljs-number">0.9</span>, e_greedy=<span class="hljs-number">0.9</span></span>):<br>        <span class="hljs-variable language_">super</span>(<span class="hljs-title class_">SarsaTable</span>, <span class="hljs-variable language_">self</span>).__init__(actions, learning_rate, reward_decay, e_greedy)    <span class="hljs-comment"># 表示继承关系</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">learn</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, s, a, r, s_, a_</span>):<br>        <span class="hljs-variable language_">self</span>.check_state_exist(s_)<br>        q_predict = <span class="hljs-variable language_">self</span>.q_table.loc[s, a]<br>        <span class="hljs-keyword">if</span> s_ != <span class="hljs-string">&#x27;terminal&#x27;</span>:<br>            q_target = r + <span class="hljs-variable language_">self</span>.gamma * <span class="hljs-variable language_">self</span>.q_table.loc[s_, a_]  <span class="hljs-comment"># q_target 基于选好的 a_ 而不是 Q(s_) 的最大值</span><br>        <span class="hljs-symbol">else:</span><br>            q_target = r  <span class="hljs-comment"># 如果 s_ 是终止符</span><br>        <span class="hljs-variable language_">self</span>.q_table.loc[s, a] += <span class="hljs-variable language_">self</span>.lr * (q_target - q_predict)  <span class="hljs-comment"># 更新 q_table</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Q-Learning-2</title>
    <link href="/2019/04/01/Q-Learning-2/"/>
    <url>/2019/04/01/Q-Learning-2/</url>
    
    <content type="html"><![CDATA[<h2 id="算法更新"><a href="#算法更新" class="headerlink" title="算法更新"></a>算法更新</h2><p><a href="https://morvanzhou.github.io/static/results/reinforcement-learning/4-1-1.jpg"><img src="https://morvanzhou.github.io/static/results/reinforcement-learning/4-1-1.jpg" alt="DQN 算法更新 (Tensorflow)"></a></p><p>整个算法乍看起来很复杂, 不过我们拆分一下, 就变简单了. 也就是个 Q learning 主框架上加了些装饰.</p><p>这些装饰包括:</p><ul><li>记忆库 (用于重复学习)</li><li>神经网络计算 Q 值</li><li>暂时冻结 <code>q_target</code> 参数 (切断相关性)<span id="more"></span></li></ul><p>##代码模式</p><p>首先我们先 import 两个模块, <code>maze_env</code> 是我们的环境模块,<code>maze_env</code> 模块我们可以不深入研究, 如果你对编辑环境感兴趣, 可以去看看如何使用 python 自带的简单 GUI 模块 <code>tkinter</code> 来编写虚拟环境.  <code>maze_env</code> 就是用 <code>tkinter</code> 编写的. 而 <code>RL_brain</code> 这个模块是 RL 的大脑部分, 我们下节会讲.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> maze_env <span class="hljs-keyword">import</span> Maze<br><span class="hljs-keyword">from</span> RL_brain <span class="hljs-keyword">import</span> QLearningTable<br></code></pre></td></tr></table></figure><p>下面的代码, 我们可以根据上面的图片中的算法对应起来, 这就是整个 Qlearning 最重要的迭代更新部分啦.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>():<br>    <span class="hljs-comment"># 学习 100 回合</span><br>    <span class="hljs-keyword">for</span> episode <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        <span class="hljs-comment"># 初始化 state 的观测值</span><br>        observation = env.reset()<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 更新可视化环境</span><br>            env.render()<br><br>            <span class="hljs-comment"># RL 大脑根据 state 的观测值挑选 action</span><br>            action = RL.choose_action(<span class="hljs-built_in">str</span>(observation))<br><br>            <span class="hljs-comment"># 探索者在环境中实施这个 action, 并得到环境返回的下一个 state 观测值, reward 和 done (是否是掉下地狱或者升上天堂)</span><br>            observation_, reward, done = env.step(action)<br><br>            <span class="hljs-comment"># RL 从这个序列 (state, action, reward, state_) 中学习</span><br>            RL.learn(<span class="hljs-built_in">str</span>(observation), action, reward, <span class="hljs-built_in">str</span>(observation_))<br><br>            <span class="hljs-comment"># 将下一个 state 的值传到下一次循环</span><br>            observation = observation_<br><br>            <span class="hljs-comment"># 如果掉下地狱或者升上天堂, 这回合就结束了</span><br>            <span class="hljs-keyword">if</span> done:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 结束游戏并关闭窗口</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;game over&#x27;</span>)<br>    env.destroy()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 定义环境 env 和 RL 方式</span><br>    env = Maze()<br>    RL = QLearningTable(actions=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(env.n_actions)))<br><br>    <span class="hljs-comment"># 开始可视化环境 env</span><br>    env.after(<span class="hljs-number">100</span>, update)<br>    env.mainloop()<br></code></pre></td></tr></table></figure><h2 id="代码主结构"><a href="#代码主结构" class="headerlink" title="代码主结构"></a>代码主结构</h2><p>与上回不一样的地方是, 我们将要以一个 class 形式定义 Q learning, 并把这种 tabular q learning 方法叫做 <code>QLearningTable</code>.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QLearningTable</span>:<br>    <span class="hljs-comment"># 初始化</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, actions, learning_rate=<span class="hljs-number">0.01</span>, reward_decay=<span class="hljs-number">0.9</span>, e_greedy=<span class="hljs-number">0.9</span></span>):<br><br>    <span class="hljs-comment"># 选行为</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">choose_action</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, observation</span>):<br><br>    <span class="hljs-comment"># 学习更新参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">learn</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, s, a, r, s_</span>):<br><br>    <span class="hljs-comment"># 检测 state 是否存在</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_state_exist</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, state</span>)<span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><h2 id="预设值"><a href="#预设值" class="headerlink" title="预设值"></a>预设值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QLearningTable</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, actions, learning_rate=<span class="hljs-number">0.01</span>, reward_decay=<span class="hljs-number">0.9</span>, e_greedy=<span class="hljs-number">0.9</span></span>):<br>        self.actions = actions  <span class="hljs-comment"># a list</span><br>        self.lr = learning_rate <span class="hljs-comment"># 学习率</span><br>        self.gamma = reward_decay   <span class="hljs-comment"># 奖励衰减</span><br>        self.epsilon = e_greedy     <span class="hljs-comment"># 贪婪度</span><br>        self.q_table = pd.DataFrame(columns=self.actions, dtype=np.float64)   <span class="hljs-comment"># 初始 q_table</span><br></code></pre></td></tr></table></figure><h2 id="决定行为"><a href="#决定行为" class="headerlink" title="决定行为"></a>决定行为</h2><p>这里是定义如何根据所在的 state, 或者是在这个 state 上的 观测值 (observation) 来决策.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">choose_action</span>(<span class="hljs-params">self, observation</span>):<br>    self.check_state_exist(observation) <span class="hljs-comment"># 检测本 state 是否在 q_table 中存在(见后面标题内容)</span><br><br>    <span class="hljs-comment"># 选择 action</span><br>    <span class="hljs-keyword">if</span> np.random.uniform() &lt; self.epsilon:  <span class="hljs-comment"># 选择 Q value 最高的 action</span><br>        state_action = self.q_table.loc[observation, :]<br><br>        <span class="hljs-comment"># 同一个 state, 可能会有多个相同的 Q action value, 所以我们乱序一下</span><br>        action = np.random.choice(state_action[state_action == np.<span class="hljs-built_in">max</span>(state_action)].index)<br><br>    <span class="hljs-keyword">else</span>:   <span class="hljs-comment"># 随机选择 action</span><br>        action = np.random.choice(self.actions)<br><br>    <span class="hljs-keyword">return</span> action<br></code></pre></td></tr></table></figure><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>我们根据是否是 <code>terminal</code> state (回合终止符) 来判断应该如何更行 <code>q_table</code>. 更新的方式是不是很熟悉呢:</p><p><code>update = self.lr * (q_target - q_predict)</code></p><p>这可以理解成神经网络中的更新方式, 学习率 * (真实值 - 预测值). 将判断误差传递回去, 有着和神经网络更新的异曲同工之处.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">learn</span>(<span class="hljs-params">self, s, a, r, s_</span>):<br>    self.check_state_exist(s_)  <span class="hljs-comment"># 检测 q_table 中是否存在 s_ (见后面标题内容)</span><br>    q_predict = self.q_table.loc[s, a]<br>    <span class="hljs-keyword">if</span> s_ != <span class="hljs-string">&#x27;terminal&#x27;</span>:<br>        q_target = r + self.gamma * self.q_table.loc[s_, :].<span class="hljs-built_in">max</span>()  <span class="hljs-comment"># 下个 state 不是 终止符</span><br>    <span class="hljs-keyword">else</span>:<br>        q_target = r  <span class="hljs-comment"># 下个 state 是终止符</span><br>    self.q_table.loc[s, a] += self.lr * (q_target - q_predict)  <span class="hljs-comment"># 更新对应的 state-action 值</span><br></code></pre></td></tr></table></figure><h2 id="检测-state-是否存在"><a href="#检测-state-是否存在" class="headerlink" title="检测 state 是否存在"></a>检测 state 是否存在</h2><p>这个功能就是检测 <code>q_table</code> 中有没有当前 state 的步骤了, 如果还没有当前 state, 那我我们就插入一组全 0 数据, 当做这个 state 的所有 action 初始 values.</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">def check_state_exist(<span class="hljs-literal">self</span>, <span class="hljs-keyword">state</span>):<br>    if <span class="hljs-keyword">state</span> not <span class="hljs-keyword">in</span> <span class="hljs-literal">self</span>.q_table.index:<br>        <span class="hljs-comment"># append new state to q table</span><br>        <span class="hljs-literal">self</span>.q_table = <span class="hljs-literal">self</span>.q_table.append(<br>            pd.Series(<br>                [<span class="hljs-number">0</span>]*len(<span class="hljs-literal">self</span>.actions),<br>                index=<span class="hljs-literal">self</span>.q_table.columns,<br>                name=<span class="hljs-keyword">state</span>,<br>            )<br>        )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Q-Learning-1</title>
    <link href="/2019/03/29/Q-Learning/"/>
    <url>/2019/03/29/Q-Learning/</url>
    
    <content type="html"><![CDATA[<p>###Q-Learning 整体算法</p><p><a href="https://morvanzhou.github.io/static/results/ML-intro/q4.png"><img src="https://morvanzhou.github.io/static/results/ML-intro/q4.png" alt="Q Leaning"></a></p><p> Q learning 的算法, 每次更新我们都用到了 Q 现实和 Q 估计, 而且 Q learning 的迷人之处就是 在 Q(s1, a2) 现实 中, 也包含了一个 Q(s2) 的最大估计值, 将对下一步的衰减的最大估计和当前所得到的奖励当成这一步的现实, 很奇妙吧. 最后我们来说说这套算法中一些参数的意义. Epsilon greedy 是用在决策上的一种策略, 比如 epsilon &#x3D; 0.9 时, 就说明有90% 的情况我会按照 Q 表的最优值选择行为, 10% 的时间使用随机选行为. alpha是学习率, 来决定这次的误差有多少是要被学习的, alpha是一个小于1 的数. gamma 是对未来 reward 的衰减值. 我们可以这样想象.</p><span id="more"></span><h2 id="Q-Learning-更新"><a href="#Q-Learning-更新" class="headerlink" title="Q-Learning 更新"></a>Q-Learning 更新</h2><p><a href="https://morvanzhou.github.io/static/results/ML-intro/q3.png"><img src="https://morvanzhou.github.io/static/results/ML-intro/q3.png" alt="Q Leaning"></a></p><h2 id="Q-Learning-Gamma"><a href="#Q-Learning-Gamma" class="headerlink" title="Q-Learning Gamma"></a>Q-Learning Gamma</h2><p><img src="https://morvanzhou.github.io/static/results/ML-intro/q5.png" alt="gamma"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">-o<span class="hljs-comment">---T</span><br><span class="hljs-comment"># T 就是宝藏的位置, o 是探索者的位置</span><br></code></pre></td></tr></table></figure><p>Q-learning 是一种记录行为值 (Q value) 的方法, 每种在一定状态的行为都会有一个值 <code>Q(s, a)</code>, 就是说 行为 <code>a</code> 在 <code>s</code> 状态的值是 <code>Q(s, a)</code>. <code>s</code> 在上面的探索者游戏中, 就是 <code>o</code> 所在的地点了. 而每一个地点探索者都能做出两个行为 <code>left/right</code>, 这就是探索者的所有可行的 <code>a</code> 啦.</p><p>如果在某个地点 <code>s1</code>, 探索者计算了他能有的两个行为, <code>a1/a2=left/right</code>, 计算结果是 <code>Q(s1, a1) &gt; Q(s1, a2)</code>, 那么探索者就会选择 <code>left</code> 这个行为. 这就是 Q learning 的行为选择简单规则.</p><h2 id="预设值"><a href="#预设值" class="headerlink" title="预设值"></a>预设值</h2><p>这一次需要的模块和参数设置:</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> time<br><br>N_STATES = <span class="hljs-number">6</span>   # <span class="hljs-number">1</span>维世界的宽度<br>ACTIONS = [<span class="hljs-string">&#x27;left&#x27;</span>, <span class="hljs-string">&#x27;right&#x27;</span>]     # 探索者的可用动作<br>EPSILON = <span class="hljs-number">0.9</span>   # 贪婪度 greedy<br>ALPHA = <span class="hljs-number">0.1</span>     # 学习率<br>GAMMA = <span class="hljs-number">0.9</span>    # 奖励递减值<br>MAX_EPISODES = <span class="hljs-number">13</span>   # 最大回合数<br>FRESH_TIME = <span class="hljs-number">0.3</span>    # 移动间隔时间<br></code></pre></td></tr></table></figure><h2 id="Q-表"><a href="#Q-表" class="headerlink" title="Q 表"></a>Q 表</h2><p>对于 tabular Q learning, 我们必须将所有的 Q values (行为值) 放在 <code>q_table</code> 中, 更新 <code>q_table</code> 也是在更新他的行为准则. <code>q_table</code> 的 index 是所有对应的 <code>state</code> (探索者位置), columns 是对应的 <code>action</code> (探索者行为).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_q_table</span>(<span class="hljs-params">n_states, actions</span>):<br>    table = pd.DataFrame(<br>        np.zeros((n_states, <span class="hljs-built_in">len</span>(actions))),     <span class="hljs-comment"># q_table 全 0 初始</span><br>        columns=actions,    <span class="hljs-comment"># columns 对应的是行为名称</span><br>    )<br>    <span class="hljs-keyword">return</span> table<br><br><span class="hljs-comment"># q_table:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">   left  right</span><br><span class="hljs-string">0   0.0    0.0</span><br><span class="hljs-string">1   0.0    0.0</span><br><span class="hljs-string">2   0.0    0.0</span><br><span class="hljs-string">3   0.0    0.0</span><br><span class="hljs-string">4   0.0    0.0</span><br><span class="hljs-string">5   0.0    0.0</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="定义动作"><a href="#定义动作" class="headerlink" title="定义动作"></a>定义动作</h2><p>接着定义探索者是如何挑选行为的. 这是我们引入 <code>epsilon greedy</code> 的概念. 因为在初始阶段, 随机的探索环境, 往往比固定的行为模式要好, 所以这也是累积经验的阶段, 我们希望探索者不会那么贪婪(greedy). 所以 <code>EPSILON</code> 就是用来控制贪婪程度的值. <code>EPSILON</code> 可以随着探索时间不断提升(越来越贪婪), 不过在这个例子中, 我们就固定成 <code>EPSILON = 0.9</code>, 90% 的时间是选择最优策略, 10% 的时间来探索.</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment"># 在某个 state 地点, 选择行为</span><br>def choose_action(<span class="hljs-keyword">state</span>, q_table):<br>    state_actions = q_table.iloc[<span class="hljs-keyword">state</span>, :]  <span class="hljs-comment"># 选出这个 state 的所有 action 值</span><br>    if (np.<span class="hljs-keyword">random</span>.uniform() &gt; EPSILON) or (state_actions.<span class="hljs-literal">all</span>() == <span class="hljs-number">0</span>):  <span class="hljs-comment"># 非贪婪 or 或者这个 state 还没有探索过</span><br>        action_name = np.<span class="hljs-keyword">random</span>.choice(ACTIONS)<br>    else:<br>        action_name = state_actions.argmax()    <span class="hljs-comment"># 贪婪模式</span><br>    return action_name<br></code></pre></td></tr></table></figure><h2 id="环境反馈-S-R"><a href="#环境反馈-S-R" class="headerlink" title="环境反馈 S_, R"></a>环境反馈 S_, R</h2><p>做出行为后, 环境也要给我们的行为一个反馈, 反馈出下个 state (S_) 和 在上个 state (S) 做出 action (A) 所得到的 reward (R). 这里定义的规则就是, 只有当 <code>o</code> 移动到了 <code>T</code>, 探索者才会得到唯一的一个奖励, 奖励值 R&#x3D;1, 其他情况都没有奖励.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">def get_env_feedback(S, A):<br>    <span class="hljs-comment"># This is how agent will interact with the environment</span><br>    <span class="hljs-keyword">if</span> A == <span class="hljs-string">&#x27;right&#x27;</span>:    <span class="hljs-comment"># move right</span><br>        <span class="hljs-keyword">if</span> S == N_STATES - <span class="hljs-number">2</span>:   <span class="hljs-comment"># terminate</span><br>            S_ = <span class="hljs-string">&#x27;terminal&#x27;</span><br>            <span class="hljs-built_in">R</span> = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            S_ = S + <span class="hljs-number">1</span><br>            <span class="hljs-built_in">R</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:   <span class="hljs-comment"># move left</span><br>        <span class="hljs-built_in">R</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> S == <span class="hljs-number">0</span>:<br>            S_ = S  <span class="hljs-comment"># reach the wall</span><br>        <span class="hljs-keyword">else</span>:<br>            S_ = S - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> S_, <span class="hljs-built_in">R</span><br></code></pre></td></tr></table></figure><h2 id="环境更新"><a href="#环境更新" class="headerlink" title="环境更新"></a>环境更新</h2><p>接下来就是环境的更新了, 不用细看.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def update_env(S, episode, step_counter):<br>    # This is how environment be updated<br>    env_list = [<span class="hljs-string">&#x27;-&#x27;</span>]*(N_STATES-1) + [<span class="hljs-string">&#x27;T&#x27;</span>]   # <span class="hljs-string">&#x27;---------T&#x27;</span> our environment<br>    <span class="hljs-keyword">if</span> S == <span class="hljs-string">&#x27;terminal&#x27;</span>:<br>        interaction = <span class="hljs-string">&#x27;Episode %s: total_steps = %s&#x27;</span> % (episode+1, step_counter)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\r&#123;&#125;&#x27;</span>.format(interaction), <span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br>        time.sleep(2)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\r                                &#x27;</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        env_list[S] = <span class="hljs-string">&#x27;o&#x27;</span><br>        interaction = <span class="hljs-string">&#x27;&#x27;</span>.join(env_list)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\r&#123;&#125;&#x27;</span>.format(interaction), <span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br>        time.sleep(FRESH_TIME)<br></code></pre></td></tr></table></figure><h2 id="强化学习主循环"><a href="#强化学习主循环" class="headerlink" title="强化学习主循环"></a>强化学习主循环</h2><p>最重要的地方就在这里. 你定义的 RL 方法都在这里体现. 在之后的教程中, 我们会更加详细得讲解 RL 中的各种方法, 下面的内容, 大家大概看看就行, 这节内容不用仔细研究.</p><p><a href="https://morvanzhou.github.io/static/results/reinforcement-learning/2-1-1.png"><img src="https://morvanzhou.github.io/static/results/reinforcement-learning/2-1-1.png" alt="小例子"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rl</span>():<br>    q_table = build_q_table(N_STATES, ACTIONS)  <span class="hljs-comment"># 初始 q table</span><br>    <span class="hljs-keyword">for</span> episode <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(MAX_EPISODES):     <span class="hljs-comment"># 回合</span><br>        step_counter = <span class="hljs-number">0</span><br>        S = <span class="hljs-number">0</span>   <span class="hljs-comment"># 回合初始位置</span><br>        is_terminated = <span class="hljs-literal">False</span>   <span class="hljs-comment"># 是否回合结束</span><br>        update_env(S, episode, step_counter)    <span class="hljs-comment"># 环境更新</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_terminated:<br><br>            A = choose_action(S, q_table)   <span class="hljs-comment"># 选行为</span><br>            S_, R = get_env_feedback(S, A)  <span class="hljs-comment"># 实施行为并得到环境的反馈</span><br>            q_predict = q_table.loc[S, A]    <span class="hljs-comment"># 估算的(状态-行为)值</span><br>            <span class="hljs-keyword">if</span> S_ != <span class="hljs-string">&#x27;terminal&#x27;</span>:<br>                q_target = R + GAMMA * q_table.iloc[S_, :].<span class="hljs-built_in">max</span>()   <span class="hljs-comment">#  实际的(状态-行为)值 (回合没结束)</span><br>            <span class="hljs-keyword">else</span>:<br>                q_target = R     <span class="hljs-comment">#  实际的(状态-行为)值 (回合结束)</span><br>                is_terminated = <span class="hljs-literal">True</span>    <span class="hljs-comment"># terminate this episode</span><br><br>            q_table.loc[S, A] += ALPHA * (q_target - q_predict)  <span class="hljs-comment">#  q_table 更新</span><br>            S = S_  <span class="hljs-comment"># 探索者移动到下一个 state</span><br><br>            update_env(S, episode, step_counter+<span class="hljs-number">1</span>)  <span class="hljs-comment"># 环境更新</span><br><br>            step_counter += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> q_table<br></code></pre></td></tr></table></figure><p>写好所有的评估和更新准则后, 我们就能开始训练了, 把探索者丢到环境中, 让它自己去玩吧.</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">__name__</span> == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-variable">q_table</span> = <span class="hljs-function"><span class="hljs-title">rl</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;\r\nQ-table:\n&#x27;</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-variable">q_table</span>)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitLab CI</title>
    <link href="/2019/03/26/GitLab-CI/"/>
    <url>/2019/03/26/GitLab-CI/</url>
    
    <content type="html"><![CDATA[<p>目前团队内部缺少组件发布平台，每次 App 发版都需要组件负责人去发布自己名下涉及的组件。这中间存在组件间依赖以及发布时间差问题，上层组件需要依赖下层组件的发布，负责人之间沟通起来极为耗时。所以团队暂时没有限制私有源仓库的推送权限，当发布时间比较紧时，方便负责人绕过 lint， 直接推送 podspec 到私有源仓库。</p><p>虽然这种发布方式能节省一部分时间，但是容易出现下层组件 lint 失败向上层传递的情况。久而久之，lint 不通过的组件将会越来越多。为了尽量避免这种情况的发生，引入 CI 对组件进行 lint 监测是个不错的选择。</p><p>以上就是团队当初引入 CI 的初衷。不过 CI 能带来的便利远不止如此，当然，这都是后话了。</p><h2 id="GitLab-CI"><a href="#GitLab-CI" class="headerlink" title="GitLab CI"></a>GitLab CI</h2><blockquote><p>本文使用 GitLab Community Edition 10.4.0 版本</p></blockquote><p><a href="https://dmanager.github.io/images/cicd_pipeline_infograph.png"><img src="https://dmanager.github.io/images/cicd_pipeline_infograph.png" alt="cicd_pipeline_infograph"></a></p><p>GitLab 在 8.0 版本之后，就集成了 GitLab CI ，随着版本的迭代，其功能越来越强大。使用者只需要在仓库根目录下 （可以通过仓库的 Setting -&gt; CI&#x2F;CD -&gt; General pipelines settings -&gt; Custom CI config path 设置加载路径，默认根目录）添加 <code>.gitlab-ci.yml</code> 配置文件，并且存在可用的 GitLab Runner ，就可以实现持续集成。</p><p>如果在仓库中没有发现 CI&#x2F;CD 设置项，则需要到 Setting -&gt; CI&#x2F;CD -&gt; Permissions -&gt; Pipeline 打开设置。</p><p>首先需要明确的是和 GitLab CI 任务相关的几个概念： pipeline、stage、job。</p><span id="more"></span><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><p>pipeline 实际是一组 stages 中执行 job 的集合，代表着使用者触发的一次构建 。任何提交，包括 MR 在符合配置文件要求的情况下都可以触发 pipeline，其在网页中的体现如下：</p><p><a href="https://dmanager.github.io/images/Snip20180715_13.png"><img src="https://dmanager.github.io/images/Snip20180715_13.png" alt="pipeline 示意图"></a></p><h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h3><p>pipeline 中的 jobs 按照构建阶段进行分类，这些分类就是一个个 stage 。如 pipeline 示意图所示，一个 pipeline 中可以定义多个 stage ，比如 <code>build</code>,  <code>test</code>,  <code>staging</code>, <code>production</code>，其对应配置语法如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">staging</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">production</span><br></code></pre></td></tr></table></figure><p>stage 的触发顺序和 <code>stages</code> 字段值定义的顺序一致，并且只有完成当前 stage ， pipeline 才会触发下一个 stage ，如果 stage 失败了，则下一个 stage 将不会被触发，完成所有的 stage 表示此次 pipeline 构建成功。</p><h3 id="job"><a href="#job" class="headerlink" title="job"></a>job</h3><p>job 表示 stage 中实际执行的任务。如 pipeline 示意图所示，一个 stage 中可以有多个 job，比如 Test stage 的 <code>test1</code>、<code>test2</code> job，其对应配置语法如下：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">test1</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Test</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">xxxx</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">xxxx</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">xxxx</span><br>    <br><span class="hljs-attribute">test2</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Test</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">xxxx</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">xxxx</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>在有足够 runner （job 执行宿主机） 的情况下，同个 stage 中的 job 是并行的，当 stage 中的所有 job 都执行成功后，该 stage 才算完成，否则视为失败。</p><h2 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h2><blockquote><p>下文操作基于 macOS 系统</p></blockquote><p><a href="https://dmanager.github.io/images/Snip20180718_1.png"><img src="https://dmanager.github.io/images/Snip20180718_1.png" alt="how_does_gitlab_ci_work"></a></p><p>GitLab Runner 和 GitLab 的关系大体如上所示， GitLab Runner 内部会起一个无限循环，根据 <code>check_interval</code> 字段设置的时间间隔，去 GitLab 请求需要执行的任务。更详细的信息可以查看 <a href="https://docs.gitlab.com/ce/ci/runners/#how-shared-runners-pick-jobs">How shared Runners pick jobs </a>，<a href="https://gitlab.com/gitlab-org/gitlab-runner/blob/master/docs/configuration/advanced-configuration.md#how-check_interval-works">How check_interval works</a>。</p><p>GitLab Runner 按服务对象可划分 shared runner 和 specific runner ，10.8 版本后还有 group runner，三者应用场景如下：</p><ul><li>shared runner<ul><li>主要针对要求配置相似的工程，可以运行不同仓库上的任务。</li></ul></li><li>specific runner<ul><li>主要针对要求特殊配置的工程，只能运行特定仓库上的任务。</li></ul></li><li>group runner<ul><li>主要针对某个分组下的所有工程（10.8 及以后版本才有）。</li></ul></li></ul><p>因为团队内部对工程进行了组件化，所以 specific runner 是比较合适的选择，也利于后期向其他业务线推广 CI 。 specific runner 注册需要  shared-runner token ，这个 token 只有 admin 账户可见，一般找 GitLab 的管理人员获取即可。以下为注册成功页（工程页 -&gt; CI &#x2F; CD -&gt; Runners setting）：</p><p><a href="https://dmanager.github.io/images/Snip20180712_4.png"><img src="https://dmanager.github.io/images/Snip20180712_4.png" alt="Snip20180712_4"></a></p><p>左边为注册的 specific runner ，使用上方显示的 <code>npeoZhFa1nHYvTAsf7f_</code> token 即可，右边即是注册成功的 shared runner，运行状态为绿色表示正在运行。</p><p>接下来看下如何在 macOS 上安装注册 GitLab Runner。</p><h3 id="安装-Gitlab-Runner"><a href="#安装-Gitlab-Runner" class="headerlink" title="安装 Gitlab Runner"></a>安装 Gitlab Runner</h3><blockquote><p>In GitLab Runner 10, the name of the executable was renamed from* *gitlab-ci-multi-runner to gitlab-runner</p></blockquote><p>通过 homebrew 安装：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>gitlab-runner<br></code></pre></td></tr></table></figure><p>随着 GitLab Runner 10 的发布，其可执行文件已经从 gitlab-ci-multi-runner 更名为 gitlab-runner，如果需要访问旧版本，可以访问<a href="https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/index.html">这里</a>下载手动安装 。</p><h3 id="注册-Gitlab-Runner"><a href="#注册-Gitlab-Runner" class="headerlink" title="注册 Gitlab Runner"></a>注册 Gitlab Runner</h3><p>1、注册 runner</p><blockquote><p>Currently, the only proven to work mode for macOS is running service in user-mode.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gitlab-runner <span class="hljs-keyword">register</span><br></code></pre></td></tr></table></figure><p>对应的反向操作：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss">gitlab-runner unregister -u url -t <span class="hljs-built_in">token</span><br><br><span class="hljs-meta"># url 为下一个步骤输入值</span><br><span class="hljs-meta"># token 可以从网页端或者配置文件中查看</span><br></code></pre></td></tr></table></figure><p>截止到 GitLab Runner 10， MacOS 中已验证可行的运行模式是用户模式，使用系统模式 <strong>(sudo)</strong> 注册的 Runner 会一直处于 Stuck 状态。</p><p>2、输入 GitLab URL 地址</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Please enter <span class="hljs-keyword">the</span> gitlab-ci coordinator <span class="hljs-built_in">URL</span> (e.g. <span class="hljs-keyword">https</span>://gitlab.com )<br>&gt; GitLab <span class="hljs-built_in">URL</span> 地址<br></code></pre></td></tr></table></figure><p>3、输入注册 Runner 需要的 Token</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">Please enter the gitlab-<span class="hljs-keyword">ci</span> <span class="hljs-keyword">token</span> <span class="hljs-keyword">for</span> this runner<br>&gt; <span class="hljs-keyword">Token</span><br></code></pre></td></tr></table></figure><p>Token 分为 special token 和 shared token，前者在项目设置页可以拿到，后者只能联系 GitLab 管理员或者有 Admin 权限的情况下获得。注册后，会分别成为 special runner 和 shared runner。</p><p>4、输入标志 Runner 的 Tags</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Please enter the gitlab-ci tags <span class="hljs-keyword">for</span> <span class="hljs-built_in">this</span> <span class="hljs-title function_">runner</span> <span class="hljs-params">(comma separated)</span>:<br>iOS,Andriod<br></code></pre></td></tr></table></figure><p><code>.gitlab-ci.yml</code> 中可以设置 <strong>tags</strong> 字段来声明，当前任务只在拥有匹配 Tags 的 Runner 上运行。比如 iOS 编译阶段只能在 Mac Runner 上运行，那么就可以设置这个 Runner 的 Tags 为 <strong>‘iOS’</strong>，并且在 iOS 工程中在字段 <em>*tags **中，添加**‘iOS’</em>* 值。 Tags 最好不要随便命名，遵循适当的命名规则会让后期 CI 的维护轻松许多。</p><p>5、是否允许运行没有设置 tags 的任务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Whether <span class="hljs-keyword">to</span> <span class="hljs-built_in">run</span> untagged jobs [<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>]:<br>[<span class="hljs-literal">false</span>]: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>可以在 GitLab 界面上更改 ，一般为 false。</p><p>6、是否锁定当前工程</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Whether <span class="hljs-keyword">to</span> <span class="hljs-keyword">lock</span> Runner <span class="hljs-keyword">to</span> <span class="hljs-keyword">current</span> project [<span class="hljs-keyword">true</span>/<span class="hljs-keyword">false</span>]:<br>[<span class="hljs-keyword">true</span>]: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>在 Runner 是 special 的情况下比较有用，可以在 GitLab 界面上更改。</p><p>7、Runner 执行者</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Please enter <span class="hljs-keyword">the</span> executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, <span class="hljs-built_in">shell</span>:<br><span class="hljs-built_in">shell</span><br></code></pre></td></tr></table></figure><p>一般为 shell。</p><p>8、选择 docker 为执行者时，需要设置默认的 docker image</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Please</span> enter the Docker image (eg. ruby:<span class="hljs-number">2</span>.<span class="hljs-number">1</span>):<br><span class="hljs-attribute">alpine</span>:latest<br></code></pre></td></tr></table></figure><p>非 docker 执行者，没有这一步。</p><h3 id="启动-x2F-关闭-Gitlab-Runner"><a href="#启动-x2F-关闭-Gitlab-Runner" class="headerlink" title="启动&#x2F;关闭 Gitlab Runner"></a>启动&#x2F;关闭 Gitlab Runner</h3><p>执行以下命令安装 runner 服务，并且启动它：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">gitlab-runner install [<span class="hljs-comment">--working-directory]</span><br>gitlab-runner <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p>关闭操作：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">gitlab-runner stop<br>gitlab-runner uninstall<br></code></pre></td></tr></table></figure><p>需要注意的是， 在不加 <code>--working-directory</code> 参数的情况下，runner 工作目录默认为执行 <code>install</code> 命令目录 ，触发了任务后，runner 会在此目录下创建 builds 文件夹 。</p><p>更多关于 runner 的命令，可以查看 <a href="https://docs.gitlab.com/runner/commands/README.html">GitLab Runner Commands</a></p><h3 id="配置GitLab-Runner"><a href="#配置GitLab-Runner" class="headerlink" title="配置GitLab Runner"></a>配置GitLab Runner</h3><p>注册后 runner 的配置信息默认保存在 <code>~/.gitlab-runner/config.toml</code> 文件中，其文件格式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua">concurrent = <span class="hljs-number">1</span><br>check_interval = <span class="hljs-number">0</span><br><br><span class="hljs-string">[[runners]]</span><br>  name = <span class="hljs-string">&quot;iOS &amp; Android CI Runner on packboy&quot;</span><br>  url = <span class="hljs-string">&quot;http://git.2dfire-inc.com/&quot;</span><br>  token = <span class="hljs-string">&quot;1ff160dc4d8f9c36e9b138adc4712a&quot;</span><br>  executor = <span class="hljs-string">&quot;shell&quot;</span><br>  output_limit = <span class="hljs-number">4096</span><br>  [runners.cache]<br>  <br><span class="hljs-string">[[runners]]</span><br>  name = <span class="hljs-string">&quot;xxxx&quot;</span><br>  ...<br>  [runners.cache]<br></code></pre></td></tr></table></figure><p>文件分为 <code>Global Section</code> 和 <code>[[runners]] Section</code> 两部分，这里只说下常用字段，想要了解更多信息，可以查看 <a href="https://docs.gitlab.com/runner/configuration/advanced-configuration.html">GitLab Runner advanced configuration</a> 。</p><p><code>Global Section</code> 常用部分：</p><table><thead><tr><th align="left">Setting</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>concurrent</code></td><td align="left">可并发执行的最大任务数，0 不代表无限制</td></tr><tr><td align="left"><code>log_level</code></td><td align="left">Log 等级 (可选择: debug, info, warn, error, fatal, panic)。优先级比通过命令行 —debug， -l 或 –log-level 设置低</td></tr><tr><td align="left"><code>check_interval</code></td><td align="left">设置轮询新任务的周期，单位（秒）。默认值为 3 秒，如果设置为 0 或者比 3 小，此字段使用默认值。</td></tr></tbody></table><p>这里需要注意的是， <a href="http://blog.cocoapods.org/CocoaPods-1.3.0/">CocoaPods 1.3.0 Release Blog</a> 在 <a href="http://blog.cocoapods.org/CocoaPods-1.3.0/">Notable Enhancements</a> 一节指出：</p><blockquote><p>Each lint execution now runs in a unique temp folder. This allows for running multiple lint processes in parallel, for example within a CI environment.</p></blockquote><p>也就是说， 在 1.3.0 版本之前，由于共用了承载 lint 操作的文件夹， CocoaPods 并不支持多个组件同时进行 lint。这就需要我们在设置 runner 的 concurrenct 配置时，确认实际使用的 CocoaPods 版本，如果低于 1.3.0 ，concurrenct 必须设置成 1 。</p><p><code>[[runners]] Section</code> 常用部分</p><table><thead><tr><th align="left">Setting</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>name</code></td><td align="left">runner 名称</td></tr><tr><td align="left"><code>url</code></td><td align="left">GitLab URL</td></tr><tr><td align="left"><code>token</code></td><td align="left">runner 专有 token (不是注册 runner 时输入的 GitLab token)，unregister 时可以使用</td></tr><tr><td align="left"><code>limit</code></td><td align="left">这个 token 下可并发执行的最大任务数，默认 0 ，表示无限制（<strong>需要结合上述 CocoaPods 1.3.0 版本以下的限制考虑</strong>）</td></tr><tr><td align="left"><code>builds_dir</code></td><td align="left">runner 工作目录，默认会在 <code>install</code> 目录下创建 builds 文件夹</td></tr><tr><td align="left"><code>cache_dir</code></td><td align="left">cache 保存目录</td></tr><tr><td align="left"><code>environment</code></td><td align="left">添加&#x2F;覆盖环境变量，如 <code>environment = [&quot;ENV=value&quot;, &quot;LC_ALL=en_US.UTF-8&quot;]</code></td></tr><tr><td align="left"><code>output_limit</code></td><td align="left">输出 log 大小限制，默认 4096 (4M)，建议设置成 0，不限制大小</td></tr><tr><td align="left"><code>pre_clone_script</code></td><td align="left">clone 之前执行的脚本，可以用来调整 Git 客户端配置</td></tr><tr><td align="left"><code>pre_build_script</code></td><td align="left">clone 之后，build 之前执行的脚本</td></tr><tr><td align="left"><code>post_build_script</code></td><td align="left">build 之后，<code>after_script</code> 之前执行的脚本</td></tr><tr><td align="left"><code>clone_url</code></td><td align="left">自定义 clone 仓库的 url</td></tr></tbody></table><h2 id="配置-gitlab-ci-yml"><a href="#配置-gitlab-ci-yml" class="headerlink" title="配置 .gitlab-ci.yml"></a>配置 .gitlab-ci.yml</h2><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">before_script</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">export LANG=en_US.UTF-8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">export LANGUAGE=en_US:en</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">export LC_ALL=en_US.UTF-8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pwd</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">git clone git@git.2dfire-inc.com:ios/ci-yaml-shell.git </span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/before_shell_executor.sh</span><br><br><span class="hljs-attribute">after_script</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">rm -fr ci-yaml-shell</span><br><br><span class="hljs-attribute">stages</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">check</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">lint</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">package</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">publish</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">report</span><br><br><span class="hljs-attribute">component_check</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">check</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/component_check_executor.rb</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/^release.*$/</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CI</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br>    <br><span class="hljs-attribute">lib_lint</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lint</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/^release.*$/</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CI</span><br>  <span class="hljs-attribute">retry</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/lib_lint_executor.sh</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br>    <br><span class="hljs-attribute">oc_lint</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lint</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CI</span><br>  <span class="hljs-attribute">retry</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/oclint_executor.sh lint_result</span><br>  <span class="hljs-attribute">after_script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cat lint_result | python -m json.tool</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br>    <br><span class="hljs-attribute">unit_test</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">test</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">CI</span><br>  <span class="hljs-attribute">retry</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">: </span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/unit_test_executor.sh</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br>    <br><span class="hljs-attribute">package_framework</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">package </span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/framework_pack_executor.sh</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br>    <br><span class="hljs-attribute">publish_pod</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">publish</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span><br>  <span class="hljs-attribute">retry</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/publish_executor.sh</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br>    <br><span class="hljs-attribute">report_to_director</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">stage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">report</span><br>  <span class="hljs-attribute">script</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ci-yaml-shell/report_executor.sh</span><br>  <span class="hljs-attribute">only</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span><br>  <span class="hljs-attribute">when</span><span class="hljs-punctuation">:</span> <span class="hljs-string">on_failure</span><br>  <span class="hljs-attribute">tags</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">iOS</span><br></code></pre></td></tr></table></figure><p>以上是团队目前采用的 <code>.gitlab-ci.yml</code> 配置，涉及的关键字在官方文档 <a href="https://docs.gitlab.com/ce/ci/yaml/README.html">Configuration of your jobs with .gitlab-ci.yml</a> 有非常详细的介绍，这里不做赘述，只说下这样配置的几点考虑。</p><p>1、所有 stage 脚本，都保存在 ci-yaml-shell 仓库中，在执行 global <code>before_script</code> 时下载（通过 ssh ，不受 GitLab CI 权限影响）。这是因为工程在组件化后会产生非常多的仓库 ，这样做有利于 CI 脚本的统一修改和管理，只要在每个仓库的 <code>.gitlab-ci.yml </code>配置中预留足够多的入口即可，后期修改调试比较方便。比如需要新增 <code>xcpretty</code> 依赖，只需在 <code>before_shell_executor.sh</code> 脚本中添加 <code>gem install xcpretty --no-ri --no-rdoc</code> 即可辐射到所有组件。</p><p>2、考虑到组件集成 CI 时，最好能创建相应的调试分支，我们在 <code>check</code>、<code>test</code>、<code>lint</code> 三个 stage 的 <code>only</code> 字段中都添加了 <code>CI</code> 分支。由于在调试阶段，此分支的 CI 执行结果并且不会推送至钉钉。<code>package</code> 和 <code>publish</code> 已经是 CD 阶段了，所以只在提交 tags 时触发。</p><p>3、团队采用 GitFlow 工作流 （在组件较多的情况下，维护 master 和 develop 两个相似分支的工作量比较大，后期会考虑优化工作流，比如采用 GitLab Flow，或者自定义 GitHub Flow），在提交 MR （release -&gt; master） 时需要触发 CI ，当 CI 成功后方可合并，所以在 <code>component_check</code> 和 <code>lib_lint</code> 两个 job 的 <code>only</code> 字段中都添加了 <code>/^release.*$/</code> 正则。</p><p>4、<code>report</code> stage 负责在 CI 执行失败后，推送钉钉消息 @ 相应的负责人和触发者，这块思路可以参照 <a href="http://triplecc.github.io/blog/2017-11-08-chuang-jian-cocoapodscha-jian/">编写自己的 CocoaPods 插件</a>，后期我也重构并优化了这块代码。 <code>publish</code> stage 在发布组件成功后，同样会推送钉钉消息。</p><p>5、stage 的失败条件是任务<strong>最后一个执行的命令</strong>返回非零结果 (<strong>$?</strong>)，所以在编写 shell 脚本的时候需要注意，如果有 shell 命令执行抛错了，要提前 exit ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># framework_pack_executor.sh</span><br><br>...<br>ruby $(dirname <span class="hljs-string">&quot;$0&quot;</span>)/validate_specification.rb || &#123; <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>; &#125;<br>...<br></code></pre></td></tr></table></figure><p>否则即使 shell 脚本中间有某些命令执行失败，但最后一个命令执行成功，stage 最终结果也会是成功的。如果是 ruby 脚本，比如上方配置的 <code>component_check</code> 任务 ，就可以规避这个问题，直接 <code>raise</code> 即可。</p><p>6、由于所有配置都在 ci-yaml-shell 仓库中，会导致安装的 gem 依赖都是一致的，如果其他业务线使用不同版本的CocoaPods ，可能会导致 CI 报错。所以组件仓库可以添加自己的 Gemfile ，定制 gem 依赖，脚本会对这种情况进行兼容 ：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"># publish_executor.sh<br>...<br><span class="hljs-keyword">if</span> <span class="hljs-string">[[ -f &quot;Gemfile&quot; ]]</span>; <span class="hljs-keyword">then</span> <br>  bundle install<br>  bundle exec pod binary publish <span class="hljs-comment">--verbose</span><br><span class="hljs-keyword">else</span><br>  pod $(pod_gem_version) binary publish <span class="hljs-comment">--verbose</span><br>fi<br>...<br></code></pre></td></tr></table></figure><p>7、<code>component_check</code> 这个入口主要对组件进行一些简单快速的校验，比如我们针对目前团队组件中存在的一些问题，设置的 podspec 校验：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># validate_specification.rb<br>require <span class="hljs-string">&#x27;cocoapods&#x27;</span><br><br>spec_file = Pathname.glob(<span class="hljs-string">&#x27;*.podspec&#x27;</span>).first<br><br><span class="hljs-keyword">raise</span> &quot;can`t find specfile at #&#123;Dir.pwd&#125;&quot; <span class="hljs-keyword">if</span> spec_file.nil?<br><br>spec = Pod::Specification.from_file(spec_file)<br><br>Pod::UI.section(<span class="hljs-string">&#x27;校验依赖限制&#x27;</span>) <span class="hljs-keyword">do</span><br>  none_requirement_dependencies = spec.dependencies.<span class="hljs-keyword">select</span> <span class="hljs-keyword">do</span> |dep|<br>    dep.requirement.<span class="hljs-keyword">none</span>?<br>  <span class="hljs-keyword">end</span><br><br>  fire_source = Pod::Config.instance.sources_manager.<span class="hljs-keyword">all</span>.<span class="hljs-keyword">select</span> <span class="hljs-keyword">do</span> |s|<br>    s.url.downcase.<span class="hljs-keyword">include</span>?(<span class="hljs-string">&#x27;2dfire&#x27;</span>)<br>  <span class="hljs-keyword">end</span>.first<br><br>  <span class="hljs-keyword">if</span> none_requirement_dependencies.<span class="hljs-keyword">any</span>?<br>    version_hash = &#123;&#125;<br>    none_requirement_dependencies.<span class="hljs-keyword">each</span> <span class="hljs-keyword">do</span> |dep|<br>      versions = fire_source.versions(dep.root_name)<br>      next <span class="hljs-keyword">if</span> versions.nil?<br><br>      newest_version = versions.sort.last<br>      version_hash[dep.root_name] = &quot;#&#123;newest_version.major&#125;.#&#123;newest_version.minor&#125;&quot;<br>    <span class="hljs-keyword">end</span><br><br>    old_require = none_requirement_dependencies.map &#123; |dep| &quot;s.dependency &#x27;#&#123;dep.name&#125;&#x27;&quot; &#125;.<span class="hljs-keyword">join</span>(&quot;\n&quot;)<br>    new_require = none_requirement_dependencies.map &#123; |dep| &quot;s.dependency &#x27;#&#123;dep.name&#125;&#x27;, &#x27;~&gt; #&#123;version_hash[dep.root_name]&#125;&#x27;&quot; &#125;.<span class="hljs-keyword">join</span>(&quot;\n&quot;)<br>    err_message = &quot;podspec 依赖需要设置限制，将：\n#&#123;old_require&#125; \n依赖更换为：\n#&#123;new_require&#125;&quot;<br>    Pod::UI.puts err_message.red<br>    <span class="hljs-keyword">raise</span> err_message<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><br>Pod::UI.section(<span class="hljs-string">&#x27;校验版本层级标识&#x27;</span>) <span class="hljs-keyword">do</span><br>  COMPONENTS_LABELS = %w[<br>    basic<br>    weakbusiness<br>    business<br>  ].<span class="hljs-keyword">freeze</span><br><br>  labels = COMPONENTS_LABELS.<span class="hljs-keyword">select</span> <span class="hljs-keyword">do</span> |l|<br>    spec.<span class="hljs-keyword">summary</span>.start_with?(l)<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">if</span> labels.empty?<br>    err_message = &quot;podspec 需要在 summary 字段中，为组件添加层级标识。分为以下层级 #&#123;COMPONENTS_LABELS&#125;，如:\ns.summary = &#x27;#&#123;COMPONENTS_LABELS.first&#125; #&#123;spec.summary&#125;&#x27;&quot;<br>    Pod::UI.puts err_message.red<br>    <span class="hljs-keyword">raise</span> err_message<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><br>Pod::UI.section(<span class="hljs-string">&#x27;校验业务线私有组件包含关系&#x27;</span>) <span class="hljs-keyword">do</span><br>  SPECIFiC_BUSSINESS_LINE_PODS =  %w[<br>    TDFLoginAssistant<br>    TDFBossBaseInfoDefaults<br>  ].<span class="hljs-keyword">freeze</span><br><br>  specific_pods = spec.dependencies.<span class="hljs-keyword">select</span> <span class="hljs-keyword">do</span> |dep|<br>    SPECIFiC_BUSSINESS_LINE_PODS.<span class="hljs-keyword">include</span>?(dep.root_name)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">if</span> specific_pods.<span class="hljs-keyword">any</span>?<br>    err_message = &quot;podspec 中不能包含业务线特殊组件/调试组件 #&#123;specific_pods.map(&amp;:name).join(&#x27;, &#x27;)&#125;&quot;<br>    Pod::UI.puts err_message.red<br>    <span class="hljs-keyword">raise</span> err_message<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>Pod::UI.section(<span class="hljs-string">&#x27;校验 pch 文件引用&#x27;</span>) <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> spec.prefix_header_file<br>    err_message = &quot;podspec 不能设置 pch 属性，删除 prefix_header_file 的设置，调整头文件引用&quot;<br>    Pod::UI.puts err_message.red<br>    <span class="hljs-keyword">raise</span> err_message<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这些校验自动监测了组件规范，可以减少一些组件的人工维护成本。</p><p>以下分别是 master、tags、release 分支触发 CI 后的 pipeline 截图：</p><p><a href="https://dmanager.github.io/images/Snip20180713_11.png"><img src="https://dmanager.github.io/images/Snip20180713_11.png" alt="Snip20180713_7"></a></p><p><a href="https://dmanager.github.io/images/Snip20180713_10.png"><img src="https://dmanager.github.io/images/Snip20180713_10.png" alt="Snip20180713_8"></a></p><p><a href="https://dmanager.github.io/images/Snip20180713_9.png"><img src="https://dmanager.github.io/images/Snip20180713_9.png" alt="Snip20180713_9"></a></p><p>master 和 tags 触发的 CI 会将执行结果推送至钉钉，release 分支推送比较频繁，所以只执行了两个必须的 stage，减少 runner 资源的占用。由于 master 是线上分支，必须进行最严格的检查，而 tags 主要是进行 CD 操作，为了加快组件的发布，省略了一些检测任务。为了更加清晰地展示所有组件的 CI 执行结果，可以利用 cocoapods gem 获取私有源的所有组件，并将 <a href="https://docs.gitlab.com/ee/user/project/pipelines/settings.html#pipeline-status-badge">pipeline badge</a> 展示在网页上：</p><p>在开发中，可能会遇到不想触发 CI 情况，这时只需要让 commit 信息包含 <code>[ci skip]</code> 或者 <code>[skip ci]</code> （不分大小写）即可。</p><h2 id="提示汇总"><a href="#提示汇总" class="headerlink" title="提示汇总"></a>提示汇总</h2><h3 id="编码错误"><a href="#编码错误" class="headerlink" title="编码错误"></a>编码错误</h3><p>搭建 CI 时，发现只有 shared runner 会因为编码问题而执行失败，special runner 仅仅报了 warning。</p><p>根据 <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/14983">CI: How to set UTF-8 in the server?</a> 和 <a href="https://github.com/supermarin/xcpretty/issues/48">xcpretty US-ASCII encoding problems</a> 上的解答，可以在 <code>before_script</code> 下添加以下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">- - <span class="hljs-built_in">export</span> <span class="hljs-attribute">LANG</span>=en_US.UTF-8<br>- <span class="hljs-built_in">export</span> <span class="hljs-attribute">LANGUAGE</span>=en_US:en<br>- <span class="hljs-built_in">export</span> <span class="hljs-attribute">LC_ALL</span>=en_US.UTF-8<br></code></pre></td></tr></table></figure><h3 id="unit-test-出现-Scheme-is-not-currently-configured-for-the-test-action"><a href="#unit-test-出现-Scheme-is-not-currently-configured-for-the-test-action" class="headerlink" title="unit test 出现 Scheme is not currently configured for the test action"></a>unit test 出现 Scheme is not currently configured for the test action</h3><p>这个问题分为必现和概现两种情况，先说必现的情况。</p><p>执行单测时，需要在对应 scheme 下添加 test targets：</p><p><a href="https://dmanager.github.io/images/Snip20180711_2.png"><img src="https://dmanager.github.io/images/Snip20180711_2.png" alt="Snip20180711_2"></a></p><p>一般 Xcode 会在创建工程时，默认添加这些配置。如果发现此栏没有问题， CI 的单测还是提示 action 错误，那就要排查下是否是 .gitignore 引起的问题了。</p><p>在我们点击 Edit Scheme &#x2F; Manager Schemes 后，会发现每个 scheme 都会有个 shared 选项，勾选了之后，就会在 <code>*.xcodeproj/xcshareddata/xcschemes</code> 目录下生成相关文件，里面存储了可以在版本控制系统共享的项目配置。</p><p><a href="https://dmanager.github.io/images/Snip20180711_1.png"><img src="https://dmanager.github.io/images/Snip20180711_1.png" alt="Snip20180711_1"></a></p><p>在没有勾选时，项目配置都保存在 <code>*.xcodeproj/xcuserdata</code> 目录下，一般针对 iOS 工程的 .gitignore 都会包含以下条目：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">xcuserdata/<br></code></pre></td></tr></table></figure><p>这就导致即使本地正确地设置了 scheme ，可以正常运行单测 ，远程 runner 执行相应操作时，还是获取不到正确的配置。所以要添加单测的组件， scheme 这栏一定要勾选 shared 。</p><p>接下来说下概现的情况。</p><p>先看下的 <code>pod lib create</code> 获取老 <code>pod-template</code> 工程所暴露的问题 ：<a href="https://github.com/CocoaPods/CocoaPods/issues/2929">pod lib create generates a project that randomly crashes when running tests</a></p><p>简单来说，就是有两个 scheme 重名了 （工程 scheme，及 pod 生成的组件 scheme）， xcodebuild 无法找到正确的 scheme 执行单测。</p><p>事实上，手动创建的工程也会存在这个问题，其工程结构和老 <code>pod-template</code> 相似。</p><p>要规避这两种情况，最简单的方法就是使用 <code>pod lib create</code> 拉取新的 <code>pod-template</code>，将旧工程直接挪过去。我们也可以根据自己的需求，创建私有 <code>pod-template</code>，然后通过指定 <code>--template-url</code> 获取。</p><h3 id="Pipeline-Job-卡在-Cloning-repository…，Runner-宿主机提示输入-Keychain-密码"><a href="#Pipeline-Job-卡在-Cloning-repository…，Runner-宿主机提示输入-Keychain-密码" class="headerlink" title="Pipeline Job 卡在 Cloning repository…，Runner 宿主机提示输入 Keychain 密码"></a>Pipeline Job 卡在 Cloning repository…，Runner 宿主机提示输入 Keychain 密码</h3><p>登录 runner 的宿主机后，可以看到提示如下：</p><p><a href="https://dmanager.github.io/images/Snip20180711_3.png"><img src="https://dmanager.github.io/images/Snip20180711_3.png" alt="Snip20180711_3"></a></p><p>runner 默认通过 http &#x2F; https 对代码进行 clone &#x2F; fetch ，在没有配置用户名密码，或配置错误时，就会出现如上提示。输入密码后，一段时间内可以正常下载代码，过了有效时间，又会弹出上方提示框。</p><p>参照 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">Git-工具-凭证存储</a>，我们使用 <code>store</code> 模式来处理凭证信息（这里更推荐使用 <code>osxkeychain</code> 模式，可以参照 <a href="https://stackoverflow.com/questions/16052602/disable-git-credential-osxkeychain">disable git credential-osxkeychain</a> ），创建 <code>.gitconfig</code> 如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[credential]</span><br>  <span class="hljs-attr">helper</span> = store --file <span class="hljs-variable">$HOME</span>/.git-credentials<br><span class="hljs-section">[user]</span><br>  <span class="hljs-attr">name</span> = gitlab-runner<br>  <span class="hljs-attr">email</span> = xxxx<br></code></pre></td></tr></table></figure><p><code>--file</code> 是 <code>store </code>模式用来自定义存放密码的文件路径（默认是<code>~/.git-credentials</code>）。<code>.git-credentials</code> 文件内容格式如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//用户名:密码@GitHost</span><br><br><span class="hljs-meta"># 如 http:<span class="hljs-comment">//gitlab-ci-token:a8mzWa7FKb1Wzbf9MQeS@git.2dfire-inc.com</span></span><br></code></pre></td></tr></table></figure><p>设置完后，可以使用 <code>git config --list</code> 查看配置信息，注意 helper 的先后顺序会影响最终执行结果。</p><p>如果有需要用到 ssh 的情况，可以参考 <a href="https://docs.gitlab.com/ee/ci/ssh_keys/">Using SSH keys with GitLab CI&#x2F;CD</a>，<a href="https://stackoverflow.com/questions/39208420/how-do-i-enable-cloning-over-ssh-for-a-gitlab-runner">How do I enable cloning over SSH for a Gitlab runner?</a></p><h3 id="xcodebuild-编译时无法找到对应模拟器的-OS-版本"><a href="#xcodebuild-编译时无法找到对应模拟器的-OS-版本" class="headerlink" title="xcodebuild 编译时无法找到对应模拟器的 OS 版本"></a>xcodebuild 编译时无法找到对应模拟器的 OS 版本</h3><p>xcodebuild 编译时需要指定 <code>-destination</code> 参数，在有多台 runner 的情况下，模拟器对应的 OS 版本是未知的，所以不能在脚本中写死，可以通过以下方式统一使用 iPhoneX ：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">build<span class="hljs-constructor">_destination()</span>&#123;<br>  devices=<span class="hljs-constructor">$(<span class="hljs-params">instruments</span> -<span class="hljs-params">s</span> <span class="hljs-params">devices</span>)</span><br>  os=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> $&#123;<span class="hljs-params">devices</span>##<span class="hljs-operator">*</span><span class="hljs-params">iPhone</span> X&#125; | <span class="hljs-params">grep</span> -Eo &#x27;[0-9]+[.][0-9]+&#x27;)</span><br>  destination=<span class="hljs-string">&quot;platform=iOS Simulator,name=iPhone X,OS=$os&quot;</span><br>  echo $destination<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="兼容-Example-scheme"><a href="#兼容-Example-scheme" class="headerlink" title="兼容 -Example scheme"></a>兼容 -Example scheme</h3><p>xcodebuild 编译时需要指定 <code>-scheme </code>参数，<code>pod lib create</code> 创建的工程 scheme 名称都以 <code>-Example</code> 结尾，手动创建的工程则一般和文件夹名一致，可以通过以下脚本获取 scheme 的名称：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">infors = <span class="hljs-string">`xcodebuild -list`</span>.split(<span class="hljs-string">&quot;\n&quot;</span>).map(&amp;<span class="hljs-symbol">:strip</span>)<br><br>scheme = <span class="hljs-literal">nil</span><br>flag = <span class="hljs-literal">false</span><br>infors.each <span class="hljs-keyword">do</span> |<span class="hljs-params">i</span>|<br>  flag = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;Schemes:&#x27;</span><br><br>  <span class="hljs-keyword">if</span> flag &amp;&amp; i.end_with?(<span class="hljs-string">&#x27;Example&#x27;</span>)<br>    scheme = i<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>puts scheme<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.gitlab.com/ee/ci/variables/">GitLab CI&#x2F;CD Variables</a></p><p><a href="https://docs.gitlab.com/ce/ci/README.html">GitLab Continuous Integration</a></p><p><a href="https://docs.gitlab.com/ce/ci/runners/">Configuring GitLab Runners</a></p><p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html">Configuration of your jobs with .gitlab-ci.yml</a></p><p><a href="https://docs.gitlab.com/runner/install/osx.html">Install GitLab Runner on macOS</a></p><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html">Introduction to pipelines and jobs</a></p><p><a href="https://www.rubydoc.info/gems/gitlab/3.6.1">A Ruby wrapper and CLI for the GitLab API</a></p><p><a href="https://gitlab.com/gitlab-org/gitlab-runner/blob/master/docs/configuration/advanced-configuration.md">GitLab Runner advanced configuration</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">Git 工具 - 凭证存储</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Runloop</title>
    <link href="/2019/03/16/Runloop/"/>
    <url>/2019/03/16/Runloop/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> 本篇主要是围绕着项目使用到的Runloop的应用场景及衍生出来的知识点，将讲述以下部分：</p><ul><li>控制线程的生命周期【线程保活】</li><li>解决NSTimer在滑动过程中停止工作的问题及衍生问题</li><li>监控应用卡顿</li><li>性能优化</li></ul><p><img src="https://i.loli.net/2020/12/16/bF3XPHuQE9yoqxG.png" alt="2020-12-16-4.12.57.png"></p><h2 id="一、线程保活"><a href="#一、线程保活" class="headerlink" title="一、线程保活"></a>一、线程保活</h2><p>线程保活问题,从字面意思上就是保护线程的生命周期不结束.正常情况下,当线程执行完一次任务之后,需要进行资源回收,但是当有一个任务,随时都有可能去调用,如果在子线程去执行,并且让子线程一直存活着,为了避免来回多次创建毁线程的动作, 降低性能消耗.</p><h3 id="情景1"><a href="#情景1" class="headerlink" title="情景1"></a>情景1</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-comment">//定义继承自NSThread线程</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYThread</span> : <span class="hljs-title">NSThread</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ZXYThread</span></span><br><span class="hljs-comment">//线程销毁会被调用</span><br>- (<span class="hljs-type">void</span>)dealloc<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br><br>    <span class="hljs-keyword">self</span>.thread = [[ZXYThread alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(run) object:<span class="hljs-literal">nil</span>];<br>    [<span class="hljs-keyword">self</span>.thread start];<br>&#125;<br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br><span class="hljs-comment">// 子线程需要执行的任务</span><br>- (<span class="hljs-type">void</span>)test<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)run &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s ----end----&quot;</span>, __func__);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>当执行完上面的代码后,会发现打印出如下-[子线程也就销毁了]</p><p>但是运行完App,当点击App时没有反应,也可以证明此线程已经销毁.如果改进让线程处于随时接受命令的状态呢?</p><h3 id="情景2"><a href="#情景2" class="headerlink" title="情景2"></a>情景2</h3><p>从Runloop中得知,如果Mode里没有任何的Source0&#x2F;Source1&#x2F;Timer&#x2F;Observer, Runloop会立马退出.</p><p>所以会想到能不能向其中加入上面中的一个是否可以如下: [run 方法中]</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 这个方法的目的：线程保活</span><br>- (<span class="hljs-type">void</span>)run &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-comment">// 往RunLoop里面添加Source\Timer\Observer</span><br>    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br><span class="hljs-comment">//    [[NSRunLoop currentRunLoop] addTimer:[[NSTimer alloc]init] forMode:NSDefaultRunLoopMode];</span><br>    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] run];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s ----end----&quot;</span>, __func__);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过在run方法中加入上面代码,让线程一直不死,打印屏幕界面:</p><p><img src="https://i.loli.net/2020/12/16/bGvNnoDlcUdYy74.png" alt="2020-12-16-4.14.23.png"></p><p>好像上面已经满足了要求,达到了线程不死的状态,但是能不能在销毁页面控制器的时候,也销毁定时器,并且随时停掉定时器.</p><span id="more"></span><h3 id="情景3"><a href="#情景3" class="headerlink" title="情景3"></a>情景3</h3><p><strong>知识点:</strong> </p><blockquote><p>如何停止runloop?通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>方法可停掉定时器,但是对于用<code>[[NSRunLoop currentRunLoop] run]</code>的Runloop是不会停掉的,因为通过<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>方法仅仅是停掉了本次的Runloop,而不是停掉所有的,但是<code>[[NSRunLoop currentRunLoop] run]</code>的run方法是一直有runloop循环,所以通过<code>[[NSRunLoop currentRunLoop] run]</code>方法是不可能被停掉runloop的</p><p>那应该改成什么样的? —-[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</p></blockquote><p>下面直接用代码来解释,里面已经写明了代码思路,下面是A页面-&gt;B页面-&gt;A页面</p><p><img src="https://i.loli.net/2020/12/16/I5ULo7fuzgTEmct.png" alt="2020-12-16-4.14.32.png"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-comment">//继承自NSThead的子线程</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) ZXYThread *thread;<br><span class="hljs-comment">//有个暂停定时器的需求,stopped代表是否点击了暂停</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">getter</span>=isStoped) <span class="hljs-type">BOOL</span> stopped;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br><br>    <span class="hljs-comment">//NSThread使用block的方法,消除循环引用</span><br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br><br>    <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">self</span>.thread = [[ZXYThread alloc] initWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----begin----&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br><br>        <span class="hljs-comment">// 往RunLoop里面添加Source\Timer\Observer</span><br>        [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br><br>        <span class="hljs-keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStoped) &#123;<br>            [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>        &#125;<br><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@----end----&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    [<span class="hljs-keyword">self</span>.thread start];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.thread) <span class="hljs-keyword">return</span>;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br><span class="hljs-comment">// 子线程需要执行的任务</span><br>- (<span class="hljs-type">void</span>)test<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br><br>- (<span class="hljs-type">void</span>) stop &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.thread) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 在子线程调用stop（waitUntilDone设置为YES，代表子线程的代码执行完毕后，这个方法才会往下走）</span><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(stopThread) onThread:<span class="hljs-keyword">self</span>.thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br><span class="hljs-comment">// 用于停止子线程的RunLoop</span><br>- (<span class="hljs-type">void</span>)stopThread<br>&#123;<br>    <span class="hljs-comment">// 设置标记为YES</span><br>    <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">YES</span>;<br><br>    <span class="hljs-comment">// 停止RunLoop</span><br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s %@&quot;</span>, __func__, [<span class="hljs-built_in">NSThread</span> currentThread]);<br><br>    <span class="hljs-comment">// 清空线程</span><br>    <span class="hljs-keyword">self</span>.thread = <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br><br>    [<span class="hljs-keyword">self</span> stop];<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>如果想将上面的代码抽取出来应该怎么办呢?</p><h3 id="情景4"><a href="#情景4" class="headerlink" title="情景4"></a>情景4</h3><p>此处封装工具类并不是直接继承自NSThread,而是继承自NSObject[因为并不想让别人直接能调用NSThread里面的方法.]这样符合开闭原则</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (^ZXYPermenantThreadTask)(<span class="hljs-type">void</span>);<br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYPermenantThread</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 在当前子线程执行一个任务</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)executeTask:(ZXYPermenantThreadTask)task;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 结束线程</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)stop;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ZXYPermenantThread.h&quot;</span></span><br><br><span class="hljs-comment">/** ZXYThread **/</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYThread</span> : <span class="hljs-title">NSThread</span></span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ZXYThread</span></span><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">/** ZXYPermenantThread **/</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ZXYPermenantThread</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) ZXYThread *innerThread;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">getter</span>=isStopped) <span class="hljs-type">BOOL</span> stopped;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ZXYPermenantThread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - public methods</span><br>- (<span class="hljs-keyword">instancetype</span>)init&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">NO</span>;<br>        __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>        <span class="hljs-keyword">self</span>.innerThread = [[ZXYThread alloc] initWithBlock:^&#123;<br>            [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc] init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br><br>            <span class="hljs-keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;<br>                [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>            &#125;<br>        &#125;];<br><br>        [<span class="hljs-keyword">self</span>.innerThread start];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)executeTask:(ZXYPermenantThreadTask)task&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.innerThread || !task) <span class="hljs-keyword">return</span>;<br><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(__executeTask:) onThread:<span class="hljs-keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)stop&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.innerThread) <span class="hljs-keyword">return</span>;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(__stop) onThread:<span class="hljs-keyword">self</span>.innerThread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%s&quot;</span>, __func__);<br>    [<span class="hljs-keyword">self</span> stop];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - private methods</span><br>- (<span class="hljs-type">void</span>)__stop&#123;<br>    <span class="hljs-keyword">self</span>.stopped = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>    <span class="hljs-keyword">self</span>.innerThread = <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)__executeTask:(ZXYPermenantThreadTask)task&#123;<br>    task();<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>上面是针对Runloop在实际开发中的第一个使用场景,那么我们是否在一些好的开源项目中使用过呢或者是看到过呢?</p><p><strong>拓展[AFNetworking也使用到了Runloop的线程保活]</strong></p><p>AFNetworking中的ANURLConnectionOperation是基于NSURLConnection构建,本质是希望能在后台线程接收到Delegate回调.为此AFNetworking单独创建了一个线程, 并在这个线程中开启了一个Runloop:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(<span class="hljs-type">id</span>)__unused object &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@&quot;AFNetworking&quot;</span>];<br>        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        [runLoop run];<br>    &#125;<br>&#125;<br><br>+ (<span class="hljs-built_in">NSThread</span> *)networkRequestThread &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSThread</span> *_networkRequestThread = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> oncePredicate;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;<br>        _networkRequestThread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="hljs-literal">nil</span>];<br>        [_networkRequestThread start];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> _networkRequestThread;<br>&#125;<br></code></pre></td></tr></table></figure><p>Runloop启动前必须要至少一个Timer&#x2F;Observer&#x2F;Source,所以AFNetworking在[runLoop run]</p><p>之前创建了NSMachPort添加进去了.通常情况下调用者需要持有这个NSMachPort并在外部线程通过这个port发送消息到loop内</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">- (void)start &#123;<br>    [<span class="hljs-built_in">self</span>.lock lock];<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">self</span> isCancelled]) &#123;<br>        [<span class="hljs-built_in">self</span> performSelector:@selector(cancelConnection) onThread:<span class="hljs-string">[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([<span class="hljs-built_in">self</span> isReady]) &#123;<br>        <span class="hljs-built_in">self</span>.state = AFOperationExecutingState;<br>        [<span class="hljs-built_in">self</span> performSelector:@selector(operationDidStart) onThread:<span class="hljs-string">[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]</span>;<br>    &#125;<br>    [<span class="hljs-built_in">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时,AFNetworking通过调用[NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中</p><h2 id="二、NSTimer问题"><a href="#二、NSTimer问题" class="headerlink" title="二、NSTimer问题"></a>二、NSTimer问题</h2><p>在日常开发中,列表经常会用到NSTimer倒计时问题,或者Interview的时候被面试官问到: NSTimer准时嘛等问题?今天就展开讲述一下原因及方案,最后讲述衍生出来的问题循环引用!争取彻底解决NSTimer带来的疑问?</p><h3 id="问题一、-NSTimer定时器不准"><a href="#问题一、-NSTimer定时器不准" class="headerlink" title="问题一、 NSTimer定时器不准"></a>问题一、 NSTimer定时器不准</h3><p><strong>原因</strong></p><ul><li>NSTimer被添加在mainRunloop中,模式是NSDefaultRunLoopMode, mainRunloop负责所有的主线程事件,例如UI界面的操作,负责的运算使当前Runloop持续的时间超过了定时器的间隔时间,那么下一次定时就被延后,这样就造成timer的阻塞</li><li>模式的切换,当创建的timer被加入到NSDefaultRunLoopMode时,此时如果有滑动UIScrollView的操作时,runloop的mode会切换为TrackingRunloopMode,这时tiemr会停止回调</li></ul><p><strong>解决方案</strong></p><ul><li>Mode方式的改变,兼顾TrackingRunloopMode</li><li>在子线程中创建timer,在主线程进行定时任务的操作或者在子线程中创建timer,在子线程中进行定时任务的操作,需要UI的操作时再切换到主线程进行操作</li><li>GCD操作: dispatch_source_create以及depatch_resume等方法</li></ul><p><strong>方案一</strong></p><p>主线程的Runloop使用到的主要有两种模式, NSDefaultRunLoopMode与TrackingRunloopMode模式</p><p>添加定时器到主线程的CommonMode中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[[NSRunLoop mainRunLoop]</span>addTimer:timer forMode:NSRunLoopCommonModes];<br></code></pre></td></tr></table></figure><p><strong>方案二</strong></p><p>子线程创建timer,主线程执行定时或者子线程创建timer,在子线程执行定时,需要刷新再到主线程</p><p>子线程启动NSTimer</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">__<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        __<span class="hljs-keyword">strong</span> __<span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>        <span class="hljs-keyword">if</span> (strongSelf) &#123;<br>            strongSelf.countTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:strongSelf selector:<span class="hljs-keyword">@selector</span>(countDown) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>            <span class="hljs-built_in">NSRunLoop</span> *runloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>            [runloop addTimer:strongSelf.countTimer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>            [runloop run];<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>主线程更新UI</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">.1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>        [<span class="hljs-keyword">self</span>.jumpBTN setTitle:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;跳过 %lds&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-keyword">self</span>.count] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    &#125;);<br></code></pre></td></tr></table></figure><p><strong>方案三</strong></p><p>使用 GCD 的定时器。GCD 的定时器是直接跟系统内核挂钩的，而且它不依赖于RunLoop，所以它非常的准时。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;myqueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><br>    <span class="hljs-comment">//创建定时器</span><br>    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, queue);<br>    <span class="hljs-comment">//设置时间（start:几s后开始执行；interval:时间间隔）</span><br>    uint64_t start = <span class="hljs-number">2.0</span>;    <span class="hljs-comment">//2s后开始执行</span><br>    uint64_t interval = <span class="hljs-number">1.0</span>; <span class="hljs-comment">//每隔1s执行</span><br>    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class="hljs-built_in">NSEC_PER_SEC</span>), interval * <span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//设置回调</span><br>    dispatch_source_set_event_handler(timer, ^&#123;<br>       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;);<br>    <span class="hljs-comment">//启动定时器</span><br>    dispatch_resume(timer);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br><br>    <span class="hljs-keyword">self</span>.timer = timer;<br></code></pre></td></tr></table></figure><h3 id="问题二、NSTimer循环引用"><a href="#问题二、NSTimer循环引用" class="headerlink" title="问题二、NSTimer循环引用"></a>问题二、NSTimer循环引用</h3><p><strong>常识</strong></p><p>这三个方法直接将timer添加到了当前runloop default mode，而不需要我们自己操作，当然这样的代价是runloop只能是当前runloop，模式是default mode:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti invocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="hljs-type">id</span>)userInfo repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br></code></pre></td></tr></table></figure><p>下面五种创建，不会自动添加到runloop，还需调用addTimer:forMode:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti invocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="hljs-type">id</span>)userInfo repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFireDate:(<span class="hljs-built_in">NSDate</span> *)date interval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)t selector:(SEL)s userInfo:(<span class="hljs-type">id</span>)ui repeats:(<span class="hljs-type">BOOL</span>)rep;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFireDate:(<span class="hljs-built_in">NSDate</span> *)date interval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br></code></pre></td></tr></table></figure><p>在实际项目开发中,使用NSTimer解决定时发送任务的需求,但是还是会产生循环引用,今天讲述本项目中的解决方案.<br>循环引用（Circular Reference）是指两个对象之间相互强引用，两者无法按时释放，从而导致内存泄露.如下:</p><p><img src="https://i.loli.net/2020/12/16/f8IKlHWxghdbcwS.png" alt="2020-12-16-4.14.47.png"></p><p>发现两者相互引用,都不能得以释放,造成了循环引用</p><p><strong>方案一、给self添加中间件</strong></p><p>引入一个对象proxy,proxy弱引用self,然后proxy传入NSTimer. self强引用NSTimer, NSTimer强引用proxy,proxy弱引用着self,这样通过弱引用解决了相互引用,就不会造成环..本项目中使用的方法是引入中间控件HCCProxy1</p><p><img src="https://i.loli.net/2020/12/16/8c2TWPbS35avn6t.png" alt="2020-12-16-4.14.54.png"></p><p>定义一个继承自NSObject的中间代理对象HCCProxy1,ViewController不持有timer,而是持有HCCProxy1实例, 让HCCProxy1实例弱引用ViewController, timer强引用HCCProxy1实例,如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCProxy1</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">id</span> target;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HCCProxy1</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target&#123;<br>    HCCProxy1 *proxy = [[HCCProxy1 alloc] init];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br>- (<span class="hljs-type">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.target;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在项目中使用如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:[HCCProxy1 proxyWithTarget:<span class="hljs-keyword">self</span>] selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拓展:</p><ul><li>(id)forwardingTargetForSelector:(SEL)aSelector是什么？</li></ul><p>  消息转发，简单来说就是如果当前对象没有实现这个方法，系统会到这个方法里来找实现对象。</p><p>本文中由于当前target是HCCProxy1，但是HCCProxy1没有实现方法(当然也不需要它实现)，让系统去找target实例的方法实现，也就是去找ViewController中的方法实现。</p></blockquote><p><strong>方案二、使用继承自NSProxy类HCCProxy的消息转发</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCProxy</span> : <span class="hljs-title">NSProxy</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">id</span> target;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HCCProxy</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)proxyWithTarget:(<span class="hljs-type">id</span>)target&#123;<br>    <span class="hljs-comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span><br>    HCCProxy *proxy = [HCCProxy alloc];<br>    proxy.target = target;<br>    <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.target methodSignatureForSelector:sel];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation&#123;<br>    [invocation invokeWithTarget:<span class="hljs-keyword">self</span>.target];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在项目中使用如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">self</span>.timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span> target:[HCCProxy proxyWithTarget:<span class="hljs-keyword">self</span>] selector:<span class="hljs-keyword">@selector</span>(timerTest) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、监控卡顿"><a href="#三、监控卡顿" class="headerlink" title="三、监控卡顿"></a>三、监控卡顿</h2><p>卡顿问题主要是主线程上无法响应用户交互的问题, 如果一个App时不时给你卡一下,有时还长时间没有响应,你还会继续使用嘛?答案当然是显然的</p><p>对于iOS开发来说,监控卡顿就是要去找到主线程都做了哪些事情,线程的消息事件依赖于NSRunloop的,所以从NSRunloop入手,就可以知道主线程上都调用了哪些方法.可以监听NSRunloop的状态,就能够发现调用方法是否执行时间过长从而判断是否出现了卡顿.所以推荐的监控卡顿方案是: 通过监控Runloop的状态来判断是否出现卡顿</p><p>下面我们讲解一下Runloop的底层常识吧</p><h3 id="1、知识-Runloop原理"><a href="#1、知识-Runloop原理" class="headerlink" title="1、知识-Runloop原理"></a>1、知识-Runloop原理</h3><p>Runloop的目的是,当有事情要去处理时保持线程忙,当没有事件要处理的时候让线程进入休眠.下面通过CFRunloop的源码来分享下Runloop的原理</p><p><strong>第一步:</strong></p><p>通知observers: Runloop要开始进入loop了,紧接着进入loop,代码如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//通知 observers</span><br><span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) <br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopEntry</span>)</span>;<br><span class="hljs-comment">//进入 loop</span><br>result = <span class="hljs-constructor">__CFRunLoopRun(<span class="hljs-params">rl</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">seconds</span>, <span class="hljs-params">returnAfterSourceHandled</span>, <span class="hljs-params">previousMode</span>)</span>;<br></code></pre></td></tr></table></figure><p><strong>第二步</strong></p><p>开启一个 do while 来保活线程。通知 Observers：RunLoop 会触发 Timer 回调、Source0 回调，接着执行加入的 block.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 通知 Observers RunLoop 会触发 Timer 回调</span><br><span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)<br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeTimers</span>)</span>;<br><span class="hljs-comment">// 通知 Observers RunLoop 会触发 Source0 回调</span><br><span class="hljs-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources)<br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeSources</span>)</span>;<br><span class="hljs-comment">// 执行 block</span><br><span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br></code></pre></td></tr></table></figure><p>接下来，触发 Source0 回调，如果有 Source1 是 ready 状态的话，就会跳转到 handle_msg 去处理消息</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">if (MACH_PORT_NULL != <span class="hljs-keyword">dispatchPort </span>) &#123;<br>    <span class="hljs-keyword">Boolean </span>hasMsg = __CFRunLoopServiceMachPort(<span class="hljs-keyword">dispatchPort, </span>&amp;msg)<br>    if (hasMsg) goto handle_msg;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三步</strong></p><p>回调触发后，通知 Observers：RunLoop 的线程将进入休眠（sleep）状态.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Boolean poll = sourceHandledThisLoop<span class="hljs-operator"> || </span>(<span class="hljs-number">0</span>ULL<span class="hljs-operator"> == </span>timeout_context-&gt;termTSR);<br><span class="hljs-keyword">if</span> (!poll<span class="hljs-operator"> &amp;&amp; </span>(currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) &#123;<br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeWaiting</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四步</strong></p><p>进入休眠后，会等待 mach_port 的消息，以再次唤醒。只有在下面四个事件出现时才会被再次唤醒：</p><ul><li>基于 port 的 Source 事件；</li><li>Timer 时间到；*RunLoop 超时；</li><li>被调用者唤醒。</li></ul><p>等待唤醒的代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-title function_">__CFRunLoopServiceMachPort</span>(<span class="hljs-params">waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort</span>) &#123;<br>        <span class="hljs-comment">// 基于 port 的 Source 事件、调用者唤醒</span><br>        <span class="hljs-keyword">if</span> (modeQueuePort != <span class="hljs-variable constant_">MACH_PORT_NULL</span> &amp;&amp; livePort == modeQueuePort) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// Timer 时间到、RunLoop 超时</span><br>        <span class="hljs-keyword">if</span> (currentMode-&gt;_timerFired) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><strong>第五步</strong></p><p>唤醒时通知 Observer：RunLoop 的线程刚刚被唤醒了。代码如下</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if (!poll <span class="hljs-symbol">&amp;&amp;</span> (<span class="hljs-name">currentMode-&gt;_observerMask</span> &amp; kCFRunLoopAfterWaiting))<br>    __CFRunLoopDoObservers(<span class="hljs-name">runloop</span>, currentMode, kCFRunLoopAfterWaiting)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>第六步</strong></p><p>RunLoop 被唤醒后就要开始处理消息了：</p><ul><li>如果是 Timer 时间到的话，就触发 Timer 的回调；</li><li>如果是 dispatch 的话，就执行 block；</li><li>如果是 source1 事件的话，就处理这个事件。</li></ul><p>消息执行完后，就执行加到 loop 里的 block。代码如下：<br>handle_msg:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 如果 Timer 时间到，就触发 Timer 回调</span><br><span class="hljs-keyword">if</span> (msg-is-timer) &#123;<br>    <span class="hljs-constructor">__CFRunLoopDoTimers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">mach_absolute_time</span>()</span>)<br>&#125; <br><span class="hljs-comment">// 如果 dispatch 就执行 block</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg_is_dispatch) &#123;<br>    <span class="hljs-constructor">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class="hljs-params">msg</span>)</span>;<br>&#125; <br><br><span class="hljs-comment">// Source1 事件的话，就处理这个事件</span><br><span class="hljs-keyword">else</span> &#123;<br>    CFRunLoopSourceRef source1 = <span class="hljs-constructor">__CFRunLoopModeFindSourceForMachPort(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">livePort</span>)</span>;<br>    sourceHandledThisLoop = <span class="hljs-constructor">__CFRunLoopDoSource1(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">source1</span>, <span class="hljs-params">msg</span>)</span>;<br>    <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>        mach<span class="hljs-constructor">_msg(<span class="hljs-params">reply</span>, MACH_SEND_MSG, <span class="hljs-params">reply</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第七步</strong></p><p>根据当前 RunLoop 的状态来判断是否需要走下一个 loop。当被外部强制停止或 loop 超时时，就不继续下一个 loop 了，否则继续走下一个 loop 。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (sourceHandledThisLoop<span class="hljs-operator"> &amp;&amp; </span>stopAfterHandle) &#123;<br>     <span class="hljs-comment">// 事件已处理完</span><br>    retVal = kCFRunLoopRunHandledSource;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout) &#123;<br>    <span class="hljs-comment">// 超时</span><br>    retVal = kCFRunLoopRunTimedOut;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopIsStopped(<span class="hljs-params">runloop</span>)</span>) &#123;<br>    <span class="hljs-comment">// 外部调用者强制停止</span><br>    retVal = kCFRunLoopRunStopped;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopModeIsEmpty(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>) &#123;<br>    <span class="hljs-comment">// mode 为空，RunLoop 结束</span><br>    retVal = kCFRunLoopRunFinished;<br>&#125;<br></code></pre></td></tr></table></figure><p>全部的内部代码如下: </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/// 用DefaultMode启动</span><br>void <span class="hljs-constructor">CFRunLoopRun(<span class="hljs-params">void</span>)</span> &#123;<br>    <span class="hljs-constructor">CFRunLoopRunSpecific(CFRunLoopGetCurrent()</span>, kCFRunLoopDefaultMode, <span class="hljs-number">1.0e10</span>, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CFRunLoopRunInMode(CFStringRef <span class="hljs-params">modeName</span>, CFTimeInterval <span class="hljs-params">seconds</span>, Boolean <span class="hljs-params">stopAfterHandle</span>)</span> &#123;<br>    return <span class="hljs-constructor">CFRunLoopRunSpecific(CFRunLoopGetCurrent()</span>, modeName, seconds, returnAfterSourceHandled);<br>&#125;<br><br><span class="hljs-comment">/// RunLoop的实现</span><br><span class="hljs-built_in">int</span> <span class="hljs-constructor">CFRunLoopRunSpecific(<span class="hljs-params">runloop</span>, <span class="hljs-params">modeName</span>, <span class="hljs-params">seconds</span>, <span class="hljs-params">stopAfterHandle</span>)</span> &#123;<br><br>    <span class="hljs-comment">/// 首先根据modeName找到对应mode</span><br>    CFRunLoopModeRef currentMode = <span class="hljs-constructor">__CFRunLoopFindMode(<span class="hljs-params">runloop</span>, <span class="hljs-params">modeName</span>, <span class="hljs-params">false</span>)</span>;<br>    <span class="hljs-comment">/// 如果mode里没有source/timer/observer, 直接返回。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopModeIsEmpty(<span class="hljs-params">currentMode</span>)</span>) return;<br><br>    <span class="hljs-comment">/// 1\. 通知 Observers: RunLoop 即将进入 loop。</span><br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopEntry</span>)</span>;<br><br>    <span class="hljs-comment">/// 内部函数，进入loop</span><br>    <span class="hljs-constructor">__CFRunLoopRun(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">seconds</span>, <span class="hljs-params">returnAfterSourceHandled</span>)</span> &#123;<br><br>        Boolean sourceHandledThisLoop = NO;<br>        <span class="hljs-built_in">int</span> retVal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br><br>            <span class="hljs-comment">/// 2\. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br>            <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeTimers</span>)</span>;<br>            <span class="hljs-comment">/// 3\. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br>            <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeSources</span>)</span>;<br>            <span class="hljs-comment">/// 执行被加入的block</span><br>            <span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br><br>            <span class="hljs-comment">/// 4\. RunLoop 触发 Source0 (非port) 回调。</span><br>            sourceHandledThisLoop = <span class="hljs-constructor">__CFRunLoopDoSources0(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">stopAfterHandle</span>)</span>;<br>            <span class="hljs-comment">/// 执行被加入的block</span><br>            <span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br><br>            <span class="hljs-comment">/// 5\. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br>            <span class="hljs-keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;<br>                Boolean hasMsg = <span class="hljs-constructor">__CFRunLoopServiceMachPort(<span class="hljs-params">dispatchPort</span>, &amp;<span class="hljs-params">msg</span>)</span><br>                <span class="hljs-keyword">if</span> (hasMsg) goto handle_msg;<br>            &#125;<br><br>            <span class="hljs-comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br>            <span class="hljs-keyword">if</span> (!sourceHandledThisLoop) &#123;<br>                <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopBeforeWaiting</span>)</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/// 7\. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br>            <span class="hljs-comment">/// • 一个基于 port 的Source 的事件。</span><br>            <span class="hljs-comment">/// • 一个 Timer 到时间了</span><br>            <span class="hljs-comment">/// • RunLoop 自身的超时时间到了</span><br>            <span class="hljs-comment">/// • 被其他什么调用者手动唤醒</span><br>            <span class="hljs-constructor">__CFRunLoopServiceMachPort(<span class="hljs-params">waitSet</span>, &amp;<span class="hljs-params">msg</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">msg_buffer</span>)</span>, &amp;livePort) &#123;<br>                mach<span class="hljs-constructor">_msg(<span class="hljs-params">msg</span>, MACH_RCV_MSG, <span class="hljs-params">port</span>)</span>; <span class="hljs-comment">// thread wait for receive msg</span><br>            &#125;<br><br>            <span class="hljs-comment">/// 8\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br>            <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopAfterWaiting</span>)</span>;<br><br>            <span class="hljs-comment">/// 收到消息，处理消息。</span><br>            handle_msg:<br><br>            <span class="hljs-comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br>            <span class="hljs-keyword">if</span> (msg_is_timer) &#123;<br>                <span class="hljs-constructor">__CFRunLoopDoTimers(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">mach_absolute_time</span>()</span>)<br>            &#125;<br><br>            <span class="hljs-comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg_is_dispatch) &#123;<br>                <span class="hljs-constructor">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class="hljs-params">msg</span>)</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                CFRunLoopSourceRef source1 = <span class="hljs-constructor">__CFRunLoopModeFindSourceForMachPort(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">livePort</span>)</span>;<br>                sourceHandledThisLoop = <span class="hljs-constructor">__CFRunLoopDoSource1(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">source1</span>, <span class="hljs-params">msg</span>)</span>;<br>                <span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>                    mach<span class="hljs-constructor">_msg(<span class="hljs-params">reply</span>, MACH_SEND_MSG, <span class="hljs-params">reply</span>)</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">/// 执行加入到Loop的block</span><br>            <span class="hljs-constructor">__CFRunLoopDoBlocks(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>;<br><br>            <span class="hljs-keyword">if</span> (sourceHandledThisLoop<span class="hljs-operator"> &amp;&amp; </span>stopAfterHandle) &#123;<br>                <span class="hljs-comment">/// 进入loop时参数说处理完事件就返回。</span><br>                retVal = kCFRunLoopRunHandledSource;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout) &#123;<br>                <span class="hljs-comment">/// 超出传入参数标记的超时时间了</span><br>                retVal = kCFRunLoopRunTimedOut;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopIsStopped(<span class="hljs-params">runloop</span>)</span>) &#123;<br>                <span class="hljs-comment">/// 被外部调用者强制停止了</span><br>                retVal = kCFRunLoopRunStopped;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-constructor">__CFRunLoopModeIsEmpty(<span class="hljs-params">runloop</span>, <span class="hljs-params">currentMode</span>)</span>) &#123;<br>                <span class="hljs-comment">/// source/timer/observer一个都没有了</span><br>                retVal = kCFRunLoopRunFinished;<br>            &#125;<br><br>            <span class="hljs-comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br>        &#125; <span class="hljs-keyword">while</span> (retVal<span class="hljs-operator"> == </span><span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/// 10\. 通知 Observers: RunLoop 即将退出。</span><br>    <span class="hljs-constructor">__CFRunLoopDoObservers(<span class="hljs-params">rl</span>, <span class="hljs-params">currentMode</span>, <span class="hljs-params">kCFRunLoopExit</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。<br>整个Runloop过程,可以总结如下一张图片</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/3QD99b9DjVF5ChLqicEMicHL29cjNDL6wJ7qRwaHlZSP7rVd56GTpZD74jXr4mhalibWQgDzwO1OojMYzWmYTGL1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="2、如何监测卡顿"><a href="#2、如何监测卡顿" class="headerlink" title="2、如何监测卡顿"></a>2、如何监测卡顿</h3><p>要想监听 RunLoop，你就首先需要创建一个 CFRunLoopObserverContext 观察者，代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<span class="hljs-number">0</span>,(__bridge <span class="hljs-type">void</span>*)<span class="hljs-keyword">self</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>&#125;;<br>runLoopObserver = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,kCFRunLoopAllActivities,<span class="hljs-literal">YES</span>,<span class="hljs-number">0</span>,&amp;runLoopObserverCallBack,&amp;context);<br></code></pre></td></tr></table></figure><p>将创建好的观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。</p><p>一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以 dump 出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间过长。</p><p>开启一个子线程监控的代码如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建子线程监控<br>dispatch_async(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-regexp">//</span>子线程开启一个持续的 loop 用来进行监控<br>    <span class="hljs-keyword">while</span> (YES) &#123;<br>        long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">3</span> * NSEC_PER_SEC));<br>        <span class="hljs-keyword">if</span> (semaphoreWait != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!runLoopObserver) &#123;<br>                timeoutCount = <span class="hljs-number">0</span>;<br>                dispatchSemaphore = <span class="hljs-number">0</span>;<br>                runLoopActivity = <span class="hljs-number">0</span>;<br>                return;<br>            &#125;<br>            <span class="hljs-regexp">//</span>BeforeSources 和 AfterWaiting 这两个状态能够检测到是否卡顿<br>            <span class="hljs-keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;<br>                <span class="hljs-regexp">//</span>将堆栈信息上报服务器的代码放到这里<br>            &#125; <span class="hljs-regexp">//</span>end activity<br>        &#125;<span class="hljs-regexp">//</span> end semaphore wait<br>        timeoutCount = <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-regexp">//</span> end <span class="hljs-keyword">while</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>下面是封装的一个工具类HCCMonitor,用于卡顿监测</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCMonitor</span> : <span class="hljs-title">NSObject</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance;<br>- (<span class="hljs-type">void</span>)beginMonitor; <span class="hljs-comment">//开始监视卡顿</span><br>- (<span class="hljs-type">void</span>)endMonitor;   <span class="hljs-comment">//停止监视卡顿</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HCCMonitor.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HCCCallStack.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HCCCPUMonitor.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HCCMonitor</span>() </span>&#123;<br>    <span class="hljs-type">int</span> timeoutCount;<br>    <span class="hljs-built_in">CFRunLoopObserverRef</span> runLoopObserver;<br>    <span class="hljs-keyword">@public</span><br>    dispatch_semaphore_t dispatchSemaphore;<br>    <span class="hljs-built_in">CFRunLoopActivity</span> runLoopActivity;<br>&#125;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSTimer</span> *cpuMonitorTimer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HCCMonitor</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Interface</span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">id</span> instance = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> dispatchOnce;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;dispatchOnce, ^&#123;<br>        instance = [[<span class="hljs-keyword">self</span> alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)beginMonitor &#123;<br>    <span class="hljs-comment">//监测 CPU 消耗</span><br>    <span class="hljs-keyword">self</span>.cpuMonitorTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">3</span><br>                                                             target:<span class="hljs-keyword">self</span><br>                                                           selector:<span class="hljs-keyword">@selector</span>(updateCPUInfo)<br>                                                           userInfo:<span class="hljs-literal">nil</span><br>                                                            repeats:<span class="hljs-literal">YES</span>];<br>    <span class="hljs-comment">//监测卡顿</span><br>    <span class="hljs-keyword">if</span> (runLoopObserver) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dispatchSemaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>); <span class="hljs-comment">//Dispatch Semaphore保证同步</span><br>    <span class="hljs-comment">//创建一个观察者</span><br>    <span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<span class="hljs-number">0</span>,(__bridge <span class="hljs-type">void</span>*)<span class="hljs-keyword">self</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>&#125;;<br>    runLoopObserver = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,<br>                                              kCFRunLoopAllActivities,<br>                                              <span class="hljs-literal">YES</span>,<br>                                              <span class="hljs-number">0</span>,<br>                                              &amp;runLoopObserverCallBack,<br>                                              &amp;context);<br>    <span class="hljs-comment">//将观察者添加到主线程runloop的common模式下的观察中</span><br>    <span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);<br><br>    <span class="hljs-comment">//创建子线程监控</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-comment">//子线程开启一个持续的loop用来进行监控</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">YES</span>) &#123;<br>            <span class="hljs-type">long</span> semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">20</span>*<span class="hljs-built_in">NSEC_PER_MSEC</span>));<br>            <span class="hljs-keyword">if</span> (semaphoreWait != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!runLoopObserver) &#123;<br>                    timeoutCount = <span class="hljs-number">0</span>;<br>                    dispatchSemaphore = <span class="hljs-number">0</span>;<br>                    runLoopActivity = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">//两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿</span><br>                <span class="hljs-keyword">if</span> (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) &#123;<br>                    <span class="hljs-comment">// 将堆栈信息上报服务器的代码放到这里</span><br>                    <span class="hljs-comment">//出现三次出结果</span><br><span class="hljs-comment">//                    if (++timeoutCount &lt; 3) &#123;</span><br><span class="hljs-comment">//                        continue;</span><br><span class="hljs-comment">//                    &#125;</span><br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;monitor trigger&quot;</span>);<br>                    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="hljs-number">0</span>), ^&#123;<br><span class="hljs-comment">//                        [HCCCallStack callStackWithType:HCCCallStackTypeAll];</span><br>                    &#125;);<br>                &#125; <span class="hljs-comment">//end activity</span><br>            &#125;<span class="hljs-comment">// end semaphore wait</span><br>            timeoutCount = <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-comment">// end while</span><br>    &#125;);<br><br>&#125;<br><br>- (<span class="hljs-type">void</span>)endMonitor &#123;<br>    [<span class="hljs-keyword">self</span>.cpuMonitorTimer invalidate];<br>    <span class="hljs-keyword">if</span> (!runLoopObserver) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">CFRunLoopRemoveObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), runLoopObserver, kCFRunLoopCommonModes);<br>    <span class="hljs-built_in">CFRelease</span>(runLoopObserver);<br>    runLoopObserver = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Private</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> runLoopObserverCallBack(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-type">void</span> *info)&#123;<br>    HCCMonitor *lagMonitor = (__bridge HCCMonitor*)info;<br>    lagMonitor-&gt;runLoopActivity = activity;<br><br>    dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore;<br>    dispatch_semaphore_signal(semaphore);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)updateCPUInfo &#123;<br>    thread_act_array_t threads;<br>    mach_msg_type_number_t threadCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> task_t thisTask = mach_task_self();<br>    kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount);<br>    <span class="hljs-keyword">if</span> (kr != KERN_SUCCESS) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCount; i++) &#123;<br>        thread_info_data_t threadInfo;<br>        thread_basic_info_t threadBaseInfo;<br>        mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;<br>        <span class="hljs-keyword">if</span> (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) &#123;<br>            threadBaseInfo = (thread_basic_info_t)threadInfo;<br>            <span class="hljs-keyword">if</span> (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;<br>                integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">if</span> (cpuUsage &gt; <span class="hljs-number">70</span>) &#123;<br>                    <span class="hljs-comment">//cup 消耗大于 70 时打印和记录堆栈</span><br>                    <span class="hljs-built_in">NSString</span> *reStr = HCCStackOfThread(threads[i]);<br>                    <span class="hljs-comment">//记录数据库中</span><br><span class="hljs-comment">//                    [[[HCCDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(id x) &#123;&#125;];</span><br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;CPU useage overload thread stack：\n%@&quot;</span>,reStr);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h2 id="四、性能优化"><a href="#四、性能优化" class="headerlink" title="四、性能优化"></a>四、性能优化</h2><p>当tableview的cell有多个ImageView，并且是大图的话，会不会在滑动的时候导致卡顿，答案是显然意见的。</p><p>通过上面讲述Runloop的原理，我们可以使用Runloop每次循环添加一张图片。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 为什么要优化：</span><br><span class="hljs-comment">    Runloop会在一次循环中绘制屏幕上所有的点，如果加载的图片过大，过多，就会造成需要绘制很多的</span><br><span class="hljs-comment">的点，导致一次循环的时间过长，从而导致UI卡顿。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="监听Runloop"><a href="#监听Runloop" class="headerlink" title="监听Runloop"></a>监听Runloop</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//添加runloop监听者</span><br>- (<span class="hljs-type">void</span>)addRunloopObserver&#123;<br><br>    <span class="hljs-comment">//    获取 当前的Runloop ref - 指针</span><br>    <span class="hljs-built_in">CFRunLoopRef</span> current =  <span class="hljs-built_in">CFRunLoopGetCurrent</span>();<br><br>    <span class="hljs-comment">//定义一个RunloopObserver</span><br>    <span class="hljs-built_in">CFRunLoopObserverRef</span> defaultModeObserver;<br><br>    <span class="hljs-comment">//上下文</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     typedef struct &#123;</span><br><span class="hljs-comment">        CFIndex version; //版本号 long</span><br><span class="hljs-comment">        void * info;    //这里我们要填写对象（self或者传进来的对象）</span><br><span class="hljs-comment">        const void *(*retain)(const void *info);        //填写&amp;CFRetain</span><br><span class="hljs-comment">        void (*release)(const void *info);           //填写&amp;CGFRelease</span><br><span class="hljs-comment">        CFStringRef (*copyDescription)(const void *info); //NULL</span><br><span class="hljs-comment">     &#125; CFRunLoopObserverContext;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<br>        <span class="hljs-number">0</span>,<br>        (__bridge <span class="hljs-type">void</span> *)(<span class="hljs-keyword">self</span>),<br>        &amp;<span class="hljs-built_in">CFRetain</span>,<br>        &amp;<span class="hljs-built_in">CFRelease</span>,<br>        <span class="hljs-literal">NULL</span><br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     1 NULL空指针 nil空对象 这里填写NULL</span><br><span class="hljs-comment">     2 模式</span><br><span class="hljs-comment">        kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="hljs-comment">        kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="hljs-comment">        kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="hljs-comment">        kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="hljs-comment">        kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="hljs-comment">        kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="hljs-comment">        kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="hljs-comment">     3 是否重复 - YES</span><br><span class="hljs-comment">     4 nil 或者 NSIntegerMax - 999</span><br><span class="hljs-comment">     5 回调</span><br><span class="hljs-comment">     6 上下文</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//    创建观察者</span><br>    defaultModeObserver = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(<span class="hljs-literal">NULL</span>,<br>                                                  kCFRunLoopBeforeWaiting, <span class="hljs-literal">YES</span>,<br>                                                  <span class="hljs-built_in">NSIntegerMax</span> - <span class="hljs-number">999</span>,<br>                                                  &amp;Callback,<br>                                                  &amp;context);<br><br>    <span class="hljs-comment">//添加当前runloop的观察着</span><br>    <span class="hljs-built_in">CFRunLoopAddObserver</span>(current, defaultModeObserver, kCFRunLoopDefaultMode);<br><br>    <span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">CFRelease</span>(defaultModeObserver);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> Callback(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity, <span class="hljs-type">void</span> *info)&#123;<br><br>    <span class="hljs-comment">//通过info桥接为当前的对象</span><br>    ZXYRunloop * runloop = (__bridge ZXYunloop *)info;<br><br>    <span class="hljs-comment">//如果没有任务，就直接返回</span><br>    <span class="hljs-keyword">if</span> (runloop.tasks.count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">BOOL</span> result = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">while</span> (result == <span class="hljs-literal">NO</span> &amp;&amp; runloop.tasks.count) &#123;<br><br>        <span class="hljs-comment">//取出任务</span><br>        RunloopBlock unit = runloop.tasks.firstObject;<br><br>        <span class="hljs-comment">//执行任务</span><br>        result = unit();<br><br>        <span class="hljs-comment">//删除任务</span><br>        [runloop.tasks removeObjectAtIndex:<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的两个方法我们可以做到监听Runloop循环，以及每次循环需要处理的事情，这个时候我们只需要对外提供一个添加任务的方法，用数组保存起来。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//add task 添加任务</span><br>- (<span class="hljs-type">void</span>)addTask:(RunloopBlock)unit withId:(<span class="hljs-type">id</span>)key&#123;<br>    <span class="hljs-comment">//添加任务到数组</span><br>    [<span class="hljs-keyword">self</span>.tasks addObject:unit];<br>    [<span class="hljs-keyword">self</span>.taskKeys addObject:key];<br><br>    <span class="hljs-comment">//为了保证加载到图片最大数是20所以要删除</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.tasks.count &gt; <span class="hljs-keyword">self</span>.maxQueue) &#123;<br>        [<span class="hljs-keyword">self</span>.tasks removeObjectAtIndex:<span class="hljs-number">0</span>];<br>        [<span class="hljs-keyword">self</span>.taskKeys removeObjectAtIndex:<span class="hljs-number">0</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><p>在ZXYRunloop初始化方法设置初始化对象和基本信息</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (instancetype)<span class="hljs-keyword">init</span>&#123;<br>    <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> [<span class="hljs-keyword">super</span> <span class="hljs-keyword">init</span>];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">//初始化对象／基本信息</span><br>        <span class="hljs-keyword">self</span>.maxQueue <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">self</span>.tasks <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableArray</span> array];<br>        <span class="hljs-keyword">self</span>.taskKeys <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableArray</span> array];<br>        <span class="hljs-keyword">self</span>.timer <span class="hljs-operator">=</span> [<span class="hljs-type">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">0.001</span> repeats:<span class="hljs-type">YES</span> block:<span class="hljs-operator">^</span>(<span class="hljs-type">NSTimer</span> <span class="hljs-operator">*</span> _Nonnull timer) &#123; &#125;];<br>        <span class="hljs-comment">//添加Runloop观察者</span><br>        [<span class="hljs-keyword">self</span> addRunloopObserver];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在TableViewCell中使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[[ZXYRunloop shareInstance]</span> addTask:^BOOL&#123;<br>        <span class="hljs-selector-attr">[ViewController addCenterImg:cell]</span>;<br>        return YES;<br>    &#125; withId:indexPath];<br></code></pre></td></tr></table></figure><p>总结一下思想</p><ul><li>加载图片的代码保存起来，不要直接执行，用一个数组保存 block </li><li>监听我们的Runloop循环 CFRunloop CFRunloopObserver </li><li>每次Runloop循环就让它从数组里面去一个加载图片等任务出来执行</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>事件传递与响应者链</title>
    <link href="/2019/01/30/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    <url>/2019/01/30/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p> UIKit 主要是通过响应者（UIResponder）来响应用户事件，那么系统是如何来处理的呢？</p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>首先我们看下目前系统的定义的 <code>UIEventType</code>，我们主要通过 UIEventTypeTouches 来了解下事件响应：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteger</span>, <span class="hljs-built_in">UIEventType</span>) &#123;<br>    <span class="hljs-built_in">UIEventTypeTouches</span>, <span class="hljs-comment">// 触摸事件</span><br>    <span class="hljs-built_in">UIEventTypeMotion</span>, <span class="hljs-comment">// 晃动事件</span><br>    <span class="hljs-built_in">UIEventTypeRemoteControl</span>, <span class="hljs-comment">// 远程控制事件，主要是外部辅助设备或者耳机的远程命令，例如控制音乐声音的大小，或者下一首歌。</span><br>    <span class="hljs-built_in">UIEventTypePresses</span> API_AVAILABLE(iOS(<span class="hljs-number">9.0</span>)), <span class="hljs-comment">// 物理按键事件</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h2><p>我们为了搞清楚事件响应机制，我们用触摸事件来进行举例。当触摸事件发生的时候，一直到找到对应这个事件的响应，我把这个过程分为两步：</p><p>1、传递链：由系统向离用户最近的view传递。<code>UIKit</code> –&gt; <code>active app&#39;s event queue</code> –&gt; <code>window</code> –&gt; <code>root view</code> –&gt; …… –&gt; <code>lowest view</code></p><p>2、响应链：由离用户最近的<code>view</code>向系统传递。<code>initial view</code> –&gt; <code>super view</code> –&gt; ….. –&gt; <code>view controller</code> –&gt; <code>window</code> –&gt; <code>Application</code> –&gt; <code>AppDelegate</code></p><ul><li>通过事件传递机制找到 First Responder</li><li>First Responder 通过事件响应链找到 Touch Event</li></ul><h2 id="事件传递机制"><a href="#事件传递机制" class="headerlink" title="事件传递机制"></a>事件传递机制</h2><blockquote><p>UIKit uses view-based hit-testing to determine where touch events occur. Specifically, UIKit compares the touch location to the bounds of view objects in the view hierarchy. The <code>hitTest:withEvent:</code> method of UIView traverses the view hierarchy, looking for the deepest subview that contains the specified touch, which becomes the first responder for the touch event.</p></blockquote><p>当点击屏幕时，系统会产生一个触摸事件 UIEvent，系统会把这个 UIEvent 放到 Application 的事件队列中，Application 会把事件分发下去。首先响应的是 UIWindow，他会调用 <code>hitTest:withEvent:</code> ，找到能够响应事件的 UIView。UIView 会通过 <code>hitTest:withEvent:</code> 根据触摸事件的 location 在视图的层级结构中进行遍历，找到包含该触摸的层级最深的子视图，定义这个视图作为响应事件（touch event）的 first responder。</p><p>我们通过下面的例子，来详细说明两个原理：</p><ul><li><p>如何进行遍历？</p></li><li><p>hitTest 怎么工作的？</p></li></ul><span id="more"></span><p>  <img src="https://i.loli.net/2021/01/04/WeafExlQ4bGXZtr.png" alt="2021-01-04-4.38.32.png"></p><p>  遍历查找最佳视图流程图</p><p>如上图例子所示，当我们点击 View B.1 的时候，如何进行遍历来确认该 View 是 first responder？</p><p><img src="https://i.loli.net/2020/12/30/y7SxN2PdjnOhqaW.png" alt="2020-12-30-3.47.58.png"></p><p>系统会根据 view 添加的顺序，确定其在 subview 数组中的顺序。我们将视图的树形结构画出来，针对这个树，是按照逆先序深度优先遍历。根据图上绿色箭头所示的顺序，查找到 B.1 为响应最合适的 view。顺序如下：</p><p>注意：先添加的View A, 在添加的View B，View C，mianView查找子视图先遍历后添加ViewC</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">UIW<span class="hljs-function"><span class="hljs-title">indow</span> -&gt;</span> M<span class="hljs-function"><span class="hljs-title">ainView</span> -&gt;</span> V<span class="hljs-function"><span class="hljs-title">iew</span> C -&gt;</span> V<span class="hljs-function"><span class="hljs-title">iew</span> B -&gt;</span> V<span class="hljs-function"><span class="hljs-title">iew</span> B.2 -&gt;</span> View B.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="hitTest-withEvent-遍历查找最佳视图"><a href="#hitTest-withEvent-遍历查找最佳视图" class="headerlink" title="hitTest:withEvent:  遍历查找最佳视图"></a>hitTest:withEvent:  遍历查找最佳视图</h3><ul><li>根据如下三个属性判断 view &amp; subview 是否接受事件，若下面三个属性设置如下，则方法会自动忽略该 view &amp; subview<ul><li>isUserInteractionEnabled &#x3D; false</li><li>isHidden &#x3D; true</li><li>alpha &lt;&#x3D; 0.01</li></ul></li><li>根据 <code>pointInside:withEvent:</code> 判断点是否在当前 view 内</li><li>如果在判断是否有 subview，没有 subview 返回自身；有子视图继续遍历</li></ul><p>根据上面的原则，我们可以大概推断出 <code>hitTest:withEvent:</code> 的实现原理代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">UIView</span> *)hitTest:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    <span class="hljs-comment">// 如果控件不允许与用用户交互,那么返回nil</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.userInteractionEnabled || [<span class="hljs-keyword">self</span> isHidden] || <span class="hljs-keyword">self</span>.alpha &lt;= <span class="hljs-number">0.01</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//判断当前视图是否在点击范围内</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> pointInside:point withEvent:event]) &#123;<br>        <span class="hljs-comment">//遍历当前对象的子视图(倒序)</span><br>        __block <span class="hljs-built_in">UIView</span> *hit = <span class="hljs-literal">nil</span>;<br>        [<span class="hljs-keyword">self</span>.subviews enumerateObjectsWithOptions:<span class="hljs-built_in">NSEnumerationReverse</span> usingBlock:^(__kindof <span class="hljs-built_in">UIView</span> * _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-type">BOOL</span> * _Nonnull stop) &#123;<br>            <span class="hljs-comment">//坐标转换，把当前坐标系上的点转换成子控件坐标系上的点</span><br>            <span class="hljs-built_in">CGPoint</span> convertPoint = [<span class="hljs-keyword">self</span> convertPoint:point toView:obj];<br>            <span class="hljs-comment">//调用子视图的hitTest方法，判断自己的子控件是不是最适合的View</span><br>            hit = [obj hitTest:convertPoint withEvent:event];<br>            <span class="hljs-comment">//如果找到了就停止遍历</span><br>            <span class="hljs-keyword">if</span> (hit) *stop = <span class="hljs-literal">YES</span>;<br>        &#125;];<br><br>        <span class="hljs-comment">//返回当前的视图对象</span><br>        <span class="hljs-keyword">return</span> hit?hit:<span class="hljs-keyword">self</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 该方法判断触摸点是否在控件身上，是则返回YES，否则返回NO，point参数必须是方法调用者的坐标系</span><br>- (<span class="hljs-type">BOOL</span>)pointInside:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;   <br>    <span class="hljs-built_in">CGFloat</span> x1 = point.x;<br>    <span class="hljs-built_in">CGFloat</span> y1 = point.y;<br>    <br>    <span class="hljs-built_in">CGFloat</span> x2 = <span class="hljs-keyword">self</span>.frame.size.width / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">CGFloat</span> y2 = <span class="hljs-keyword">self</span>.frame.size.height / <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">//判断是否在圆形区域内</span><br>    <span class="hljs-type">double</span> dis = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));<br>    <span class="hljs-keyword">if</span> (dis &lt;= <span class="hljs-keyword">self</span>.frame.size.width / <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h2><p><img src="https://i.loli.net/2020/12/30/NpR7bYIxrDcyaTe.png" alt="2020-12-30-4.15.48.png"></p><p>我们发现事件响应链和事件传递完全是相反的过程。最有机会处理事件的就是通过事件传递找到的 first responder，如果没有进行处理，就会沿着事件响应链传递给下一个响应者 nextResponder，一直追溯到最上层 UIApplication。若都没有进行处理，就丢弃事件。</p><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event;<br>- (<span class="hljs-type">void</span>)touchesMoved:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event;<br>- (<span class="hljs-type">void</span>)touchesEnded:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event;<br>- (<span class="hljs-type">void</span>)touchesCancelled:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event;<br></code></pre></td></tr></table></figure><p>对于触摸事件，系统提供了上面四种方法来处理。如果重写了上述方法，那么事件就会在此中断，并且不再沿着事件响应链进行传递；如果需要继续进行传递，则需要调用 <code>super</code> 方法。</p><h3 id="决定第一响应者"><a href="#决定第一响应者" class="headerlink" title="决定第一响应者"></a>决定第一响应者</h3><p>我们上面通过事件传递机制寻找 first responder 主要是针对 UIEventTypeTouches 事件，但是 UIKit 决定 first responder 是根据事件类型来的。</p><table><thead><tr><th align="left">Event type</th><th align="left">First responder</th></tr></thead><tbody><tr><td align="left">Touch events</td><td align="left">触摸发生的 view</td></tr><tr><td align="left">Press events</td><td align="left">聚焦的对象</td></tr><tr><td align="left">Shake-motion events</td><td align="left">用户（UIKit）制定的对象</td></tr><tr><td align="left">Remote-control events</td><td align="left">用户（UIKit）制定的对象</td></tr><tr><td align="left">Editing menu messages</td><td align="left">用户（UIKit）制定的对象</td></tr></tbody></table><blockquote><p>与加速计、陀螺仪、磁力仪相关的运动事件，不遵循事件响应链。Core Motion 直接将这些事件传递给指定的对象。</p></blockquote><h3 id="改变事件传递链"><a href="#改变事件传递链" class="headerlink" title="改变事件传递链"></a>改变事件传递链</h3><p>例：两层重叠视图，让事件由下层视图处理，重写上层视图hitTest方法，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;<br>  if (判断上层视图是否需要处理该事件) &#123;<br>    return nil;//将调用下层试图的hitTest:查找最佳试图<br>  &#125;<br>  [super hitTest:point withEvent:event];<br>&#125;<br><br>判断上层视图是否处理该事件：循环遍历上层可以处理事件的子视图，是否在该point上，<br><br>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event <br></code></pre></td></tr></table></figure><h3 id="改变响应者链"><a href="#改变响应者链" class="headerlink" title="改变响应者链"></a>改变响应者链</h3><p>在 UIResponse 类中有一个 <code>nextResponder</code> 属性，可以通过重写该属性来改变事件响应链。很多的系统类就通过这个属性改变了 next responder：</p><ul><li><strong>UIView</strong>，如果 view 的 root view 是 UIViewController，则 next responder 是 UIViewController；否则，next responder 是 super view；</li><li>UIViewController<ul><li>如果 view controller 是 UIWindow 的 root view ，那么 next responder 是 UIWindow；</li><li>如果 view controller 是被另一个 view controller presented 出来，那么 next responder 是 presenting view controller；</li></ul></li><li><strong>UIWindow</strong>，next responder 是 UIApplication；</li><li><strong>UIApplication</strong>, next responder 是 app delegate；</li></ul><h2 id="事件是怎么被接收的？"><a href="#事件是怎么被接收的？" class="headerlink" title="事件是怎么被接收的？"></a>事件是怎么被接收的？</h2><p>简单描述 Runloop 机制：</p><blockquote><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin&#x2F;Move&#x2F;End&#x2F;Cancel 事件都是在这个回调中完成的。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>runtime小结</title>
    <link href="/2019/01/22/runtime-1/"/>
    <url>/2019/01/22/runtime-1/</url>
    
    <content type="html"><![CDATA[<ol><li>下面代码执行 ⌘+R 后会 Compile Error 、Runtime Crash 或者 NSLog 输出？</li><li>如果 [(__bridge id)obj speak]; 能调用成功，输出什么？</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Speaker</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-type">void</span>)speak;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Speaker</span></span><br>- (<span class="hljs-type">void</span>)speak &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Speaker&#x27;s name: %@&quot;</span>, <span class="hljs-keyword">self</span>.name);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-type">id</span> cls = [Speaker <span class="hljs-keyword">class</span>]; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">void</span> *obj = &amp;cls; <span class="hljs-comment">// 2</span><br>    [(__bridge <span class="hljs-type">id</span>)obj speak]; <span class="hljs-comment">// 3</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>当然，本着 反正不是真面试 的态度，直接跑一下不就行了，嘿嘿。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>输出<br>Speake<span class="hljs-string">r&#x27;s name: &lt;ViewController: 0x7fcc84e09e90&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到运行时成功的，但输出的结果让我有点懵逼？？？原因有2点：</p><ol><li>为什么 [(__bridge id)obj speak] 不会崩溃，而且感觉看着像给 类对象发消息 ，这应该解析不了啊？</li><li>为什么 self.name 是ViewController对象？</li></ol><p>下面我们仔细分析一下。</p><span id="more"></span><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-为什么可以发消息？"><a href="#2-1-为什么可以发消息？" class="headerlink" title="2.1 为什么可以发消息？"></a>2.1 为什么可以发消息？</h3><ul><li>第一步</li></ul><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">id</span> cls <span class="hljs-operator">=</span> [Speaker <span class="hljs-keyword">class</span>]; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>这一步获取到了Speaker的类对象，id表示将其转换为一个对象指针，实际类型为<code>struct objc_object *</code>。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">struct</span> <span class="hljs-keyword">objc_object</span> &#123;<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;<br>&#125;;<br><br>typedef <span class="hljs-keyword">struct</span> objc_object <span class="hljs-operator">*</span><span class="hljs-built_in">id</span>;<br></code></pre></td></tr></table></figure><p>而 [Speaker class] 的返回类型为Class，其实类型为<code>struct objc_class *</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_class</span> *Class;<br></code></pre></td></tr></table></figure><p>虽然，我们写的类型为<code>struct objc_object *</code>，但其本质还是 <code>struct objc_class *</code>。</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">id</span> cls <span class="hljs-operator">=</span> [Speaker <span class="hljs-keyword">class</span>];<br><span class="hljs-keyword">if</span> (object_isClass(cls)) &#123;<br>    NSLog(<span class="hljs-string">@&quot;object_isClass&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 输出</span><br>object_isClass<br>复制代码也就是说这一步拿到的 本质还是类对象。<br><span class="hljs-built_in">id</span> cls <span class="hljs-operator">=</span> [Speaker <span class="hljs-keyword">class</span>];<br>[cls speak];<br><span class="hljs-comment">// 直接发送消息，是会崩溃的</span><br><span class="hljs-operator">+</span>[Speaker speak]<span class="hljs-operator">:</span> unrecognized selector sent <span class="hljs-keyword">to</span> <span class="hljs-keyword">class</span> 0x106824f08<br></code></pre></td></tr></table></figure><ul><li>第二步、第三步</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">void *obj = <span class="hljs-meta">&amp;cls; <span class="hljs-comment">// 2</span></span><br></code></pre></td></tr></table></figure><p><strong>这一步才是关键。</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct objc_object &#123;<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以看到struct objc_object这个结构体的首字段是 isa 指向一个Class。</p><p>也就是说，我们如果有一个指向Class的地址的指针，相当于这个对象就已经可以使用了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">![<span class="hljs-number">2020</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span><span class="hljs-number">-8.58</span><span class="hljs-number">.27</span>.png](https:<span class="hljs-comment">//i.loli.net/2020/12/30/vfXLpJNrD4Och7s.png)@interface Speaker : NSObject</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-type">void</span>)speak;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Speaker</span></span><br>- (<span class="hljs-type">void</span>)speak &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;speak&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-keyword">struct</span> my_object &#123;<br>    Class isa;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> my_object *getObject() &#123;<br>    <span class="hljs-comment">// id cls = [Speaker class]; id类型的实质是一个指针，所以cls是一个指针</span><br>    <span class="hljs-comment">// void *obj = &amp;cls; 这里取cls的地址，相当于[Speaker class]现在被一个 指针 的 指针 所指向</span><br>    <span class="hljs-comment">// 下面 struct my_object * 是一个指针，isa 是一个也是一个指针</span><br>    <span class="hljs-comment">// 所以也等效于[Speaker class]现在被一个 指针 的 指针 所指向</span><br>    <span class="hljs-keyword">struct</span> my_object *obj = (<span class="hljs-keyword">struct</span> my_object *)malloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> my_object));<br>    obj-&gt;isa = [Speaker <span class="hljs-keyword">class</span>];<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">struct</span> my_object *obj = getObject();<br>    <span class="hljs-type">id</span> obj1 = (__bridge <span class="hljs-type">id</span>)obj;<br>    [obj1 speak]; <span class="hljs-comment">// 3</span><br>    free(obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/12/30/vfXLpJNrD4Och7s.png" alt="2020-12-30-8.58.27.png"></p><p>我们可以看到，通过id类型转换obj1也被Xcode识别为了Speaker实例对象，而且我们调用 [obj1 speak] 也顺利输出了。</p><p>相当于消息 objc_msgSend 执行过程中通过 obj1 顺利访问到了 isa 对象，在Speaker类中找到了speak实例方法，并成功调用。</p><h3 id="2-2-为什么输出的name是ViewController实例对象？"><a href="#2-2-为什么输出的name是ViewController实例对象？" class="headerlink" title="2.2 为什么输出的name是ViewController实例对象？"></a>2.2 为什么输出的name是ViewController实例对象？</h3><h4 id="2-2-1-等价代码"><a href="#2-2-1-等价代码" class="headerlink" title="2.2.1 等价代码"></a>2.2.1 等价代码</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Speaker</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-type">void</span>)speak;<br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Speaker</span></span><br>- (<span class="hljs-type">void</span>)speak &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;my name&#x27;s %@&quot;</span>, <span class="hljs-keyword">self</span>.name);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> : <span class="hljs-title">UIViewController</span></span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-type">id</span> cls = [Speaker <span class="hljs-keyword">class</span>];<br>    <span class="hljs-type">void</span> *obj = &amp;cls;<br>    [(__bridge <span class="hljs-type">id</span>)obj speak];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>我们将这个 ViewController.m 文件编译为 ViewController.cpp 来看一下。</p><p>在 终端 中切换到 ViewController.m 所在目录，并输入以下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">xcrun</span> -sdk iphoneos clang -arch arm64 -w -rewrite-objc -fobjc-arc -mios-version-min=<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> -fobjc-runtime=ios-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> ViewController.m<br></code></pre></td></tr></table></figure><p>执行完毕后我们可以在同一个目录下找到 ViewController.cpp 文件。</p><p>打开 ViewController.cpp ，并搜索 ViewController_viewDidLoad 即可找到下面的方法：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _I_ViewController_viewDidLoad(ViewController <span class="hljs-operator">*</span> self, SEL _cmd) &#123;<br>    ((<span class="hljs-keyword">void</span> (<span class="hljs-operator">*</span>)(__rw_objc_super <span class="hljs-operator">*</span>, SEL))(<span class="hljs-keyword">void</span> <span class="hljs-operator">*</span>)objc_msgSendSuper)((__rw_objc_super)&#123;(<span class="hljs-built_in">id</span>)self, (<span class="hljs-built_in">id</span>)class_getSuperclass(objc_getClass(<span class="hljs-string">&quot;ViewController&quot;</span>))&#125;, sel_registerName(<span class="hljs-string">&quot;viewDidLoad&quot;</span>));<br>    <span class="hljs-built_in">id</span> cls <span class="hljs-operator">=</span> ((Class (<span class="hljs-operator">*</span>)(<span class="hljs-built_in">id</span>, SEL))(<span class="hljs-keyword">void</span> <span class="hljs-operator">*</span>)objc_msgSend)((<span class="hljs-built_in">id</span>)objc_getClass(<span class="hljs-string">&quot;Speaker&quot;</span>), sel_registerName(<span class="hljs-string">&quot;class&quot;</span>));<br>    <span class="hljs-keyword">void</span> <span class="hljs-operator">*</span>obj <span class="hljs-operator">=</span> <span class="hljs-operator">&amp;</span>cls;<br>    ((<span class="hljs-keyword">void</span> (<span class="hljs-operator">*</span>)(<span class="hljs-built_in">id</span>, SEL))(<span class="hljs-keyword">void</span> <span class="hljs-operator">*</span>)objc_msgSend)((<span class="hljs-built_in">id</span>)(__bridgeid)obj, sel_registerName(<span class="hljs-string">&quot;speak&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来有点复杂，我们把非必要的格式转换去掉：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">_I_ViewController_viewDidLoad(ViewController <span class="hljs-operator">*</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">_cmd</span>)</span> &#123;<br>    objc<span class="hljs-constructor">_msgSendSuper((<span class="hljs-params">__rw_objc_super</span>)</span>&#123;self, <span class="hljs-keyword">class</span><span class="hljs-constructor">_getSuperclass(<span class="hljs-params">objc_getClass</span>(<span class="hljs-string">&quot;ViewController&quot;</span>)</span>)&#125;, sel<span class="hljs-constructor">_registerName(<span class="hljs-string">&quot;viewDidLoad&quot;</span>)</span>); <span class="hljs-comment">// 1</span><br>    id cls = objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">objc_getClass</span>(<span class="hljs-string">&quot;Speaker&quot;</span>)</span>, sel<span class="hljs-constructor">_registerName(<span class="hljs-string">&quot;class&quot;</span>)</span>); <span class="hljs-comment">// 2</span><br>    void *obj = &amp;cls; <span class="hljs-comment">// 3</span><br>    objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">obj</span>, <span class="hljs-params">sel_registerName</span>(<span class="hljs-string">&quot;speak&quot;</span>)</span>); <span class="hljs-comment">// 4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li>对应 [super viewDidLoad]</li><li>对应 id cls &#x3D; [Speaker class];</li><li>对应 void *obj &#x3D; &amp;cls;</li><li>对应 [(__bridge id)obj speak];</li></ul><p>objc_msgSend 会传入两个隐式参数self和_cmd，想必大家已经很熟悉了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">objc_msgSend</span>(void /* id self, SEL op, ... */ )<br>    <span class="hljs-attribute">OBJC_AVAILABLE</span>(<span class="hljs-number">10</span>.<span class="hljs-number">0</span>, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>, <span class="hljs-number">9</span>.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>);<br><br><span class="hljs-attribute">objc_msgSendSuper</span>(void /* struct objc_super *super, SEL op, ... */ )<br>    <span class="hljs-attribute">OBJC_AVAILABLE</span>(<span class="hljs-number">10</span>.<span class="hljs-number">0</span>, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>, <span class="hljs-number">9</span>.<span class="hljs-number">0</span>, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>而 objc_msgSendSuper 需要传入另一个结构体 <code>struct objc_super *</code>。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">/// Specifies the superclass of an instance.</span><br>struct objc_super &#123;<br>    <span class="hljs-comment">/// Specifies an instance of a class.</span><br>    <span class="hljs-variable">__unsafe_unretained</span> <span class="hljs-variable">_Nonnull</span> id receiver;<br><br>    <span class="hljs-comment">/// Specifies the particular superclass of the instance to message.</span><br><span class="hljs-meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br>    <span class="hljs-comment">/* For compatibility with old objc-runtime.h header */</span><br>    <span class="hljs-variable">__unsafe_unretained</span> <span class="hljs-variable">_Nonnull</span> Class class;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-variable">__unsafe_unretained</span> <span class="hljs-variable">_Nonnull</span> Class super_class;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* super_class is the first class to search */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>&#123;self, class_getSuperclass(objc_getClass(&quot;ViewController&quot;))&#125;</code> 实际上就是在初始化一个struct objc_super结构体。</p><p>知道这些之后，再阅读上面的代码就没有什么难度了。</p><h4 id="2-2-2-参数顺序"><a href="#2-2-2-参数顺序" class="headerlink" title="2.2.2 参数顺序"></a>2.2.2 参数顺序</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">void</span> sum(<span class="hljs-built_in">NSNumber</span> *a, <span class="hljs-built_in">NSNumber</span> *b) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;a地址 = %p&quot;</span>, &amp;a);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;b地址 = %p&quot;</span>, &amp;b);<br>    printf(<span class="hljs-string">&quot;%d&quot;</span>, a.intValue + b.intValue);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    sum(@(<span class="hljs-number">1</span>), @(<span class="hljs-number">2</span>));<br>    <span class="hljs-built_in">NSNumber</span> *c = @(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;c地址 = %p&quot;</span>, &amp;c);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在给函数传入参数时，参数会作为自动变量入栈 ：</p><p><img src="https://i.loli.net/2020/12/30/Mm6yB5NUKei1Gu7.png" alt="2020-12-30-8.58.19.png"></p><p>而且我们可以看到入栈的顺序是a先入栈，b后入栈，因为 栈从高地址到低地址分配内存 。</p><p>但是在初始化一个结构体的时候，这个顺序是相反的：</p><p><img src="https://i.loli.net/2020/12/30/vfXLpJNrD4Och7s.png" alt="2020-12-30-8.58.27.png"></p><p>我们看到 two_number tn &#x3D; {@(1), @(2)}; 先传入的是1后传入的2，但实际情况是2先入栈，1后入栈。</p><p>按照上面2条规则，下面代码第5步之前的变量入栈的顺序应该是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void <span class="hljs-constructor">_I_ViewController_viewDidLoad(ViewController <span class="hljs-operator">*</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">_cmd</span>)</span> &#123; <span class="hljs-comment">// 1</span><br>    objc<span class="hljs-constructor">_msgSendSuper((<span class="hljs-params">__rw_objc_super</span>)</span>&#123;self, <span class="hljs-keyword">class</span><span class="hljs-constructor">_getSuperclass(<span class="hljs-params">objc_getClass</span>(<span class="hljs-string">&quot;ViewController&quot;</span>)</span>)&#125;, sel<span class="hljs-constructor">_registerName(<span class="hljs-string">&quot;viewDidLoad&quot;</span>)</span>); <span class="hljs-comment">// 2</span><br>    id cls = objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">objc_getClass</span>(<span class="hljs-string">&quot;Speaker&quot;</span>)</span>, sel<span class="hljs-constructor">_registerName(<span class="hljs-string">&quot;class&quot;</span>)</span>); <span class="hljs-comment">// 3</span><br>    void *obj = &amp;cls; <span class="hljs-comment">// 4</span><br>    objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">obj</span>, <span class="hljs-params">sel_registerName</span>(<span class="hljs-string">&quot;speak&quot;</span>)</span>); <span class="hljs-comment">// 5</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>self、_cmd为函数的隐式参数，依次先入栈。</p></li><li><p>objc_msgSendSuper 初始化了一个结构体，这个结构体的参数会入栈。</p><p>又因为参数入栈是从右到左的顺序入栈：</p></li><li><ul><li>class_getSuperclass(objc_getClass(“ViewController”))</li><li>self后入栈</li></ul></li><li><p>cls本地变量赋值为Speaker类，最后入栈</p></li></ul><p>那么入栈的顺序为self、_cmd、class_getSuperclass(objc_getClass(“ViewController”))、self、Speaker类。下面我们验证一下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Speaker</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-type">void</span>)speak;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Speaker</span></span><br>- (<span class="hljs-type">void</span>)speak &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Speaker self: %p, _name: %p&quot;</span>, <span class="hljs-keyword">self</span>, &amp;_name);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Speaker&#x27;s name: %@&quot;</span>, <span class="hljs-keyword">self</span>.name);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-type">id</span> cls = [Speaker <span class="hljs-keyword">class</span>]; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">void</span> *obj = &amp;cls; <span class="hljs-comment">// 2</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;栈区变量&quot;</span>);<br>    <span class="hljs-type">void</span> *start = (<span class="hljs-type">void</span> *)&amp;<span class="hljs-keyword">self</span>;<br>    <span class="hljs-type">void</span> *end = (<span class="hljs-type">void</span> *)&amp;obj;<br>    <span class="hljs-type">long</span> count = (start - end) / <span class="hljs-number">0x8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-type">void</span> *address = start - <span class="hljs-number">0x8</span> * i;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p: %s&quot;</span>, address, *(<span class="hljs-type">char</span> **)(address));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p: %@&quot;</span>, address, *(<span class="hljs-type">void</span> **)address);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;obj speak&quot;</span>);<br>    [(__bridge <span class="hljs-type">id</span>)obj speak]; <span class="hljs-comment">// 3</span><br>&#125;<br><span class="hljs-keyword">@end</span><br><span class="hljs-comment">// 打印</span><br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] 栈区变量<br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] <span class="hljs-number">0x7ffeec17c648</span>: &lt;ViewController: <span class="hljs-number">0x7fb445607ee0</span>&gt;<br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] <span class="hljs-number">0x7ffeec17c640</span>: viewDidLoad<br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] <span class="hljs-number">0x7ffeec17c638</span>: ViewController <span class="hljs-comment">//这里比较怪</span><br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] <span class="hljs-number">0x7ffeec17c630</span>: &lt;ViewController: <span class="hljs-number">0x7fb445607ee0</span>&gt;<br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] <span class="hljs-number">0x7ffeec17c628</span>: Speaker<br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] obj speak<br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] Speaker <span class="hljs-keyword">self</span>: <span class="hljs-number">0x7ffeec17c628</span>, _name: <span class="hljs-number">0x7ffeec17c630</span><br>Demo[<span class="hljs-number">32768</span>:<span class="hljs-number">1105890</span>] Speaker<span class="hljs-string">&#x27;s name: &lt;ViewController: 0x7fb445607ee0&gt;</span><br></code></pre></td></tr></table></figure><p>从输出可以看到，栈区的打印顺序和我们的分析基本吻合。<br>下面我们看一下为什么Speaker实例对象的 self.name 访问到的是ViewController实例对象。</p><ul><li>Speaker实例对象，如果我们通过 [[Speaker alloc] init] 初始化的话，会在堆区分配内存。但现在，我们是使用栈区指针指向了Speaker类对象地址，”伪装”成了一个Speaker实例对象，所以传入的self值为栈区的地址：0x7ffeec17c628 。</li><li>从上面的输出我们可以看到，name属性的实例变量_name在Speaker实例对象 self + 0x8 的地址，即 0x7ffeec17c630 。</li><li>根据输出_name实例变量访问的地址 0x7ffeec17c630 ，找到栈区对应的数据 0x7ffeec17c630: <code>&lt;ViewController: 0x7fb445607ee0&gt;</code> ，所以输出为 Speaker’s name: <code>&lt;ViewController: 0x7fb445607ee0&gt;</code> 。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>通过这个面试题我们得出了一下结论：</p><ul><li>Objective-C中的对象是一个指向class_object地址的变量，即 id obj &#x3D; &amp;class_object</li><li>对象的实例变量 void *ivar &#x3D; &amp;obj + offset(N)</li></ul><p>但这里还有一个疑问：</p><p>我们看到直接调用 [super viewDidLoad]; ，栈区的第3个变量为ViewController类。</p><p>但根据我们用Clang重写的代码 [super viewDidLoad]; 实现做替换：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    ((<span class="hljs-type">void</span> (*)(<span class="hljs-keyword">struct</span> objc_super *, SEL))(<span class="hljs-type">void</span> *)objc_msgSendSuper)(&amp;((<span class="hljs-keyword">struct</span> objc_super)&#123;(<span class="hljs-type">id</span>)<span class="hljs-keyword">self</span>, (<span class="hljs-type">id</span>)class_getSuperclass(objc_getClass(<span class="hljs-string">&quot;ViewController&quot;</span>))&#125;), sel_registerName(<span class="hljs-string">&quot;viewDidLoad&quot;</span>));<br>    <br>    <span class="hljs-type">id</span> cls = [Speaker <span class="hljs-keyword">class</span>]; <span class="hljs-comment">// 1</span><br>    <span class="hljs-type">void</span> *obj = &amp;cls; <span class="hljs-comment">// 2</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;栈区变量&quot;</span>);<br>    <span class="hljs-type">void</span> *start = (<span class="hljs-type">void</span> *)&amp;<span class="hljs-keyword">self</span>;<br>    <span class="hljs-type">void</span> *end = (<span class="hljs-type">void</span> *)&amp;obj;<br>    <span class="hljs-type">long</span> count = (start - end) / <span class="hljs-number">0x8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-type">void</span> *address = start - <span class="hljs-number">0x8</span> * i;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p: %s&quot;</span>, address, *(<span class="hljs-type">char</span> **)(address));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%p: %@&quot;</span>, address, *(<span class="hljs-type">void</span> **)address);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;obj speak&quot;</span>);<br>    [(__bridge <span class="hljs-type">id</span>)obj speak]; <span class="hljs-comment">// 3</span><br>&#125;<br><span class="hljs-comment">// 输出</span><br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] 栈区变量<br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] <span class="hljs-number">0x7ffee4983648</span>: &lt;ViewController: <span class="hljs-number">0x7f9e0bf07fd0</span>&gt;<br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] <span class="hljs-number">0x7ffee4983640</span>: viewDidLoad<br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] <span class="hljs-number">0x7ffee4983638</span>: <span class="hljs-built_in">UIViewController</span> <span class="hljs-comment">// 这里符合预期</span><br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] <span class="hljs-number">0x7ffee4983630</span>: &lt;ViewController: <span class="hljs-number">0x7f9e0bf07fd0</span>&gt;<br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] <span class="hljs-number">0x7ffee4983628</span>: Speaker<br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] obj speak<br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] Speaker <span class="hljs-keyword">self</span>: <span class="hljs-number">0x7ffee4983628</span>, _name: <span class="hljs-number">0x7ffee4983630</span><br>Demo[<span class="hljs-number">33008</span>:<span class="hljs-number">1114325</span>] Speaker<span class="hljs-string">&#x27;s name: &lt;ViewController: 0x7f9e0bf07fd0&gt;</span><br></code></pre></td></tr></table></figure><p>我们看到栈区的第3个变量为UIViewController类，这个输出是符合预期的，因为<code>class_getSuperclass(objc_getClass(&quot;ViewController&quot;))</code>我们获取的就是父类。</p><p>但为什么直接调用 [super viewDidLoad]; ，栈区的第3个变量为ViewController类，这个问题难道是Xcode的Bug？？？</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态库与静态库</title>
    <link href="/2018/08/05/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2018/08/05/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h4 id="dymanic-framework原因"><a href="#dymanic-framework原因" class="headerlink" title="dymanic framework原因"></a>dymanic framework原因</h4><p>在iOS8以前,苹果只允许发布静态库,当然cocoapods只支持静态库,但是在iOS8苹果推出了APP extension的概念,可以对项目进行扩展,感兴趣的可以看<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html">APP extension</a>.<br> 因为APP extension和主项目是两个独立的进程,为了共享代码,苹果允许我们创建动态库,即<code>dynamic framework</code>.</p><h4 id="swift第三方库"><a href="#swift第三方库" class="headerlink" title="swift第三方库"></a>swift第三方库</h4><p>在swift语言日益优化的前提下,我们想要进行项目swift化,但是在Xcode 6.0 Beta 4的 Release Notes 中，可以找到这句话：<br> <code>Xcode does not support building ``static</code> <code>libraries that include Swift code. (17181019)</code></p><h4 id="动态库导致的static-library报错"><a href="#动态库导致的static-library报错" class="headerlink" title="动态库导致的static library报错"></a>动态库导致的static library报错</h4><p>看了上面的原因,你会问pod直接使用动态库不就好了,但是对于pod来说,有这么几个问题</p><ul><li>包含静态库报错<br> <code>The &#39;xxx&#39; target has transitive dependencies that include static binaries</code></li><li>动态库不能依赖静态库</li></ul><p>ok,介绍完历史原因,我们继续看,在讲解适配前,先了解几个概念.</p><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>项目都使用cocoapods进行第三方库的管理,pod可以实现依赖管理,版本控制等功能,对于主项目X依赖A,A内部A-&gt;B,A-&gt;C,B→D,这类的依赖情况,主项目只需要引入A,在安装时就会检测其他的依赖pod是否存在,不存在进行安装.</p><p>pod的管理,使得项目中同一类的库只存在一份,cocoapods的项目可以<strong>静态库</strong> <strong>动态库</strong>二选其一,关于这两种的区别下面会做详细解释</p><p>默认使用静态库管理,如果想改为动态,需要在podfile内部添加use_frameworks!字段,该字段告诉pod,使用框架的方式,安装和管理第三方库</p><p>静态库不能包含swift文件,pod将第三方编译为static library,不能支持swift语言,新版的改为了framework的形式,下面介绍library和framework的区别.</p><h1 id="library和framework"><a href="#library和framework" class="headerlink" title="library和framework"></a>library和framework</h1><p><strong>library</strong>仅能包含编译后的代码,即.a文件,不能包含其他的资源文件.</p><p>但是我们封装的第三方库,有时需要包含.h文件,.nib文件,图片,文档扥g</p><p><strong>framework</strong>可以包含以上所有类型.且支持包含swift代码.</p><p><strong>framework</strong>支持iOS8以后,而static library可以追溯到iOS6.</p><p>由于 iOS 的沙盒机制,自己创建的 Framework 和系统Framework 不同,App 中使用的 Framework 运行在沙盒里,而不是系统中.每个 App 都只能用自己对应签名的动态库,做不到多个 App 使用一个动态库</p><h1 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h1><p>动态库和静态库的区别如下</p><table><thead><tr><th></th><th>动态库</th><th>静态库</th></tr></thead><tbody><tr><td>命名空间</td><td>有单独的命名空间,不同库同名文件不会冲突 使用import&lt;XXX&#x2F;xxx.h&gt;的方式引入</td><td>没有单独命名空间,同名文件冲突 引入方式import”xxx.h”</td></tr><tr><td>加载时机</td><td>在启动时加载,加载时间较长</td><td>构建时加载</td></tr><tr><td>依赖关系</td><td>可以依赖动态库,不能依赖静态库</td><td>可以依赖动态库和静态库</td></tr><tr><td>是否能使用swift</td><td>可以包含swift文件</td><td>在cocoapods1.4.0之后,可以使用use_framework!的方式包含swift文件 framework支持static_framework</td></tr></tbody></table><span id="more"></span><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>上面的总结我们知道静态库在程序启动时被加载,动态库在使用时被加载</p><p>那么这些区别原理何在呢,下面分析下几个概念:</p><h3 id="编译-目标文件-符号表-链接"><a href="#编译-目标文件-符号表-链接" class="headerlink" title="编译,目标文件,符号表,链接"></a>编译,目标文件,符号表,链接</h3><p>编译: 编译器生成机器代码,生成目标文件.</p><p>目标文件包含两种符号表: 1.文件转换后的符号(名称和方法的地址及偏移量)  2.未确定的符号(需要在链接阶段才能解析完成的机器代码)</p><p>目标文件包含名为”main”的符号,可以将代码块加载进RAM运行.并将”main”作为符号表的运行入口的初始位置</p><p>链接: 将我们的各种目标文件加上一些第三方库，和系统库链接为可执行文件</p><p>链接主要决议符号,也就是变量函数等的地址</p><ul><li>若符号来⾃静态库(本质就是.o 的集合包)或 .o，将其纳⼊链接产物，并确定符号地址</li><li>若符号来⾃动态库，打个标记，等启动的时候再说—交给 dyld 去加载和链接符号</li></ul><p>于是链接加装载就有了不同的情况</p><p>Load 装载：将库⽂件载⼊内存</p><ul><li>Static Loading：启动时</li><li>Dynamic Loading：启动后（使⽤时）<br> Link 链接：决议符号地址</li><li>Static Linking：构建（链接）时</li><li>Dynamic Linking：运⾏时（启动时或使⽤时）</li></ul><h3 id="静态-共享和动态库"><a href="#静态-共享和动态库" class="headerlink" title="静态,共享和动态库"></a>静态,共享和动态库</h3><p>静态库只是目标文件的集合.静态库只是为了方便处理大量文件.链接器只选取需要的文件并将它们写入最终代码块,这使得静态链接程序很大.( This makes statically linked programs pretty large.)</p><p>共享和动态库只需要被系统加载一次.然后使用该库的工程只需要对其进行引用即可.共享和动态库有两种创建方式</p><p>1.全量的链接对象文件,包含大量的可被调用的符号表(真实的库代码)</p><p>2.通过”stub”对象文件,包含可调用方法的映射表(jump table)</p><p>通过动态库链接时,stub对象文件是通过类似静态库的形式被加载到程序中的.但是方法只是加载了方法声明.</p><p>当程序使用动态库加载时,系统需要额外链接存储在RAM中的共享库.在加载系统共享库的stub文件时有个实现技巧.有两种方式可以实现加载系统共享库,1.系统拦截调用,进入系统,修改项目地址的上下文,转换到共享库,工作量很大.另一种方式,将静态库映射到运行程序通过虚拟内存管理的地址空间,这使得共享库对于多个项目来说,只是项目的一部分,虽然只在内存中短暂存在.</p><p>这样的话,代码被共享,但是每个程序的堆栈由自己管理,使得各个程序员直接完全独立.</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>静态库:稳定,但是占用内存空间.</p><p>动态库:从系统加载代码,共享代码节约空间,但是可以会导致运行时的错误,且不易定位和修复.</p><h1 id="动态库详解"><a href="#动态库详解" class="headerlink" title="动态库详解"></a>动态库详解</h1><p>苹果官方关于动态库的描述:</p><p>动态库相比静态库,减少了app可执行文件的大小.并且可以只在使用时,按需加载而不是在启动时加载.这个特性减低了启动时间,并且更优秀的利用了内存.</p><p>动态库不能依赖静态库</p><h2 id="启动时间过长解决办法"><a href="#启动时间过长解决办法" class="headerlink" title="启动时间过长解决办法"></a>启动时间过长解决办法</h2><ol><li><a href="https://github.com/keith/swift-staticlibs">第三方框架swift-staticlibs,集成的为动态库,在构建阶段,转为静态库加载的形式,这样做的原因:</a><ol><li>Xcode的static library不能包含swift</li><li>动态库启动时间过长</li></ol></li><li>使用static framework的方式,下面会做介绍</li></ol><h1 id="静态库详解"><a href="#静态库详解" class="headerlink" title="静态库详解"></a>静态库详解</h1><p>我们可以在Build Setting里面通过Mach-O Type查看target的动态或者静态状态</p><p>[图片上传失败…(image-28b016-1519821296948)]</p><h2 id="cocoapods1-4-0对于static-framework的支持"><a href="#cocoapods1-4-0对于static-framework的支持" class="headerlink" title="cocoapods1.4.0对于static framework的支持"></a>cocoapods1.4.0对于static framework的支持</h2><h3 id="static-framework"><a href="#static-framework" class="headerlink" title="static framework"></a>static framework</h3><p>pod在1.4.0之后提供了静态框架的特性.过去的ues_framework!只能发布动态库,现在可以发布静态的框架.这一特性解决了过去动态框架不能依赖静态库的弊端.现在的静态framework也可以依赖静态库,也可以依赖通过vendored_frameworks发布的第三方框架.</p><p>补充,vendored_frameworks和vendored_library是在podspec文件内使用的属性,用法是声明包含的第三方framework和library.</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li><ol><li>static framework和library有什么区别呢? framework是对于library,头文件和资源等内容的封装.library可以是动态或者静态的,静态库在构建时期链接,但是动态库是在运行时才进行加载.</li><li>动态库不能依赖静态库是因为静态库不需要在运行时再次加载,如果多个动态库依赖同一个静态库,会出现多个静态库的拷贝,而这些拷贝本身只是对于内存空间的消耗.</li><li>另一个历史原因是,过去很多库是通过包含静态库的vendored_framework形式发布的.</li><li>在1.4.0之前,资源只能通过动态库的方式构建,所以不能依赖vendored_framework的库.而且对于vendored_framework的二进制库,无法在转换成资源pod时仍保持动态性</li></ol></li></ol><p>以上原因,使得pod在1.4.0提供了静态框架的支持.用法简单,只需要在podspec文件内,声明如下即可</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">s.static_framework</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>所有swift库需要保持一致的版本,包含Swift文件的framework,必须指定swift的版本号,pod之后提供了新特性<a href="https://github.com/CocoaPods/CocoaPods/issues/7134">pod制定swift版本范围</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">`Pod::Spec.`</span><span class="hljs-string">`new`</span> <span class="hljs-string">`do`</span> <span class="hljs-string">`|s|`</span><br><br><span class="hljs-string">`s.name = `</span><span class="hljs-string">`&#x27;BanannaLib&#x27;`</span><br><br><span class="hljs-string">`s.version = `</span><span class="hljs-string">`&#x27;1.0.0&#x27;`</span><br><br><span class="hljs-string">`s.swift_version = `</span><span class="hljs-string">`&#x27;&gt;= 3.2&#x27;`</span><br><br><span class="hljs-string">`s.source_files = `</span><span class="hljs-string">`&#x27;**/*.swift&#x27;`</span><br><br><span class="hljs-string">`end`</span><br></code></pre></td></tr></table></figure><h2 id="支持包含swift文件"><a href="#支持包含swift文件" class="headerlink" title="支持包含swift文件"></a>支持包含swift文件</h2><p>在创建私有pod时,如果项目中包含swift文件,需要在podfile内部添加use_framework!字段,如果不添加会报以下错误</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[!] Pods written <span class="hljs-keyword">in</span> Swift can only be integrated <span class="hljs-keyword">as</span> frameworks; <span class="hljs-keyword">add</span> `use_frameworks!` to your Podfile <span class="hljs-keyword">or</span> target to opt <span class="hljs-keyword">into</span> <span class="hljs-keyword">using</span> it. The Swift Pod being used <span class="hljs-keyword">is</span>: erp-boss-common-ios<br></code></pre></td></tr></table></figure><p>如果框架已经声明了static_framework &#x3D; true,则可以包含swift文件,且可以依赖其他的静态库.</p><p>苹果官方的Xcode9发布文档有以下说明<a href="https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-Xcode/Chapters/Introduction.html#//apple_ref/doc/uid/TP40001051-CH1-SW936">Xcode release文档</a></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title class_">Xcode</span> supports <span class="hljs-keyword">static</span> library targets which contain <span class="hljs-title class_">Swift</span> code. <span class="hljs-title class_">Debugging</span> applications that use <span class="hljs-title class_">Swift</span> <span class="hljs-keyword">static</span> libraries may <span class="hljs-built_in">require</span> a complete set <span class="hljs-keyword">of</span> build artifacts that are <span class="hljs-keyword">in</span> their original location. (<span class="hljs-string">``</span><span class="hljs-number">33297067</span><span class="hljs-string">``</span>)<span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>Xcode支持包含swift代码的静态库项目.</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h4><p>包含.a的static library,可以用lipo查看.a库所支持的架构.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">lipo -info libTestLib<span class="hljs-selector-class">.a</span> <br><br>Architectures in the fat file: libTestLib.a are: armv7 i386 x86_64 arm64<br></code></pre></td></tr></table></figure><h1 id="静态库报错"><a href="#静态库报错" class="headerlink" title="静态库报错"></a>静态库报错</h1><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>在我们使用use_frameworks!的时候,会遇到类似于下面的错误提示,引起这种提示的原因,和各种情况,下面分析一下.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[!] <span class="hljs-title class_">The</span> <span class="hljs-string">&#x27;Pods-testDynamic_Example&#x27;</span><span class="hljs-string">` `</span>target has transitive dependencies that <span class="hljs-keyword">include</span> static <span class="hljs-symbol">binaries:</span> (<span class="hljs-regexp">/Users/zhaoyanan</span><span class="hljs-regexp">/Documents/projects</span><span class="hljs-regexp">/pod/test</span>Dynamic/<span class="hljs-title class_">Example</span>/<span class="hljs-title class_">Pods</span>/<span class="hljs-variable constant_">SAKC</span>-<span class="hljs-title class_">Ares</span>/lib/libcares_iOS.a)<br></code></pre></td></tr></table></figure><p>boss-&gt;A-&gt;B-&gt;SL(static library)</p><p>boss为主项目</p><p>SL为包含.a的静态库</p><p>boss-&gt;SL,没有问题</p><p>在B内增加static_framework &#x3D; true, 可以解决boss-&gt;B-&gt;C问题</p><p>对于boss-&gt;A-&gt;B-&gt;C的情况,如果A,A’,A’’都依赖了B,需要保证他们依赖的方式相同,即都不指定版本号,都在都指定特定的版本号,或者都指定相同的范围,声明不同,则会报错.</p><p>s.static_framework &#x3D; true, s.subspec不需要再设置</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>有一种做法,可以作为参考,没有测试,对于<code>A-&gt;B-&gt;C-SL</code>的情况十是否使用也不可知,感兴趣的可以研究下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart">A库依赖B库为例,B库中有一个静态库libB.a :<br><br>在A库中修改.podspec :<br><br>s.pod_target_xcconfig = &#123;<br><br><span class="hljs-string">&#x27;FRAMEWORK_SEARCH_PATHS&#x27;</span>`=&gt;<span class="hljs-string">&#x27;$(inherited) $(PODS_ROOT)/Crashlytics&#x27;</span>,<br><br><span class="hljs-string">&#x27;OTHER_LDFLAGS&#x27;</span>         =&gt; <span class="hljs-string">&#x27;$(inherited) -undefined dynamic_lookup&#x27;</span><br><br>&#125;， <br><br>然后在Podfile中添加hook：<br><br>pre_install <span class="hljs-keyword">do</span> |installer|<br><br># workaround ``<span class="hljs-keyword">for</span>` `https:``<span class="hljs-comment">//github.com/CocoaPods/CocoaPods/issues/3289</span><br><br>def installer.verify_no_static_framework_transitive_dependencies; end<br><br>end<br></code></pre></td></tr></table></figure><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>在pod1.5.0之后,安装包含swift第三方库的时候,不限制必须在podfile内声明<code>use_frameworks!</code>.但是,如果swift库依赖OC库,就需要在OC库内允许<code>modular headers</code></p><h2 id="Modular-Headers"><a href="#Modular-Headers" class="headerlink" title="Modular Headers"></a>Modular Headers</h2><p>CocoaPods在创建之初,就致力于封装尽可能多的第三方库.pod管理了第三方库的头文件搜索路径(header search paths).pod允许任意pod之间的相互引用,不需要考虑命名空间,不用制定import &lt;nameSpace&#x2F;fileName&gt;.</p><p>例如B库使用#import”A.h”的,pod会配置对应的build setting来保证这种引入的可行.但是如果在其他库内增加了module maps,这种引用就会找不到文件.pod尝试自动去管理静态库的module maps,但是因为这样破坏了pod的使用方式,没有进行下去.<br> 说一下 module maps<br> 在XCode的build setting内,<strong>Packaging</strong>内有以下设置module map的选项</p><ol><li><strong>Defines Module (DEFINES_MODULE)</strong> :<br> 如果设置为YES,会认为项目自定义自己的组件,允许项目通过组件的方式引入</li><li><strong>Module Map File (MODULEMAP_FILE)</strong><br> 用来管理LLVM的module map,定义编译器组件结构.如果defines module为YES的时候,如果Module Map File没填,会自动生成.</li></ol><p>在pod1.5.0版本中,通过直接import和组件导入都能找到文件.对于pod开发者,可以在<code>pod_target_xcconfig</code>内添加<code>&#39;DEFINES_MODULE&#39; =&gt; &#39;YES&#39;</code>.对于使用者,可以在podfile内添加<code>use_modular_headers!</code>允许直接import和module map.也可以通过<code>:modular_headers =&gt; true</code>配置特定的pod.</p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>buildProcess</title>
    <link href="/2018/04/01/buildProcess/"/>
    <url>/2018/04/01/buildProcess/</url>
    
    <content type="html"><![CDATA[<p>近些日子我们被宠坏了 – 我们只需要单击 Xcode 中的一个按钮（这个按钮看起来有点像是在播放一些音乐的动作），过几秒钟之后，我们的程序就会运行起来了，除非遇到一些错误，这非常的神奇。</p><p>在本文中，我们将从更高级别的角度来解读 Build 过程，并探索一下在 Xcode 界面中暴露出的 project setting 信息与 Build 过程有什么关系。为了更加深入的探索 Build 过程中，每一步实际执行的工作，我都会在本文中引入一些别的文章。</p><span id="more"></span><h2 id="解密-Build-日志"><a href="#解密-Build-日志" class="headerlink" title="解密 Build 日志"></a>解密 Build 日志</h2><p>为了了解 Xcode build 过程的内部工作原理，我们首先把突破口瞄准完整的 log 文件上。打开 Log Navigator ，从列表中选择一个 Build ，Xcode 会将 log 文件很完美的展现出来。</p><p><img src="https://objccn.io/images/issues/issue-6/build-log.png" alt="Xcode build log navigator"></p><p>默认情况下，上面的 Xcode 界面中隐藏了大量的信息，我们通过选择任务，然后点击右边的展开按钮，就能看到每个任务的详细信息。另外一种可选的方案就是选中列表中的一个或者多个任务，然后选择组合键 Cmd-C，这将会把所有的纯文本信息拷贝至粘贴板。最后，我们还可以选择 Editor 菜单中的 “Copy transcript for shown results”，以此将所有的 log 信息拷贝到粘贴板中。</p><p>本文给出的示例中，log 信息将近有 10,000 行（其实大多数的 log 信息是编译 OpenSSL 时生成的，并不是我们自己所写的代码生成的）。下面我们就开始吧！</p><p>注意观察输出的 log 信息，首先会发现 log 信息被分为不同的几大块，它们与我们工程中的targets相互对应着：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">Build target Pods-SSZipArchive<br><span class="hljs-meta prompt_">...</span><br>Build target Makefile-openssl<br><span class="hljs-meta prompt_">...</span><br>Build target Pods-AFNetworking<br><span class="hljs-meta prompt_">...</span><br>Build target crypto<br><span class="hljs-meta prompt_">...</span><br>Build target Pods<br><span class="hljs-meta prompt_">...</span><br>Build target ssl<br><span class="hljs-meta prompt_">...</span><br>Build target objcio<br></code></pre></td></tr></table></figure><p>本文涉及到的工程有几个依赖项：其中 AFNetworking 和 SSZipArchive 包含在 Pods 中，而 OpenSSL 则以子工程的形式包含在工程中。</p><p>针对工程中的每个 target，Xcode 都会执行一系列的操作，将相关的源码，根据所选定的平台，转换为机器可读的二进制文件。下面我们详细的了解一下第一个 target：SSZipArchive。</p><p>在针对这个 target 输出的 log 信息中，我们可以看到每个任务被执行的详细情况。例如第一个任务是处理一个预编译头文件（为了增强 log 信息的可读性，我省略了许多细节）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">(<span class="hljs-number">1</span>) ProcessPCH <span class="hljs-regexp">/.../</span>Pods-SSZipArchive-prefix.pch.pch Pods-SSZipArchive-prefix.pch normal armv7 objective-c com.apple.compilers.llvm.clang.<span class="hljs-number">1</span>_0.compiler<br>    (<span class="hljs-number">2</span>) cd <span class="hljs-regexp">/.../</span>Dev<span class="hljs-regexp">/objcio/</span>Pods<br>        setenv LANG en_US.US-ASCII<br>        setenv PATH <span class="hljs-string">&quot;...&quot;</span><br>    (<span class="hljs-number">3</span>) <span class="hljs-regexp">/.../</span>Xcode.app<span class="hljs-regexp">/.../</span>clang <br>            (<span class="hljs-number">4</span>) -x objective-c-header <br>            (<span class="hljs-number">5</span>) -arch armv7 <br>            ... configuration and warning flags ...<br>            (<span class="hljs-number">6</span>) -DDEBUG=<span class="hljs-number">1</span> -DCOCOAPODS=<span class="hljs-number">1</span> <br>            ... <span class="hljs-keyword">include</span> paths and more ...<br>            (<span class="hljs-number">7</span>) -c <br>            (<span class="hljs-number">8</span>) <span class="hljs-regexp">/.../</span>Pods-SSZipArchive-prefix.pch <br>            (<span class="hljs-number">9</span>) -o <span class="hljs-regexp">/.../</span>Pods-SSZipArchive-prefix.pch.pch<br></code></pre></td></tr></table></figure><p>在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。</p><ol><li>类似上面的每个 log 信息块都会利用一行 log 信息来描述相关的任务作为起点。</li><li>接着输出带缩进的3行 log 信息，列出了该任务执行的语句。此处，工作目录发生了改变，并对 LANG 和 PATH 环境变量进行设置。</li><li>这里是发生奇迹的地方。为了处理一个<code>.pch</code>文件，调用了 clang，并附带了许多可选项。下面跟着输出的 log 信息显示了完整的调用过程，以及所有的参数。我们看看其中的几个参数…</li><li><code>-x</code> 标示符用来指定所使用的语言，此处是 <code>objective-c-header</code>。</li><li>目标架构指定为 <code>armv7</code>。</li><li>暗示 <code>#defines</code> 的内容已经被添加了。</li><li><code>-c</code> 标示符用来告诉 clang 具体该如何做。<code>-c</code> 表示：运行预处理器、词法分析器、类型检查、LLVM 的生成和优化，以及 target 指定汇编代码的生成阶段，最后，运行汇编器以产出一个<code>.o</code>的目标文件。</li><li>输入文件。</li><li>输出文件。</li></ol><p>虽然有大量的 log 信息，不过我不会对每个任务做详细的介绍。我们的重点是让你全面的了解在整个 build 过程中，哪些工具会被调用，以及背后会使用到了哪些参数。</p><p>针对这个 target ，虽然只有一个 <code>.pch</code> 文件，但实际上这里对 <code>objective-c-header</code> 文件的处理有两个任务。通过观察具体输出的 log 信息，我们可以知道详情：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">ProcessPCH /.../Pods-SSZipArchive-<span class="hljs-keyword">prefix</span>.pch.pch Pods-SSZipArchive-<span class="hljs-keyword">prefix</span>.pch normal armv<span class="hljs-number">7</span> objective-<span class="hljs-keyword">c</span> ...<br>ProcessPCH /.../Pods-SSZipArchive-<span class="hljs-keyword">prefix</span>.pch.pch Pods-SSZipArchive-<span class="hljs-keyword">prefix</span>.pch normal armv<span class="hljs-number">7</span>s objective-<span class="hljs-keyword">c</span> ...<br></code></pre></td></tr></table></figure><p>从上面的 log 信息中，可以明显的看出 target 针对两种架构做了 build – armv7 和 armv7s – 因此 clang 对文件做了两次处理，每次针对一种架构。</p><p>在处理预编译头文件之后，可以看到针对 SSZipArchive target 有另外的几个任务类型。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">CompileC</span></span> ...<br><span class="hljs-function"><span class="hljs-title">Libtool</span></span> ...<br><span class="hljs-function"><span class="hljs-title">CreateUniversalBinary</span></span> ...<br></code></pre></td></tr></table></figure><p>顾名思义：<code>CompileC</code> 用来编译 <code>.m</code> 和 <code>.c</code> 文件，<code>Libtool</code> 用来从目标文件中构建 library，而 <code>CreateUniversalBinary</code> 则将上一阶段产生的两个 <code>.a</code> 文件（每个文件对应一种架构）合并为一个通用的二进制文件，这样就能同时在 armv7 和 armv7s 上面运行。</p><p>接着，在工程中其它一些依赖项也会发生于此类似的步骤。AFNetworking 被编译之后，会与 SSZipArchive 进行链接，以当做 pod library。OpenSSL 编译之后，会接着处理 crypto 和 ssl target。</p><p>当所有的依赖项都 build 完成之后，就轮到我们程序的 target 了。Build 该 target 时，输出的 log 信息会包含一些非常有价值，并且之前没有出现过的内容：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">PhaseScriptExecution</span></span> ...<br><span class="hljs-function"><span class="hljs-title">DataModelVersionCompile</span></span> ...<br><span class="hljs-function"><span class="hljs-title">Ld</span></span> ...<br><span class="hljs-function"><span class="hljs-title">GenerateDSYMFile</span></span> ...<br><span class="hljs-function"><span class="hljs-title">CopyStringsFile</span></span> ...<br><span class="hljs-function"><span class="hljs-title">CpResource</span></span> ...<br><span class="hljs-function"><span class="hljs-title">CopyPNGFile</span></span> ...<br><span class="hljs-function"><span class="hljs-title">CompileAssetCatalog</span></span> ...<br><span class="hljs-function"><span class="hljs-title">ProcessInfoPlistFile</span></span> ...<br>ProcessProductPackaging /.../some-hash.mobileprovision ...<br>ProcessProductPackaging objcio/objcio.entitlements ...<br><span class="hljs-function"><span class="hljs-title">CodeSign</span></span> ...<br></code></pre></td></tr></table></figure><p>在上面的任务列表中，根据名称不能区分的唯一任务可能就是 <code>Ld</code>，<code>Ld</code> 是一个 linker 工具的名称，与 <code>libtool</code> 非常相似。实际上，<code>libtool</code>也是简单的调用 <code>ld</code> 和 <code>lipo</code>。’ld’被用来构建可执行文件，而<code>libtool</code>则用来构建 library 文件。阅读<a href="http://www.objccn.io/issue-6-3">Daniel</a> 和 <a href="http://www.objccn.io/issue-6-2">Chris</a>两篇文章，可以了解到更多关于编译和链接的工作原理。</p><p>上面每一个步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看到的的 <code>ProcessPCH</code> 类似。至此，我将不会继续介绍这些 log 信息了，我将带领大家从另外一个不同的角度来继续探索这些任务：Xcode 是如何知道哪些任务需要被执行？</p><h2 id="Build过程的控制"><a href="#Build过程的控制" class="headerlink" title="Build过程的控制"></a>Build过程的控制</h2><p>当你选择 Xcode 5 中的一个工程时，会在 project editor 顶部显示出 6 个 tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。</p><p><img src="https://objccn.io/images/issues/issue-6/project-editor-tabs.png" alt="Xcode project editor tabs"></p><p>对于我们理解 build 过程来说，其中最后 3 项与 build 过程紧密相连。</p><h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>Build Phases 代表着将代码转变为可执行文件的最高级别规则。里面描述了 build 过程中必须执行的不同类型规则。</p><p><img src="/" alt="Xcode build phases"></p><p><a href="https://objccn.io/images/issues/issue-6/build-phases.png">https://objccn.io/images/issues/issue-6/build-phases.png</a></p><p>首先是 target 依赖项的构建。这里会告诉 build 系统，build 当前的 target 之前，必须先对这里的依赖性进行 build。实际上这并不属于真正的 build phase，在这里，Xcode 只不过将其与 build phase 显示到一块罢了。</p><p>接着在 build phase中是一个 CocoaPods 相关的脚本 <em>script execution</em> – 更多 CocoaPods 相关信息和 它的 build 过程可以查看<a href="http://www.objc.io/issue-6-4">Michele的文章</a> – 接着在 <code>Compile Sources</code> section 中规定了所有必须参与编译的文件。需要留意的是，这里并没有指明这些文件是<em>如何</em>被编译处理的。关于处理这些文件的更多内容，我们将在研究 build rules 和 build settings 时学习到。此处列出的所有文件将根据相关的 rules 和 settings 被处理。</p><p>当编译结束之后，接下来就是将编译所生成的目标文件链接到一块。注意观察，Xcode 中的 build phase 之后是：”Link Binary with Libraries.” 这里面列出了所有的静态库和动态库，这些库会参与上面编译阶段生成的目标文件进行链接。静态库和动态库的处理过程有非常大的区别，相关内容请参考 Daniel的文章 <a href="http://www.objccn.io/issue-6-3">Mach-O 可执行文件</a>。</p><p>当链接完成之后，build phase 中最后需要处理的就是将静态资源（例如图片和字体）拷贝到 app bundle 中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化（如果 build settings 中的 PNG 优化是打开的话）。</p><p>虽然静态资源的拷贝是 build phase 中的最后一步，但 build 还没有完成。例如，还没有进行 code signing （这并不是 build phase 考虑的范畴），code signing 属于 build 步骤中的最后一步 “Packaging”。</p><h3 id="定制Build-Phases"><a href="#定制Build-Phases" class="headerlink" title="定制Build Phases"></a>定制Build Phases</h3><p>至此，如果不考虑默认设置的话，你已经可以完全掌握了上面介绍的 build phases。例如，你可以在 build phases 中添加运行自定义脚本，就像<a href="http://www.objccn.io/issue-6-4/">CocoaPods</a>使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到指定的 target 目录中，这非常有用。</p><p>另外定制 build phases 有一个非常好用的功能：添加带有水印（包括版本号和 commit hash）的 app icon – 只需要在 build phase 中添加一个 “Run Script”，并用下面的命令来获取版本号和 commit hash：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">version</span>=`/usr/libexec/PlistBuddy -c <span class="hljs-string">&quot;Print CFBundleVersion&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;INFOPLIST_FILE&#125;</span>&quot;</span>`<br><span class="hljs-attribute">commit</span>=`git rev-parse --short HEAD`<br></code></pre></td></tr></table></figure><p>然后使用 ImageMagick 来修改 app icon。这里有一个<a href="https://github.com/krzysztofzablocki/IconOverlaying">完整的示例</a>，可以参考。</p><p>如果你希望自己或者别人编写的代码看起来比较简洁点，可以添加一个 “Run Script”：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">find</span> <span class="hljs-string">&quot;$&#123;SRCROOT&#125;&quot;</span> \( -name <span class="hljs-string">&quot;*.h&quot;</span> -or -name <span class="hljs-string">&quot;*.m&quot;</span> \) -print0 | xargs -<span class="hljs-number">0</span> wc -l | awk &#x27;$<span class="hljs-number">1</span> &gt; <span class="hljs-number">200</span> &amp;&amp; $<span class="hljs-number">2</span> != <span class="hljs-string">&quot;total&quot;</span> &#123; print $<span class="hljs-number">2</span> <span class="hljs-string">&quot;:1: warning: file more than 200 lines&quot;</span> &#125;&#x27;<br></code></pre></td></tr></table></figure><h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>Build rules 指定了不同的文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定类型的文件添加处理方法，那么可以在此处添加一条新的规则。</p><p>一条 build rule 指定了其应用于哪种类型文件，该类型文件是如何被处理的，以及输出的内容该如何处置。比方说，我们创建了一条预处理规则，该规则将 Objective-C 的实现文件当做输入，解析文件中的注释内容，最后再输出一个 <code>.m</code> 文件，文件中包含了生成的代码。由于我们不能将 <code>.m</code> 文件既当做输入又当做输出，所以我使用了 <code>.mal</code> 后缀，定制的 build rule 如下所示：</p><p><img src="https://objccn.io/images/issues/issue-6/custom-build-rule.png" alt="Custom build rule"></p><p>上面的规则应用于所有后缀为 <code>*.mal</code> 的文件，这些文件会被自定义的脚本处理（调用我们的预处理器，并附带上输入和输出参数）。最后，该规则告诉 build system 在哪里可以找到此规则的输出文件。</p><p>在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a> 文档中可以找到所有可用的变量。build 过程中，要想观察所有已存在的环境变量，你可以在 build phase 中添加一个 “Run Script”，并勾选上 “Show environment variables in build log”。</p><h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>至此，我们已经了解到在 build phases 中是如何定义 build 处理的过程，以及 build rules 是如何指定哪些文件类型在编译阶段需要被预处理。在 build settings 中，我们可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。</p><p>你会发现 build 过程的每一个阶段，都有许多选项：从编译、链接一直到 code signing 和 packaging。注意，settings 是如何被分割为不同的部分 – 其实这大部分会与 build phases 有关联，有时候也会指定编译的文件类型。</p><p>这些选项基本都有很好的文档介绍，你可以在右边面板中的 quick help inspector 或者 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a>中查看到。</p><h2 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h2><p>上面我们介绍的所有内容都被保存在工程文件（<code>.pbxproj</code>）中，除了其它一些工程相关信息（例如 file groups），我们很少会深入该文件内部，除非在代码 merge 时发生冲突，或许会进去看看。</p><p>建议你用文本编辑器打开一个工程文件，从头到尾看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。</p><p>首先，我们来看看文件中叫做 <code>rootObject</code> 的条目。在我的工程中，如下所示：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">rootObject</span> <span class="hljs-operator">=</span> <span class="hljs-number">1793817</span>C17A9421F0078255E /* Project object */<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>根据这个 ID（<code>1793817C17A9421F0078255E</code>），我们可以找到 main 工程的定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* Begin PBXProject section */</span><br>    <span class="hljs-number">1793817</span>C17A9421F0078255E <span class="hljs-regexp">/* Project object */</span> = &#123;<br>        isa = PBXProject;<br>...<br></code></pre></td></tr></table></figure><p>在这部分中有一些 keys，顺从这些 key，我们可以了解到更多关于这个工程文件的组成。例如，<code>mainGroup</code> 指向了 root file group。如果你按照这个思路，你可以快速了解到在 <code>.pbxproj</code> 文件中工程的结构。下面我要来介绍一些与 build 过程相关的内容。其中 <code>target</code> key 指向了 build target 的定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">targets = (<br>    <span class="hljs-number">1793818317</span>A9421F0078255E <span class="hljs-regexp">/* objcio */</span>,<br>    <span class="hljs-number">170</span>E83CE17ABF256006E716E <span class="hljs-regexp">/* objcio Tests */</span>,<br>);<br></code></pre></td></tr></table></figure><p>根据第一个内容，我们找到一个 target 的定义：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1793818317</span>A9421F0078255E <span class="hljs-regexp">/* objcio */</span> = &#123;<br>    isa = PBXNativeTarget;<br>    buildConfigurationList = <span class="hljs-number">179381</span>B617A9421F0078255E <span class="hljs-regexp">/* Build configuration list for PBXNativeTarget &quot;objcio&quot; */</span>;<br>    buildPhases = (<br>        F3EB8576A1C24900A8F9CBB6 <span class="hljs-regexp">/* Check Pods Manifest.lock */</span>,<br>        <span class="hljs-number">1793818017</span>A9421F0078255E <span class="hljs-regexp">/* Sources */</span>,<br>        <span class="hljs-number">1793818117</span>A9421F0078255E <span class="hljs-regexp">/* Frameworks */</span>,<br>        <span class="hljs-number">1793818217</span>A9421F0078255E <span class="hljs-regexp">/* Resources */</span>,<br>        FF25BB7F4B7D4F87AC7A4265 <span class="hljs-regexp">/* Copy Pods Resources */</span>,<br>    );<br>    buildRules = (<br>    );<br>    dependencies = (<br>        <span class="hljs-number">1769</span>BED917CA8239008B6F5D <span class="hljs-regexp">/* PBXTargetDependency */</span>,<br>        <span class="hljs-number">1769</span>BED717CA8236008B6F5D <span class="hljs-regexp">/* PBXTargetDependency */</span>,<br>    );<br>    name = objcio;<br>    productName = objcio;<br>    productReference = <span class="hljs-number">1793818417</span>A9421F0078255E <span class="hljs-regexp">/* objcio.app */</span>;<br>    productType = <span class="hljs-string">&quot;com.apple.product-type.application&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>buildConfigurationList</code> 指向了可用的配置项，一般是 <code>Debug</code> 和 <code>Release</code>。根据 debug 对应的 id，我们可以找到 build setting tab 中所有选项存储的位置：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">179381</span>B717A9421F0078255E /* Debug */ <span class="hljs-operator">=</span> &#123;<br>    isa <span class="hljs-operator">=</span> XCBuildConfiguration<span class="hljs-comment">;</span><br>    baseConfigurationReference <span class="hljs-operator">=</span> <span class="hljs-number">05</span>D234D6F5E146E9937E8997 /* Pods.xcconfig */<span class="hljs-comment">;</span><br>    buildSettings <span class="hljs-operator">=</span> &#123;<br>        ALWAYS_SEARCH_USER_PATHS <span class="hljs-operator">=</span> YES<span class="hljs-comment">;</span><br>        ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME <span class="hljs-operator">=</span> LaunchImage<span class="hljs-comment">;</span><br>        CODE_SIGN_ENTITLEMENTS <span class="hljs-operator">=</span> objcio/objcio.entitlements<span class="hljs-comment">;</span><br>...<br></code></pre></td></tr></table></figure><p><code>buildPhases</code> 属性则简单的列出了在 Xcode 中定义的所有 build phases。这非常容易识别出来（Xcode 中的参数使用了它们原本真正的名字，并以 C 风格进行注释）。<code>buildRules</code> 属性是空的：因为在该工程中，我没有自定义 build rules。<code>dependencies</code> 列出了在 Xcode build phase tab 中列出的 target 依赖项。</p><p>没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着对象的 ID 走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同 section ，那么对于 merge 工程文件的冲突时，将变得非常简单。甚至可以在 GitHub 中就能阅读工程文件，而不用将工程文件 clone 到本地，并用 Xcode 打开。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当今的软件是都用其它复杂的一些软件和资源开发出来的，例如 library 和 build 工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。</p><p>本文所探索 build system 的内部机制犹如剥掉洋葱的一层。其实当我们点击 Xcode 中的运行按钮时，我们并没必要理解这个动作涉及到的所有内容。我们只是深入理解某一层，然后找到一个有组织的、并且可控的调用其它工具的顺序，如果我们愿意的话，可以做进一步的探索。我建议你阅读本期中的其它文章，以进一步了解这个洋葱的下一层内容！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello Worlds</title>
    <link href="/2017/09/23/hello-world/"/>
    <url>/2017/09/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译器做些什么？</title>
    <link href="/2017/04/23/clang/"/>
    <url>/2017/04/23/clang/</url>
    
    <content type="html"><![CDATA[<h2 id="编译器做些什么？"><a href="#编译器做些什么？" class="headerlink" title="编译器做些什么？"></a>编译器做些什么？</h2><p>本文主要探讨一下编译器主要做些什么，以及如何有效的利用编译器。</p><p>简单的说，编译器有两个职责：把 Objective-C 代码转化成低级代码，以及对代码做分析，确保代码中没有任何明显的错误。</p><p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。</p><span id="more"></span>1<p>LLVM 指令的一个好处就是可以在支持 LLVM 的任意平台上生成和运行 LLVM 指令。例如，你写的一个 iOS app, 它可以自动的运行在两个完全不同的架构(Inter 和 ARM)上，LLVM 会根据不同的平台将 IR 码转换为对应的本地字节码。</p><p>LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 <em>The Architecture of Open Source Applications</em> 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于 <a href="http://www.aosabook.org/en/llvm.html">LLVM 架构</a>。</p><p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 <em>hello.m</em> 源文件需要几个不同的阶段，我们可以让通过 clang 命令观察：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">% clang -ccc-print-phases hello<span class="hljs-selector-class">.m</span><br><br><span class="hljs-number">0</span>: input, <span class="hljs-string">&quot;hello.m&quot;</span>, objective-c<br><span class="hljs-number">1</span>: preprocessor, &#123;<span class="hljs-number">0</span>&#125;, objective-c-cpp-output<br><span class="hljs-number">2</span>: compiler, &#123;<span class="hljs-number">1</span>&#125;, assembler<br><span class="hljs-number">3</span>: assembler, &#123;<span class="hljs-number">2</span>&#125;, <span class="hljs-selector-tag">object</span><br><span class="hljs-number">4</span>: linker, &#123;<span class="hljs-number">3</span>&#125;, image<br><span class="hljs-number">5</span>: bind-arch, <span class="hljs-string">&quot;x86_64&quot;</span>, &#123;<span class="hljs-number">4</span>&#125;, image<br></code></pre></td></tr></table></figure><p>本文我们将重点关注第一阶段和第二阶段。在文章 <a href="http://objccn.io/issue-6-3/">Mach-O Executables</a> 中，Daniel 会对第三阶段和第四阶段进行阐述。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>每当编源译文件的时候，编译器首先做的是一些预处理工作。比如预处理器会处理源文件中的宏定义，将代码中的宏用其对应定义的具体内容进行替换。</p><p>例如，如果在源文件中出现下述代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。</p><p>这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多。例如，在头文件中用：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">@<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>;<br></code></pre></td></tr></table></figure><p>代替：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;MyClass.h&quot;</span><br></code></pre></td></tr></table></figure><p>这么写是告诉编译器 MyClass 是一个类，并且在 .m 实现文件中可以通过 import <code>MyClass.h</code> 的方式来使用它。</p><p>假设我们写了一个简单的 C 程序 <code>hello.c</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后给上面的代码执行以下预处理命令，看看是什么效果：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">clang -E hello.c <span class="hljs-string">| less</span><br></code></pre></td></tr></table></figure><p>接下来看看处理后的代码，一共是 401 行。如果将如下一行代码添加到上面代码的顶部：：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>再执行一下上面的预处理命令，处理后的文件代码行数暴增至 89,839 行。这个数字比某些操作系统的总代码行数还要多。</p><p>幸好，目前的情况已经改善许多了：引入了<a href="http://clang.llvm.org/docs/Modules.html">模块 - modules</a>功能，这使预处理变得更加的高级。</p><h4 id="自定义宏"><a href="#自定义宏" class="headerlink" title="自定义宏"></a>自定义宏</h4><p>我们来看看另外一种情形定义或者使用自定义宏，比如定义了如下宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MY_CONSTANT 4</span><br></code></pre></td></tr></table></figure><p>那么，凡是在此行宏定义作用域内，输入了 <code>MY_CONSTANT</code>，在预处理过程中 <code>MY_CONSTANT</code> 都会被替换成 <code>4</code>。我们定义的宏也是可以携带参数的， 比如：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">#<span class="hljs-keyword">define</span> MY_MACRO(<span class="hljs-keyword">x</span>) <span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure><p>鉴于本文的内容所限，就不对强大的预处理做更多、更全面的展开讨论了。但是还是要强调一点，建议大家不要在需要预处理的代码中加入内联代码逻辑。</p><p>例如，下面这段代码，这样用没什么问题：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-id">#define</span> <span class="hljs-selector-tag">MAX</span>(a,b) <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span> ? <span class="hljs-selector-tag">a</span> : <span class="hljs-selector-tag">b</span><br><br><span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">main</span>() &#123;<br>  <span class="hljs-selector-tag">printf</span>(<span class="hljs-string">&quot;largest: %d\n&quot;</span>, <span class="hljs-built_in">MAX</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>));<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果换成这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a,b) a &gt; b ? a : b</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">200</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;largest: %d\n&quot;</span>, <span class="hljs-built_in">MAX</span>(i++,<span class="hljs-number">100</span>));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i: %d\n&quot;</span>, i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用 <code>clang max.c</code> 编译一下，结果是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">largest</span>: <span class="hljs-number">201</span><br><span class="hljs-attribute">i</span>: <span class="hljs-number">202</span><br></code></pre></td></tr></table></figure><p>用 <code>clang -E max.c</code> 进行宏展开的预处理结果是如下所示：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> main() &#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">200</span>;<br>  <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;largest: %d\n&quot;</span>, i++ &gt; <span class="hljs-number">100</span> ? i++ : <span class="hljs-number">100</span>);<br>  <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;i: %d\n&quot;</span>, i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例是典型的宏使用不当，而且通常这类问题非常隐蔽且难以 debug 。针对本例这类情况，最好使用 <code>static inline</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MyConstant = <span class="hljs-number">200</span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> l &gt; r ? l : r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> i = MyConstant;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;largest: %d\n&quot;</span>, <span class="hljs-built_in">max</span>(i++,<span class="hljs-number">100</span>));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i: %d\n&quot;</span>, i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样改过之后，就可以输出正常的结果 (<code>i:201</code>)。因为这里定义的代码是内联的 (inlined)，所以它的效率和宏变量差不多，但是可靠性比宏定义要好许多。再者，还可以设置断点、类型检查以及避免异常行为。</p><p>基本上，宏的最佳使用场景是日志输出，可以使用 <code>__FILE__</code> 和 <code>__LINE__</code> 和 assert 宏。</p><h3 id="词法解析标记"><a href="#词法解析标记" class="headerlink" title="词法解析标记"></a>词法解析标记</h3><p>预处理完成以后，每一个 <code>.m</code> 源文件里都有一堆的声明和定义。这些代码文本都会从 string 转化成特殊的标记流。</p><p>例如，下面是一段简单的 Objective-C hello word 程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>  NSLog(<span class="hljs-string">@&quot;hello, %@&quot;</span>, <span class="hljs-string">@&quot;world&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用 clang 命令 <code>clang -Xclang -dump-tokens hello.m</code> 来将上面代码的标记流导出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-string">&#x27;int&#x27;</span>        [StartOfLine]  <span class="hljs-attribute">Loc</span>=&lt;hello.m:4:1&gt;<br>identifier <span class="hljs-string">&#x27;main&#x27;</span>        [LeadingSpace] <span class="hljs-attribute">Loc</span>=&lt;hello.m:4:5&gt;<br>l_paren <span class="hljs-string">&#x27;(&#x27;</span>             <span class="hljs-attribute">Loc</span>=&lt;hello.m:4:9&gt;<br>r_paren <span class="hljs-string">&#x27;)&#x27;</span>             <span class="hljs-attribute">Loc</span>=&lt;hello.m:4:10&gt;<br>l_brace <span class="hljs-string">&#x27;&#123;&#x27;</span>      [LeadingSpace] <span class="hljs-attribute">Loc</span>=&lt;hello.m:4:12&gt;<br>identifier <span class="hljs-string">&#x27;NSLog&#x27;</span>       [StartOfLine] [LeadingSpace]   <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:3&gt;<br>l_paren <span class="hljs-string">&#x27;(&#x27;</span>             <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:8&gt;<br>at <span class="hljs-string">&#x27;@&#x27;</span>          <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:9&gt;<br>string_literal <span class="hljs-string">&#x27;&quot;hello, %@&quot;&#x27;</span>            <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:10&gt;<br>comma <span class="hljs-string">&#x27;,&#x27;</span>               <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:21&gt;<br>at <span class="hljs-string">&#x27;@&#x27;</span>   [LeadingSpace] <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:23&gt;<br>string_literal <span class="hljs-string">&#x27;&quot;world&quot;&#x27;</span>                <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:24&gt;<br>r_paren <span class="hljs-string">&#x27;)&#x27;</span>             <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:31&gt;<br>semi <span class="hljs-string">&#x27;;&#x27;</span>                <span class="hljs-attribute">Loc</span>=&lt;hello.m:5:32&gt;<br>return <span class="hljs-string">&#x27;return&#x27;</span>  [StartOfLine] [LeadingSpace]   <span class="hljs-attribute">Loc</span>=&lt;hello.m:6:3&gt;<br>numeric_constant <span class="hljs-string">&#x27;0&#x27;</span>     [LeadingSpace] <span class="hljs-attribute">Loc</span>=&lt;hello.m:6:10&gt;<br>semi <span class="hljs-string">&#x27;;&#x27;</span>                <span class="hljs-attribute">Loc</span>=&lt;hello.m:6:11&gt;<br>r_brace <span class="hljs-string">&#x27;&#125;&#x27;</span>      [StartOfLine]  <span class="hljs-attribute">Loc</span>=&lt;hello.m:7:1&gt;<br>eof <span class="hljs-string">&#x27;&#x27;</span>          <span class="hljs-attribute">Loc</span>=&lt;hello.m:7:2&gt;<br></code></pre></td></tr></table></figure><p>仔细观察可以发现，每一个标记都包含了对应的源码内容和其在源码中的位置。注意这里的位置是宏展开之前的位置，这样一来，如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>接下来要说的东西比较有意思：之前生成的标记流将会被解析成一棵抽象语法树 (abstract syntax tree – AST)。由于 Objective-C 是一门复杂的语言，因此解析的过程不简单。解析过后，源程序变成了一棵抽象语法树：一棵代表源程序的树。假设我们有一个程序 <code>hello.m</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">World</span></span><br>- (<span class="hljs-type">void</span>)hello;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">World</span></span><br>- (<span class="hljs-type">void</span>)hello &#123;<br>  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;hello, world&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-type">int</span> main() &#123;<br>   World* world = [World new];<br>   [world hello];<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们执行 clang 命令 <code>clang -Xclang -ast-dump -fsyntax-only hello.m</code> 之后，命令行中输出的结果如下所示：：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> World- (void) hello;<br><span class="hljs-variable">@end</span><br><span class="hljs-variable">@implementation</span> World<br>- (void) hello (CompoundStmt <span class="hljs-number">0</span>x10372ded0 &lt;hello.<span class="hljs-attribute">m</span>:<span class="hljs-number">8</span>:<span class="hljs-number">15</span>, <span class="hljs-attribute">line</span>:<span class="hljs-number">10</span>:<span class="hljs-number">1</span>&gt;<br>  (CallExpr <span class="hljs-number">0</span>x10372dea0 &lt;<span class="hljs-attribute">line</span>:<span class="hljs-number">9</span>:<span class="hljs-number">3</span>, <span class="hljs-attribute">col</span>:<span class="hljs-number">24</span>&gt; <span class="hljs-string">&#x27;void&#x27;</span><br>    (ImplicitCastExpr <span class="hljs-number">0</span>x10372de88 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">3</span>&gt; <span class="hljs-string">&#x27;void (*)(NSString *, ...)&#x27;</span> &lt;FunctionToPointerDecay&gt;<br>      (DeclRefExpr <span class="hljs-number">0</span>x10372ddd8 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">3</span>&gt; <span class="hljs-string">&#x27;void (NSString *, ...)&#x27;</span> Function <span class="hljs-number">0</span>x1023510d0 <span class="hljs-string">&#x27;NSLog&#x27;</span> <span class="hljs-string">&#x27;void (NSString *, ...)&#x27;</span>))<br>    (ObjCStringLiteral <span class="hljs-number">0</span>x10372de38 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">9</span>, <span class="hljs-attribute">col</span>:<span class="hljs-number">10</span>&gt; <span class="hljs-string">&#x27;NSString *&#x27;</span><br>      (StringLiteral <span class="hljs-number">0</span>x10372de00 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">10</span>&gt; <span class="hljs-string">&#x27;char [13]&#x27;</span> lvalue <span class="hljs-string">&quot;hello, world&quot;</span>))))<br><br><br><span class="hljs-variable">@end</span><br>int <span class="hljs-built_in">main</span>() (CompoundStmt <span class="hljs-number">0</span>x10372e118 &lt;hello.<span class="hljs-attribute">m</span>:<span class="hljs-number">13</span>:<span class="hljs-number">12</span>, <span class="hljs-attribute">line</span>:<span class="hljs-number">16</span>:<span class="hljs-number">1</span>&gt;<br>  (DeclStmt <span class="hljs-number">0</span>x10372e090 &lt;<span class="hljs-attribute">line</span>:<span class="hljs-number">14</span>:<span class="hljs-number">4</span>, <span class="hljs-attribute">col</span>:<span class="hljs-number">30</span>&gt;<br>    <span class="hljs-number">0</span>x10372dfe0 &quot;World *world =<br>      (ImplicitCastExpr <span class="hljs-number">0</span>x10372e078 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">19</span>, <span class="hljs-attribute">col</span>:<span class="hljs-number">29</span>&gt; <span class="hljs-string">&#x27;World *&#x27;</span> &lt;BitCast&gt;<br>        (ObjCMessageExpr <span class="hljs-number">0</span>x10372e048 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">19</span>, <span class="hljs-attribute">col</span>:<span class="hljs-number">29</span>&gt; <span class="hljs-string">&#x27;id&#x27;</span>:<span class="hljs-string">&#x27;id&#x27;</span> selector=new class=<span class="hljs-string">&#x27;World&#x27;</span>))&quot;)<br>  (ObjCMessageExpr <span class="hljs-number">0</span>x10372e0e8 &lt;<span class="hljs-attribute">line</span>:<span class="hljs-number">15</span>:<span class="hljs-number">4</span>, <span class="hljs-attribute">col</span>:<span class="hljs-number">16</span>&gt; <span class="hljs-string">&#x27;void&#x27;</span> selector=hello<br>    (ImplicitCastExpr <span class="hljs-number">0</span>x10372e0d0 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">5</span>&gt; <span class="hljs-string">&#x27;World *&#x27;</span> &lt;LValueToRValue&gt;<br>      (DeclRefExpr <span class="hljs-number">0</span>x10372e0a8 &lt;<span class="hljs-attribute">col</span>:<span class="hljs-number">5</span>&gt; <span class="hljs-string">&#x27;World *&#x27;</span> lvalue Var <span class="hljs-number">0</span>x10372dfe0 <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-string">&#x27;World *&#x27;</span>))))<br></code></pre></td></tr></table></figure><p>在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p><h5 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h5><ul><li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">clang AST 介绍</a></li></ul><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>每当开发人员编写代码的时候，clang 都会帮忙检查错误。其中最常见的就是检查程序是否发送正确的消息给正确的对象，是否在正确的值上调用了正确的函数。如果你给一个单纯的 <code>NSObject*</code> 对象发送了一个 <code>hello</code> 消息，那么 clang 就会报错。同样，如果你创建了 <code>NSObject</code> 的一个子类 <code>Test</code>, 如下所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Test </span>: NSObject<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p>然后试图给这个子类中某个属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。</p><p>一般会把类型分为两类：动态的和静态的。动态的在运行时做检查，静态的在编译时做检查。以往，编写代码时可以向任意对象发送任何消息，在运行时，才会检查对象是否能够响应这些消息。由于只是在运行时做此类检查，所以叫做动态类型。</p><p>至于静态类型，是在编译时做检查。当在代码中使用 ARC 时，编译器在编译期间，会做许多的类型检查：因为编译器需要知道哪个对象该如何使用。例如，如果 myObject 没有 hello 方法，那么就不能写如下这行代码了：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[myObject hello]</span><br></code></pre></td></tr></table></figure><h4 id="其他分析"><a href="#其他分析" class="headerlink" title="其他分析"></a>其他分析</h4><p>clang 在静态分析阶段，除了类型检查外，还会做许多其它一些分析。如果你把 clang 的代码仓库 clone 到本地，然后进入目录 <code>lib/StaticAnalyzer/Checkers</code>，你会看到所有静态检查内容。比如 <code>ObjCUnusedIVarsChecker.cpp</code> 是用来检查是否有定义了，但是从未使用过的变量。而 <code>ObjCSelfInitChecker.cpp</code> 则是检查在 你的初始化方法中中调用 <code>self</code> 之前，是否已经调用 <code>[self initWith...]</code> 或 <code>[super init]</code> 了。编译器还进行了一些其它的检查，例如在 <code>lib/Sema/SemaExprObjC.cpp</code> 的 2,534 行，有这样一句：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Diag(SelLoc, <span class="hljs-params">diag</span>::<span class="hljs-params">warn_arc_perform_selector_leaks</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个会生成严重错误的警告 “performSelector may cause a leak because its selector is unknown” 。</p><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看<code>hello.c</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">clang -O<span class="hljs-number">3</span> -emit-LLVM hello.<span class="hljs-keyword">c</span> -<span class="hljs-keyword">c</span> -o hello.bc<br></code></pre></td></tr></table></figure><p>接着用另一个命令来查看刚刚生成的二进制文件：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">llvm-dis </span>&lt; hello.<span class="hljs-keyword">bc </span><span class="hljs-title">| less</span><br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-comment">; ModuleID = &#x27;&lt;stdin&gt;&#x27;</span><br><span class="hljs-keyword">target</span> <span class="hljs-keyword">datalayout</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128&quot;</span><br><span class="hljs-keyword">target</span> <span class="hljs-keyword">triple</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;x86_64-apple-macosx10.8.0&quot;</span><br><br><span class="hljs-title">@str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">unnamed_addr</span> <span class="hljs-keyword">constant</span> [<span class="hljs-number">12</span> <span class="hljs-keyword">x</span> <span class="hljs-type">i8</span>] <span class="hljs-keyword">c</span><span class="hljs-string">&quot;hello world<span class="hljs-char escape_">\00</span>&quot;</span><br><br><span class="hljs-comment">; Function Attrs: nounwind ssp uwtable</span><br><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@main</span>() <span class="hljs-variable">#0</span> &#123;<br>  <span class="hljs-variable">%puts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">tail</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i32</span> <span class="hljs-title">@puts</span>(<span class="hljs-type">i8</span>* <span class="hljs-keyword">getelementptr</span> <span class="hljs-keyword">inbounds</span> ([<span class="hljs-number">12</span> <span class="hljs-keyword">x</span> <span class="hljs-type">i8</span>]* <span class="hljs-title">@str</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i64</span> <span class="hljs-number">0</span>))<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">; Function Attrs: nounwind</span><br><span class="hljs-keyword">declare</span> <span class="hljs-type">i32</span> <span class="hljs-title">@puts</span>(<span class="hljs-type">i8</span>* <span class="hljs-keyword">nocapture</span>) <span class="hljs-variable">#1</span><br><br><span class="hljs-keyword">attributes</span> <span class="hljs-variable">#0</span> <span class="hljs-operator">=</span> &#123; <span class="hljs-keyword">nounwind</span> <span class="hljs-keyword">ssp</span> <span class="hljs-keyword">uwtable</span> &#125;<br><span class="hljs-keyword">attributes</span> <span class="hljs-variable">#1</span> <span class="hljs-operator">=</span> &#123; <span class="hljs-keyword">nounwind</span> &#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，可以看到 <code>main</code> 函数只有两行代码：一行输出string，另一行返回 <code>0</code>。</p><p>再换一个程序，拿 <code>five.m</code> 为例，对其做相同的编译，然后执行 <code>LLVM-dis &lt; five.bc | less</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>, [@<span class="hljs-number">5</span> description]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抛开其他的不说，单看 <code>main</code> 函数：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@main</span>() <span class="hljs-variable">#0</span> &#123;<br>  <span class="hljs-variable">%1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-variable">%struct._class_t</span>** @<span class="hljs-string">&quot;<span class="hljs-char escape_">\01</span>L_OBJC_CLASSLIST_REFERENCES_$_&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">8</span><br>  <span class="hljs-variable">%2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i8</span>** @<span class="hljs-string">&quot;<span class="hljs-char escape_">\01</span>L_OBJC_SELECTOR_REFERENCES_&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span> <span class="hljs-title">!invariant.load</span> <span class="hljs-title">!4</span><br>  <span class="hljs-variable">%3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">bitcast</span> <span class="hljs-variable">%struct._class_t</span>* <span class="hljs-variable">%1</span> <span class="hljs-keyword">to</span> <span class="hljs-type">i8</span>*<br>  <span class="hljs-variable">%4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">tail</span> <span class="hljs-keyword">call</span> <span class="hljs-variable">%0</span>* <span class="hljs-keyword">bitcast</span> (<span class="hljs-type">i8</span>* (<span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> ...)* <span class="hljs-title">@objc_msgSend</span> <span class="hljs-keyword">to</span> <span class="hljs-variable">%0</span>* (<span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>)*)(<span class="hljs-type">i8</span>* <span class="hljs-variable">%3</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>* <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span> <span class="hljs-number">5</span>)<br>  <span class="hljs-variable">%5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i8</span>** @<span class="hljs-string">&quot;<span class="hljs-char escape_">\01</span>L_OBJC_SELECTOR_REFERENCES_2&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">8</span><span class="hljs-punctuation">,</span> <span class="hljs-title">!invariant.load</span> <span class="hljs-title">!4</span><br>  <span class="hljs-variable">%6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">bitcast</span> <span class="hljs-variable">%0</span>* <span class="hljs-variable">%4</span> <span class="hljs-keyword">to</span> <span class="hljs-type">i8</span>*<br>  <span class="hljs-variable">%7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">tail</span> <span class="hljs-keyword">call</span> <span class="hljs-variable">%1</span>* <span class="hljs-keyword">bitcast</span> (<span class="hljs-type">i8</span>* (<span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> ...)* <span class="hljs-title">@objc_msgSend</span> <span class="hljs-keyword">to</span> <span class="hljs-variable">%1</span>* (<span class="hljs-type">i8</span>*<span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>*)*)(<span class="hljs-type">i8</span>* <span class="hljs-variable">%6</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i8</span>* <span class="hljs-variable">%5</span>)<br>  <span class="hljs-keyword">tail</span> <span class="hljs-keyword">call</span> void (<span class="hljs-variable">%1</span>*<span class="hljs-punctuation">,</span> ...)* <span class="hljs-title">@NSLog</span>(<span class="hljs-variable">%1</span>* <span class="hljs-keyword">bitcast</span> (<span class="hljs-variable">%struct.NSConstantString</span>* <span class="hljs-title">@_unnamed_cfstring_</span> <span class="hljs-keyword">to</span> <span class="hljs-variable">%1</span>*)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%1</span>* <span class="hljs-variable">%7</span>)<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中最重要的是第 4 行，它创建了一个 <code>NSNumber</code> 对象。第 7 行，给这个 number 对象发送了一个<code>description</code> 消息。第 8 行，将 <code>description</code> 消息返回的内容打印出来。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>要想了解 LLVM 的优化内容，以及 clang 能做哪些优化，我们先看一个略微复杂的 C 程序：这个函数主要是递归计算 <code>阶乘</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">factorial</span>(x<span class="hljs-number">-1</span>);<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;factorial 10: %d\n&quot;</span>, <span class="hljs-built_in">factorial</span>(<span class="hljs-number">10</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看不做优化的编译情况，执行下面命令：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clang -O0 -emit-llvm <span class="hljs-built_in">factorial</span>.c  -c -o <span class="hljs-built_in">factorial</span>.bc &amp;&amp; llvm-dis &lt; <span class="hljs-built_in">factorial</span>.bc<br></code></pre></td></tr></table></figure><p>重点看一下针对 <code>阶乘</code> 部分生成的代码：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@factorial</span>(<span class="hljs-type">i32</span> <span class="hljs-variable">%x</span>) <span class="hljs-variable">#0</span> &#123;<br>  <span class="hljs-variable">%1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">4</span><br>  <span class="hljs-variable">%2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">alloca</span> <span class="hljs-type">i32</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">4</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">4</span><br>  <span class="hljs-variable">%3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">4</span><br>  <span class="hljs-variable">%4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">sgt</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%3</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%4</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%5</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%11</span><br><br><span class="hljs-comment">; &lt;label&gt;:5                                       ; preds = %0</span><br>  <span class="hljs-variable">%6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">4</span><br>  <span class="hljs-variable">%7</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">align</span> <span class="hljs-number">4</span><br>  <span class="hljs-variable">%8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">sub</span> <span class="hljs-keyword">nsw</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%7</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><br>  <span class="hljs-variable">%9</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">call</span> <span class="hljs-type">i32</span> <span class="hljs-title">@factorial</span>(<span class="hljs-type">i32</span> <span class="hljs-variable">%8</span>)<br>  <span class="hljs-variable">%10</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-keyword">nsw</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%6</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%9</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%10</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%1</span><br>  <span class="hljs-keyword">br</span> label <span class="hljs-variable">%12</span><br><br><span class="hljs-comment">; &lt;label&gt;:11                                      ; preds = %0</span><br>  <span class="hljs-keyword">store</span> <span class="hljs-type">i32</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%1</span><br>  <span class="hljs-keyword">br</span> label <span class="hljs-variable">%12</span><br><br><span class="hljs-comment">; &lt;label&gt;:12                                      ; preds = %11, %5</span><br>  <span class="hljs-variable">%13</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">load</span> <span class="hljs-type">i32</span>* <span class="hljs-variable">%1</span><br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%13</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看一下 <code>%9</code> 标注的那一行，这行代码正是递归调用阶乘函数本身，实际上这样调用是非常低效的，因为每次递归调用都要重新压栈。接下来可以看一下优化后的效果，可以通过这样的方式开启优化 – 将 <code>-03</code> 标志传给 clang：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clang -O3 -emit-llvm <span class="hljs-built_in">factorial</span>.c  -c -o <span class="hljs-built_in">factorial</span>.bc &amp;&amp; llvm-dis &lt; <span class="hljs-built_in">factorial</span>.bc<br></code></pre></td></tr></table></figure><p>现在 <code>阶乘</code> 计算相关代码编译后生成的代码如下：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">define</span> <span class="hljs-type">i32</span> <span class="hljs-title">@factorial</span>(<span class="hljs-type">i32</span> <span class="hljs-variable">%x</span>) <span class="hljs-variable">#0</span> &#123;<br>  <span class="hljs-variable">%1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">sgt</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%1</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%tailrecurse</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%tailrecurse._crit_edge</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">tailrecurse:</span>                                      <span class="hljs-comment">; preds = %tailrecurse, %0</span><br>  <span class="hljs-variable">%x.tr2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">phi</span> <span class="hljs-type">i32</span> [ <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%tailrecurse</span> ]<span class="hljs-punctuation">,</span> [ <span class="hljs-variable">%x</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%0</span> ]<br>  <span class="hljs-variable">%accumulator.tr1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">phi</span> <span class="hljs-type">i32</span> [ <span class="hljs-variable">%3</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%tailrecurse</span> ]<span class="hljs-punctuation">,</span> [ <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%0</span> ]<br>  <span class="hljs-variable">%2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">nsw</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%x.tr2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-1</span><br>  <span class="hljs-variable">%3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">mul</span> <span class="hljs-keyword">nsw</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%x.tr2</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%accumulator.tr1</span><br>  <span class="hljs-variable">%4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">icmp</span> <span class="hljs-keyword">sgt</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">br</span> <span class="hljs-type">i1</span> <span class="hljs-variable">%4</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%tailrecurse</span><span class="hljs-punctuation">,</span> label <span class="hljs-variable">%tailrecurse._crit_edge</span><br><br>tailrecurse._crit_edge:                           <span class="hljs-comment">; preds = %tailrecurse, %0</span><br>  <span class="hljs-variable">%accumulator.tr.lcssa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">phi</span> <span class="hljs-type">i32</span> [ <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%0</span> ]<span class="hljs-punctuation">,</span> [ <span class="hljs-variable">%3</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%tailrecurse</span> ]<br>  <span class="hljs-keyword">ret</span> <span class="hljs-type">i32</span> <span class="hljs-variable">%accumulator.tr.lcssa</span><br>&#125;<br></code></pre></td></tr></table></figure><p>即便我们的函数并没有按照<a href="http://en.wikipedia.org/wiki/Tail_call">尾递归</a>的方式编写，clang 仍然能对其做优化处理，让该函数编译的结果中只包含一个循环。当然 clang 能对代码进行的优化还有很多方面。可以看以下这个比较不错的 gcc 的优化例子<a href="http://ridiculousfish.com/blog/posts/will-it-optimize.html">ridiculousfish.com</a>。</p><p><strong>延伸阅读</strong></p><ul><li><a href="http://blog.llvm.org/search/label/optimization">LLVM blog: posts tagged ‘optimization’</a></li><li><a href="http://blog.llvm.org/2013/05/llvm-33-vectorization-improvements.html">LLVM blog: vectorization improvements</a></li><li><a href="http://blog.llvm.org/2011/09/greedy-register-allocation-in-llvm-30.html">LLVM blog: greedy register allocation</a></li><li><a href="http://polly.llvm.org/index.html">The Polly project</a></li></ul><h2 id="如何在实际中应用这些特性"><a href="#如何在实际中应用这些特性" class="headerlink" title="如何在实际中应用这些特性"></a>如何在实际中应用这些特性</h2><p>刚刚我们探讨了编译的全过程，从标记到解析，从抽象语法树到分析检查，再到汇编。读者不禁要问，为什么要关注这些？</p><h3 id="使用-libclan-g或-clang-插件"><a href="#使用-libclan-g或-clang-插件" class="headerlink" title="使用 libclan g或 clang 插件"></a>使用 libclan g或 clang 插件</h3><p>之所以 clang 很酷：是因为它是一个开源的项目、并且它是一个非常好的工程：几乎可以说全身是宝。使用者可以创建自己的 clang 版本，针对自己的需求对其进行改造。比如说，可以改变 clang 生成代码的方式，增加更强的类型检查，或者按照自己的定义进行代码的检查分析等等。要想达成以上的目标，有很多种方法，其中最简单的就是使用一个名为 <a href="http://clang.llvm.org/doxygen/group__CINDEX.html">libclang</a> 的C类库。libclang 提供的 API 非常简单，可以对 C 和 clang 做桥接，并可以用它对所有的源码做分析处理。不过，根据我的经验，如果使用者的需求更高，那么 libclang 就不怎么行了。针对这种情况，推荐使用 <a href="https://github.com/macmade/ClangKit">Clangkit</a>，它是基于 clang 提供的功能，用 Objective-C 进行封装的一个库。</p><p>最后，clang 还提供了一个直接使用 LibTooling 的 C++ 类库。这里要做的事儿比较多，而且涉及到 C++，但是它能够发挥 clang 的强大功能。用它你可以对源码做任意类型的分析，甚至重写程序。如果你想要给 clang 添加一些自定义的分析、创建自己的重构器 (refactorer)、或者需要基于现有代码做出大量修改，甚至想要基于工程生成相关图形或者文档，那么 LibTooling 是很好的选择。</p><h3 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h3><p>开发者可以按照 <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html">Tutorial for building tools using LibTooling</a> 中的说明去构造 LLVM ，clang 以及 clan g的附加工具。需要注意的是，编译代码是需要花费一些时间的，即时机器已经很快了，但是在编译期间，我还是可以吃顿饭的。</p><p>接下来，进入到 LLVM 目录，然后执行命令<code>cd ~/llvm/tools/clang/tools/</code>。在这个目录中，可以创建自己独立的 clang 工具。例如，我们创建一个小工具，用来检查某个库是否正确使用。首先将 <a href="https://github.com/objcio/issue6-compiler-tool">样例工程</a> 克隆到本地，然后输入 <code>make</code>。这样就会生成一个名为 <code>example</code> 的二进制文件。</p><p>我们的使用场景是：假如有一个 <code>Observer</code> 类, 代码如下所示：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">@interface <span class="hljs-type">Observer</span><br>+ (instance<span class="hljs-keyword">type</span>)observerWithTarget:(id)target action:(<span class="hljs-type">SEL</span>)selector;<br>@end<br></code></pre></td></tr></table></figure><p>接下来，我们想要检查一下每当这个类被调用的时候，在 <code>target</code> 对象中是否都有对应的 <code>action</code> 方法存在。可以写个 C++ 函数来做这件事（注意，这是我第一次写 C++ 程序，可能不那么严谨）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-constructor">VisitObjCMessageExpr(ObjCMessageExpr <span class="hljs-operator">*</span>E)</span> &#123;<br>  <span class="hljs-keyword">if</span> (E-&gt;get<span class="hljs-constructor">ReceiverKind()</span><span class="hljs-operator"> == </span>ObjCMessageExpr::Class) &#123;<br>    QualType ReceiverType = E-&gt;get<span class="hljs-constructor">ClassReceiver()</span>;<br>    Selector Sel = E-&gt;get<span class="hljs-constructor">Selector()</span>;<br>    <span class="hljs-built_in">string</span> TypeName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReceiverType</span>.</span></span>get<span class="hljs-constructor">AsString()</span>;<br>    <span class="hljs-built_in">string</span> SelName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Sel</span>.</span></span>get<span class="hljs-constructor">AsString()</span>;<br>    <span class="hljs-keyword">if</span> (TypeName<span class="hljs-operator"> == </span><span class="hljs-string">&quot;Observer&quot;</span><span class="hljs-operator"> &amp;&amp; </span>SelName<span class="hljs-operator"> == </span><span class="hljs-string">&quot;observerWithTarget:action:&quot;</span>) &#123;<br>      Expr *Receiver = E-&gt;get<span class="hljs-constructor">Arg(0)</span>-&gt;<span class="hljs-constructor">IgnoreParenCasts()</span>;<br>      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;get<span class="hljs-constructor">Arg(1)</span>-&gt;<span class="hljs-constructor">IgnoreParenCasts()</span>);<br>      Selector Sel = SelExpr-&gt;get<span class="hljs-constructor">Selector()</span>;<br>      <span class="hljs-keyword">if</span> (const ObjCObjectPointerType *OT = Receiver-&gt;get<span class="hljs-constructor">Type()</span>-&gt;getAs&lt;ObjCObjectPointerType&gt;<span class="hljs-literal">()</span>) &#123;<br>        ObjCInterfaceDecl *decl = OT-&gt;get<span class="hljs-constructor">InterfaceDecl()</span>;<br>        <span class="hljs-keyword">if</span> (! decl-&gt;lookup<span class="hljs-constructor">InstanceMethod(Sel)</span>) &#123;<br>          errs<span class="hljs-literal">()</span> &lt;&lt; <span class="hljs-string">&quot;Warning: class &quot;</span> &lt;&lt; TypeName &lt;&lt; <span class="hljs-string">&quot; does not implement selector &quot;</span> &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Sel</span>.</span></span>get<span class="hljs-constructor">AsString()</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>          SourceLocation Loc = E-&gt;get<span class="hljs-constructor">ExprLoc()</span>;<br>          PresumedLoc PLoc = astContext-&gt;get<span class="hljs-constructor">SourceManager()</span>.get<span class="hljs-constructor">PresumedLoc(Loc)</span>;<br>          errs<span class="hljs-literal">()</span> &lt;&lt; <span class="hljs-string">&quot;in &quot;</span> &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PLoc</span>.</span></span>get<span class="hljs-constructor">Filename()</span> &lt;&lt; <span class="hljs-string">&quot; &lt;&quot;</span> &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PLoc</span>.</span></span>get<span class="hljs-constructor">Line()</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PLoc</span>.</span></span>get<span class="hljs-constructor">Column()</span> &lt;&lt; <span class="hljs-string">&quot;&gt;\n&quot;</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  return <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这个方法首先查找消息表达式， 以 <code>Observer</code> 作为接收者， <code>observerWithTarget:action:</code> 作为 selector，然后检查 target 中是否存在相应的方法。虽然这个例子有点儿刻意，但如果你想要利用 AST 对自己的代码库做某些检查，按照上面的例子来就可以了。</p><h3 id="clang的其他特性"><a href="#clang的其他特性" class="headerlink" title="clang的其他特性"></a>clang的其他特性</h3><p>clang还有许多其他的用途。比如，可以写编译器插件（例如，类似上面的检查器例子）并且动态的加载到编译器中。虽然我没有亲自实验过，但是我觉得在 Xcode 中应该是可行的。再比如，也可以通过编写 clang 插件来自定义代码样式（具体可以参见 <a href="http://objccn.io/issue-6-1/">编译过程</a>）。</p><p>另外，如果想对现有的代码做大规模的重构， 而 Xcode 或 AppCode 本身集成的重构工具无法达你的要求，你完全可以用 clang 自己写个重构工具。听起来有点儿可怕，读读下面的文档和教程，你会发现其实没那么难。</p><p>最后，如果是真的有这种需求，你完全可以引导 Xcdoe 使用你自己编译的 clang 。再一次，如果你去尝试，其实这些事儿真的没想象中那么复杂，反而会发现许多个中乐趣</p>]]></content>
    
    
    
    <tags>
      
      <tag>Xcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cocoaPods</title>
    <link href="/2017/02/23/cocoaPods/"/>
    <url>/2017/02/23/cocoaPods/</url>
    
    <content type="html"><![CDATA[<p>CocoaPods 是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具。利用 CocoaPods，可以定义自己的依赖关系 (称作 <code>pods</code>)，并且随着时间的变化，以及在整个开发环境中对第三方库的版本管理非常方便。</p><p>CocoaPods 背后的理念主要体现在两个方面。首先，在工程中引入第三方代码会涉及到许多内容。针对 Objective-C 初级开发者来说，工程文件的配置会让人很沮丧。在配置 build phases 和 linker flags 过程中，会引起许多人为因素的错误。CocoaPods 简化了这一切，它能够自动配置编译选项。</p><p>其次，通过 CocoaPods，可以很方便的查找到新的第三方库。当然，这并不是说你可以简单的将别人提供的库拿来拼凑成一个应用程序。它的真正作用是让你能够找到真正好用的库，以此来缩短我们的开发周期和提升软件的质量。</p><p>本文中，我们将通过分析 <code>pod 安装 (</code>pod install<code>)</code> 的过程，一步一步揭示 CocoaPods 背后的技术。</p><span id="more"></span><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： <a href="https://github.com/CocoaPods/CocoaPods/">CocoaPods&#x2F;CocoaPods</a>, <a href="https://github.com/CocoaPods/Core">CocoaPods&#x2F;Core</a>, 和 <a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods&#x2F;Xcodeproj</a> (是的，CocoaPods 是一个依赖管理工具 – 利用依赖管理进行构建的！)。</p><blockquote><p>编者注 CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的</p></blockquote><h3 id="CocoaPods-x2F-CocoaPod"><a href="#CocoaPods-x2F-CocoaPod" class="headerlink" title="CocoaPods&#x2F;CocoaPod"></a>CocoaPods&#x2F;CocoaPod</h3><p>这是是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。</p><h3 id="CocoaPods-x2F-Core"><a href="#CocoaPods-x2F-Core" class="headerlink" title="CocoaPods&#x2F;Core"></a>CocoaPods&#x2F;Core</h3><p>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。</p><h5 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h5><p>Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <a href="http://guides.cocoapods.org/syntax/podfile.html">Podfile 指南</a>。</p><h4 id="Podspec"><a href="#Podspec" class="headerlink" title="Podspec"></a>Podspec</h4><p><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</p><h3 id="CocoaPods-x2F-Xcodeproj"><a href="#CocoaPods-x2F-Xcodeproj" class="headerlink" title="CocoaPods&#x2F;Xcodeproj"></a>CocoaPods&#x2F;Xcodeproj</h3><p>这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。</p><h2 id="运行-pod-install-命令"><a href="#运行-pod-install-命令" class="headerlink" title="运行 pod install 命令"></a>运行 <code>pod install</code> 命令</h2><p>当运行 <code>pod install</code> 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 <code>--verbose</code>。现在运行这个命令 <code>pod install --verbose</code>，可以看到类似如下的内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ pod install --verbose<br><br>Analyzing dependencies<br><br>Updating spec repositories<br>Updating spec repo <span class="hljs-code">`master`</span><br>  $ /usr/bin/git pull<br>  Already up-to-date.<br><br><br>Finding Podfile changes<br><span class="hljs-bullet">  -</span> AFNetworking<br><span class="hljs-bullet">  -</span> HockeySDK<br><br>Resolving dependencies of <span class="hljs-code">`Podfile`</span><br>Resolving dependencies for target `Pods&#x27; (iOS 6.0)<br><span class="hljs-bullet">  -</span> AFNetworking (= 1.2.1)<br><span class="hljs-bullet">  -</span> SDWebImage (= 3.2)<br><span class="hljs-bullet">    -</span> SDWebImage/Core<br><br>Comparing resolved specification to the sandbox manifest<br><span class="hljs-bullet">  -</span> AFNetworking<br><span class="hljs-bullet">  -</span> HockeySDK<br><br>Downloading dependencies<br><br>-&gt; Using AFNetworking (1.2.1)<br><br>-&gt; Using HockeySDK (3.0.0)<br><span class="hljs-bullet">  -</span> Running pre install hooks<br><span class="hljs-bullet">    -</span> HockeySDK<br><br>Generating Pods project<br><span class="hljs-bullet">  -</span> Creating Pods project<br><span class="hljs-bullet">  -</span> Adding source files to Pods project<br><span class="hljs-bullet">  -</span> Adding frameworks to Pods project<br><span class="hljs-bullet">  -</span> Adding libraries to Pods project<br><span class="hljs-bullet">  -</span> Adding resources to Pods project<br><span class="hljs-bullet">  -</span> Linking headers<br><span class="hljs-bullet">  -</span> Installing libraries<br><span class="hljs-bullet">    -</span> Installing target <span class="hljs-code">`Pods-AFNetworking`</span> iOS 6.0<br><span class="hljs-bullet">      -</span> Adding Build files<br><span class="hljs-bullet">      -</span> Adding resource bundles to Pods project<br><span class="hljs-bullet">      -</span> Generating public xcconfig file at <span class="hljs-code">`Pods/Pods-AFNetworking.xcconfig`</span><br><span class="hljs-bullet">      -</span> Generating private xcconfig file at <span class="hljs-code">`Pods/Pods-AFNetworking-Private.xcconfig`</span><br><span class="hljs-bullet">      -</span> Generating prefix header at <span class="hljs-code">`Pods/Pods-AFNetworking-prefix.pch`</span><br><span class="hljs-bullet">      -</span> Generating dummy source file at <span class="hljs-code">`Pods/Pods-AFNetworking-dummy.m`</span><br><span class="hljs-bullet">    -</span> Installing target <span class="hljs-code">`Pods-HockeySDK`</span> iOS 6.0<br><span class="hljs-bullet">      -</span> Adding Build files<br><span class="hljs-bullet">      -</span> Adding resource bundles to Pods project<br><span class="hljs-bullet">      -</span> Generating public xcconfig file at <span class="hljs-code">`Pods/Pods-HockeySDK.xcconfig`</span><br><span class="hljs-bullet">      -</span> Generating private xcconfig file at <span class="hljs-code">`Pods/Pods-HockeySDK-Private.xcconfig`</span><br><span class="hljs-bullet">      -</span> Generating prefix header at <span class="hljs-code">`Pods/Pods-HockeySDK-prefix.pch`</span><br><span class="hljs-bullet">      -</span> Generating dummy source file at <span class="hljs-code">`Pods/Pods-HockeySDK-dummy.m`</span><br><span class="hljs-bullet">    -</span> Installing target <span class="hljs-code">`Pods`</span> iOS 6.0<br><span class="hljs-bullet">      -</span> Generating xcconfig file at <span class="hljs-code">`Pods/Pods.xcconfig`</span><br><span class="hljs-bullet">      -</span> Generating target environment header at <span class="hljs-code">`Pods/Pods-environment.h`</span><br><span class="hljs-bullet">      -</span> Generating copy resources script at <span class="hljs-code">`Pods/Pods-resources.sh`</span><br><span class="hljs-bullet">      -</span> Generating acknowledgements at <span class="hljs-code">`Pods/Pods-acknowledgements.plist`</span><br><span class="hljs-bullet">      -</span> Generating acknowledgements at <span class="hljs-code">`Pods/Pods-acknowledgements.markdown`</span><br><span class="hljs-bullet">      -</span> Generating dummy source file at <span class="hljs-code">`Pods/Pods-dummy.m`</span><br><span class="hljs-bullet">  -</span> Running post install hooks<br><span class="hljs-bullet">  -</span> Writing Xcode project file to <span class="hljs-code">`Pods/Pods.xcodeproj`</span><br><span class="hljs-bullet">  -</span> Writing Lockfile in <span class="hljs-code">`Podfile.lock`</span><br><span class="hljs-bullet">  -</span> Writing Manifest in <span class="hljs-code">`Pods/Manifest.lock`</span><br><br>Integrating client project<br></code></pre></td></tr></table></figure><p>可以上到，整个过程执行了很多操作，不过把它们分解之后，再看看，会发现它们都很简单。让我们逐步来分析一下。</p><h3 id="读取-Podfile-文件"><a href="#读取-Podfile-文件" class="headerlink" title="读取 Podfile 文件"></a>读取 Podfile 文件</h3><p>你是否对 Podfile 的语法格式感到奇怪过，那是因为这是用 Ruby 语言写的。相较而言，这要比现有的其他格式更加简单好用一些。</p><p>在安装期间，第一步是要弄清楚显示或隐式的声明了哪些第三方库。在加载 podspecs 过程中，CocoaPods 就建立了包括版本信息在内的所有的第三方库的列表。Podspecs 被存储在本地路径 <code>~/.cocoapods</code> 中。</p><h4 id="版本控制和冲突"><a href="#版本控制和冲突" class="headerlink" title="版本控制和冲突"></a>版本控制和冲突</h4><p>CocoaPods 使用<a href="http://semver.org/">语义版本控制 - Semantic Versioning</a> 命名约定来解决对版本的依赖。由于冲突解决系统建立在非重大变更的补丁版本之间，这使得解决依赖关系变得容易很多。例如，两个不同的 pods 依赖于 CocoaLumberjack 的两个版本，假设一个依赖于 <code>2.3.1</code>，另一个依赖于 <code>2.3.3</code>，此时冲突解决系统可以使用最新的版本 <code>2.3.3</code>，因为这个可以向后与 <code>2.3.1</code> 兼容。</p><p>但这并不总是有效。有许多第三方库并不使用这样的约定，这让解决方案变得非常复杂。</p><p>当然，总会有一些冲突需要手动解决。如果一个库依赖于 CocoaLumberjack 的 <code>1.2.5</code>，另外一个库则依赖于 <code>2.3.1</code>，那么只有最终用户通过明确指定使用某个版本来解决冲突。</p><h3 id="加载源文件"><a href="#加载源文件" class="headerlink" title="加载源文件"></a>加载源文件</h3><p>CocoaPods 执行的下一步是加载源码。每个 <code>.podspec</code> 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 <code>~/Library/Caches/CocoaPods</code> 中。这个路径中文件的创建是由 Core gem 负责的。</p><p>CocoaPods 将依照 <code>Podfile</code>、<code>.podspec</code> 和缓存文件的信息将源文件下载到 <code>Pods</code> 目录中。</p><h3 id="生成-Pods-xcodeproj"><a href="#生成-Pods-xcodeproj" class="headerlink" title="生成 Pods.xcodeproj"></a>生成 Pods.xcodeproj</h3><p>每次 <code>pod install</code> 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 <code>Pods.xcodeproj</code>进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中。</p><h3 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h3><p>当 CocoaPods 往工程中添加一个第三方库时，不仅仅是添加代码这么简单，还会添加很多内容。由于每个第三方库有不同的 target，因此对于每个库，都会有几个文件需要添加，每个 target 都需要：</p><ul><li>一个包含编译选项的 <code>.xcconfig</code> 文件</li><li>一个同时包含编译设置和 CocoaPods 默认配置的私有 <code>.xcconfig</code> 文件</li><li>一个编译所必须的 <code>prefix.pch</code> 文件</li><li>另一个编译必须的文件 <code>dummy.m</code></li></ul><p>一旦每个 pod 的 target 完成了上面的内容，整个 <code>Pods</code> target 就会被创建。这增加了相同文件的同时，还增加了另外几个文件。如果源码中包含有资源 bundle，将这个 bundle 添加至程序 target 的指令将被添加到 <code>Pods-Resources.sh</code> 文件中。还有一个名为 <code>Pods-environment.h</code> 的文件，文件中包含了一些宏，这些宏可以用来检查某个组件是否来自 pod。最后，将生成两个认可文件，一个是 <code>plist</code>，另一个是 <code>markdown</code>，这两个文件用于给最终用户查阅相关许可信息。</p><h3 id="写入至磁盘"><a href="#写入至磁盘" class="headerlink" title="写入至磁盘"></a>写入至磁盘</h3><p>直到现在，许多工作都是在内存中进行的。为了让这些成果能被重复利用，我们需要将所有的结果保存到一个文件中。所以 <code>Pods.xcodeproj</code> 文件被写入磁盘，另外两个非常重要的文件：<code>Podfile.lock</code> 和 <code>Manifest.lock</code> 都将被写入磁盘。</p><h4 id="Podfile-lock"><a href="#Podfile-lock" class="headerlink" title="Podfile.lock"></a>Podfile.lock</h4><p>这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。</p><h4 id="Manifest-lock"><a href="#Manifest-lock" class="headerlink" title="Manifest.lock"></a>Manifest.lock</h4><p>这是每次运行 <code>pod install</code> 命令时创建的 <code>Podfile.lock</code> 文件的副本。如果你遇见过这样的错误 <code>沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)</code>，这是因为 Manifest.lock 文件和 <code>Podfile.lock</code> 文件不一致所引起。由于 <code>Pods</code> 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。</p><h3 id="xcproj"><a href="#xcproj" class="headerlink" title="xcproj"></a>xcproj</h3><p>如果你已经依照我们的建议在系统上安装了 <a href="https://github.com/0xced/xcproj">xcproj</a>，它会对 <code>Pods.xcodeproj</code> 文件执行一下 <code>touch</code> 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 <code>Pods.xcodeproj</code> 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>运行 <code>pod install</code> 命令的最终结果是许多文件被添加到你的工程和系统中。这个过程通常只需要几秒钟。当然没有 Cocoapods 这些事也都可以完成。只不过所花的时间就不仅仅是几秒而已了。</p><h2 id="补充：持续集成"><a href="#补充：持续集成" class="headerlink" title="补充：持续集成"></a>补充：持续集成</h2><p>CocoaPods 和持续集成在一起非常融洽。虽然持续集成很大程度上取决于你的项目配置，但 Cocoapods 依然能很容易地对项目进行编译。</p><h3 id="Pods-文件夹的版本控制"><a href="#Pods-文件夹的版本控制" class="headerlink" title="Pods 文件夹的版本控制"></a>Pods 文件夹的版本控制</h3><p>如果 Pods 文件夹和里面的所有内容都在版本控制之中，那么你不需要做什么特别的工作，就能够持续集成。我们只需要给 <code>.xcworkspace</code> 选择一个正确的 scheme 即可。</p><h3 id="不受版本控制的-Pods-文件夹"><a href="#不受版本控制的-Pods-文件夹" class="headerlink" title="不受版本控制的 Pods 文件夹"></a>不受版本控制的 Pods 文件夹</h3><p>如果你的 <code>Pods</code> 文件夹不受版本控制，那么你需要做一些额外的步骤来保证持续集成的顺利进行。最起码，<code>Podfile</code> 文件要放入版本控制之中。另外强烈建议将生成的 <code>.xcworkspace</code> 和 <code>Podfile.lock</code> 文件纳入版本控制，这样不仅简单方便，也能保证所使用 Pod 的版本是正确的。</p><p>一旦配置完毕，在持续集成中运行 CocoaPods 的关键就是确保每次编译之前都执行了 <code>pod install</code> 命令。在大多数系统中，例如 Jenkins 或 Travis，只需要定义一个编译步骤即可 (实际上，Travis 会自动执行 <code>pod install</code> 命令)。对于 <a href="https://groups.google.com/d/msg/cocoapods/eYL8QB3XjyQ/10nmCRN8YxoJ">Xcode Bots，在书写这篇文章时我们还没能找到非常流畅的方式</a>，不过我们正朝着解决方案努力，一旦成功，我们将会立即分享。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>CocoaPods 简化了 Objective-C 的开发流程，我们的目标是让第三方库更容易被发现和添加。了解 CocoaPods 的原理能让你做出更好的应用程序。我们沿着 CocoaPods 的整个执行过程，从载入 specs 文件和源代码、创建 <code>.xcodeproj</code> 文件和所有组件，到将所有文件写入磁盘。所以接下来，我们运行 <code>pod install --verbose</code>，静静观察 CocoaPods 的魔力如何显现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建博客</title>
    <link href="/2016/12/16/build-blog/"/>
    <url>/2016/12/16/build-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p><a href="https://hexo.io/docs/">Hexo官网</a>上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。</p><h3 id="1-Node-js"><a href="#1-Node-js" class="headerlink" title="1.Node.js"></a>1.Node.js</h3><p>用来生成静态页面。移步<a href="https://nodejs.org/en/">Node.js官网</a>，下载v5.5.0 Stable 一路安装即可。</p><h3 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h3><p>用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考Hexo官网上的安装方法。</p><span id="more"></span><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装)</p><blockquote><p>注意坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>终端cd到一个你选定的目录，执行hexo init命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo init blog<br></code></pre></td></tr></table></figure><p>blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>执行如下命令，开启hexo服务器：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>此时，浏览器中打开网址<a href="http://localhost:4000，能看到页面">http://localhost:4000，能看到页面</a></p><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h3><p>登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如xushuanghui.github.io即下图中1所示：</p><p>本地的blog文件夹下内容为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">_<span class="hljs-built_in">config</span>.yml<br>db.<span class="hljs-keyword">json </span><br>node_modules <br>package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">scaffolds</span><br><span class="hljs-keyword"></span>source<br>themes<br></code></pre></td></tr></table></figure><p>终端cd到blog文件夹下，vim打开_config.yml，命令如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>vim _config.yml<br></code></pre></td></tr></table></figure><p>打开后往下滑到最后，修改成下边的样子：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> https:<span class="hljs-comment">//github.com/xushuanghui/xushuanghui.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>你需要将repository后xushuanghui换成你自己的用户名，地址在上图2位置获取。hexo 3.1.1版本后type:值为git。</p><blockquote><p>注意坑二：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记</p></blockquote><p>在blog文件夹目录下执行生成静态页面命令：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span>或者：hexo g<br></code></pre></td></tr></table></figure><p>此时若出现如下报错：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>Local hexo not found in ~/blog<br><span class="hljs-keyword">ERROR </span>Try runing: &#x27;npm install hexo --save&#x27;<br><br>则执行命令：<br>npm install hexo --save<br><br>若无报错，自行忽略此步骤。<br></code></pre></td></tr></table></figure><p>再执行配置命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo deploy或者：hexo d<br></code></pre></td></tr></table></figure><blockquote><p>注意坑三：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save        </span><br></code></pre></td></tr></table></figure><p>再次执行hexo generate和hexo deploy命令。</p><p>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">Username <span class="hljs-keyword">for</span> <span class="hljs-symbol">&#x27;https</span>:<span class="hljs-comment">//github.com&#x27;:</span><br>Password <span class="hljs-keyword">for</span> <span class="hljs-symbol">&#x27;https</span>:<span class="hljs-comment">//github.com&#x27;:</span><br></code></pre></td></tr></table></figure><p>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://xushuanghui.github.io(将xushuanghui换成你的用户名)能看到和打开http//localhost:4000%E6%97%B6%E4%B8%80%E6%A0%B7%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82">http://xushuanghui.github.io（将xushuanghui换成你的用户名）能看到和打开http://localhost:4000时一样的页面。</a></p><p><strong>为避免每次输入Github用户名和密码的麻烦，可参照第二节方法</strong></p><p>###2.添加ssh key到Github<br>####1.1.检查SSH keys是否存在Github<br>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -al ~/.ssh</span><br></code></pre></td></tr></table></figure><p>####1.2.生成新的ssh key<br>执行如下命令生成public&#x2F;private rsa key pair，注意将<code>your_email@example.com</code>换成你自己注册Github的邮箱地址。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;your_email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>默认会在相应路径下（~&#x2F;.ssh&#x2F;id_rsa.pub）生成id_rsa和id_rsa.pub两个文件.</p><p>####1.3.将ssh key添加到Github中<br>Find前往文件夹~&#x2F;.ssh&#x2F;id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p><p>##3.发布文章<br>终端cd到blog文件夹下，执行如下命令新建文章：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;postName&quot;</span><br></code></pre></td></tr></table></figure><p>名为postName.md的文件会建在目录&#x2F;blog&#x2F;source&#x2F;_posts下，postName是文件名，为方便链接不建议掺杂汉字.我使用的是macDown.</p><p>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span><span class="hljs-comment">//生成静态页面</span><br><br>hexo deploy<span class="hljs-comment">//将文章部署到Github</span><br></code></pre></td></tr></table></figure><p>至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。</p><p>##安装theme<br>你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例</p><p>终端cd到 blog 目录下执行如下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/iissnan/</span>hexo-theme-<span class="hljs-keyword">next</span> themes/<span class="hljs-keyword">next</span><br>将blog目录下_config.yml里theme的名称landscape修改为<span class="hljs-keyword">next</span><br></code></pre></td></tr></table></figure><p>终端cd到blog目录下执行如下命令(每次部署文章的步骤)：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ hexo clean<span class="hljs-regexp">//</span>清除缓存文件 (db.json) 和已生成的静态文件 (public)<br><br>$ hexo g<span class="hljs-regexp">//</span>生成缓存和静态文件<br><br>$ hexo d<span class="hljs-regexp">//</span>重新部署到服务器<br></code></pre></td></tr></table></figure><p>至于更改theme内容比如名称、描述、头像等去修改blog&#x2F;_config.yml文件和blog&#x2F;themes&#x2F;next&#x2F;_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。</p><p>##绑定个人域名<br>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到GoDaddy官网，网友亲切称呼为：狗爹，也可以到阿里万网购买。我是在万网买的，可直接在其网站做域名解析。</p><p>##1.Github端<br>在&#x2F;blog&#x2F;themes&#x2F;next&#x2F;source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：gonghonglou.com写入。</p><p>终端cd到blog目录下执行如下命令重新部署：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><br><span class="hljs-variable">$ </span>hexo g<br><br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p>注意坑四：网上许多都是说在Github上直接新建CNAME文件，如果这样的话，在你下一次执行hexo d部署命令后CNAME文件就消失了，因为本地没有此文件嘛。</p><p>##2.域名解析<br>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析</p><p>记录类型：CNAME</p><p>主机记录：将域名解析为example.com（不带www），填写@或者不填写</p><p>记录值：gonghonglou.github.io. (不要忘记最后的.，gonghonglou改为你自己的用户名)，点击保存即可.</p><p>###1、解决 deploy 后博客空白问题<br>昨晚更新了一下 blog 做了个部署，结果blog就挂了，打开 gonghonglou.com 页面显示一片空白。然而 hexo s 开启本地服务器 localhost:4000 访问是没问题的。<br>上网查了一下，原来是 GitHub Pages 禁止了 source&#x2F;vendors 目录的访问。Github 在 11 月 3 日更新了版本。其中包括升级了 Jekyll 到 3.3。Jekyll 为了加快构建速度，忽略 vendor 和 node_modules 文件夹。所以部署到 GitHub 后，识别不到本地下的的这个文件夹 blog&#x2F;themes&#x2F;next&#x2F;source&#x2F;vendor，你只需要给这个文件夹换个名字再重新部署一次就 OK 了。nexT 在 GitHub 上的 isusses 已经给出了解决方案：#1214</p><p>还有另一种解决方案就是升级 nexT 主题，cd 到 blog&#x2F;themes&#x2F;next&#x2F; 下执行命令 git pull 更新。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
